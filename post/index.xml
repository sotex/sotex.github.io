<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 风吹过</title>
    <link>http://sotex.github.io/post/</link>
    <description>Recent content in Posts on 风吹过</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 24 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://sotex.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>cesium地形瓦片(Quantized-mesh)格式</title>
      <link>http://sotex.github.io/post/2019-06-24-cesium%E5%9C%B0%E5%BD%A2%E7%93%A6%E7%89%87quantized-mesh%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-06-24-cesium%E5%9C%B0%E5%BD%A2%E7%93%A6%E7%89%87quantized-mesh%E6%A0%BC%E5%BC%8F/</guid>
      <description>[TOC]
博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/06/24/11080222.html
参考资料：
 quantized-mesh-1.0 terrain format(用于三维可视化的流式海量地形数据集规范) Tile Map Service Specification 国内主要地图瓦片坐标系定义及计算原理 QuantizedMeshTerrainData cesium地形瓦片(HeightMap)格式 Index compression follow-up  1、切片规则 量化网格-1.0格式的地形图瓦片的切分规则和HeightMap的一样，也是Tile Map Service (TMS) 的global-geodetic规则，详情可见cesium地形瓦片(HeightMap)格式中的描述。
如果瓦片集的URL是如下形式:
http://assets.agi.com/stk-terrain/world/tiles  则金字塔根部两个瓦片文件的URL:
 (-180 deg, -90 deg) - (0 deg, 90 deg) - http://assets.agi.com/stk-terrain/world/tiles/0/0/0.terrain (0 deg, -90 deg) - (180 deg, 90 deg) - http://assets.agi.com/stk-terrain/world/tiles/0/1/0.terrain  再下一级的8个瓦片文件的URL:
 (-180 deg, -90 deg) - (-90 deg, 0 deg) - http://assets.agi.com/stk-terrain/world/tiles/1/0/0.terrain (-90 deg, -90 deg) - (0 deg, 0 deg) - http://assets.</description>
    </item>
    
    <item>
      <title>博客园备份提取</title>
      <link>http://sotex.github.io/post/2019-06-24-%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%A4%87%E4%BB%BD%E6%8F%90%E5%8F%96/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-06-24-%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%A4%87%E4%BB%BD%E6%8F%90%E5%8F%96/</guid>
      <description>简述 [TOC]
博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/06/24/11079838.html
在博客园记录了一些文章，想把它备份到github上，还好大部分博文都是markdown格式的，博客园也支持备份导出，但是到处的是单个的XML文件。 为了把每一篇博文单独提取出来，所以写了一个小程序来提取。 github中需要如下图所示的格式，方能正确的分类 文件名需要日期开头，文件内容中最前面一段是文章的一些描述信息
程序代码 程序是用Golang编写的，代码如下：
// cnblogs2githubpages project main.go package main import ( &amp;quot;bytes&amp;quot; &amp;quot;encoding/xml&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;time&amp;quot; ) // 结构体中要能够进行XML解析，则字段名必须以大写开头 // 帖子 type Post struct { XMLName xml.Name `xml:&amp;quot;item&amp;quot;` Title string `xml:&amp;quot;title&amp;quot;` Link string `xml:&amp;quot;link&amp;quot;` Creator string `xml:&amp;quot;dc:creator&amp;quot;` Author string `xml:&amp;quot;author&amp;quot;` PubDate string `xml:&amp;quot;pubDate&amp;quot;` Guid string `xml:&amp;quot;guid&amp;quot;` Description string `xml:&amp;quot;description,CDATA&amp;quot;` } type Blogs struct { XMLName xml.Name `xml:&amp;quot;channel&amp;quot;` Title string `xml:&amp;quot;title&amp;quot;` Link string `xml:&amp;quot;link&amp;quot;` Description string `xml:&amp;quot;description&amp;quot;` Language string `xml:&amp;quot;language&amp;quot;` LastBuildDate string `xml:&amp;quot;lastBuildDate&amp;quot;` PubDate string `xml:&amp;quot;pubDate&amp;quot;` Ttl string `xml:&amp;quot;ttl&amp;quot;` Items []Post `xml:&amp;quot;item&amp;quot;` } type RSS struct { XMLName xml.</description>
    </item>
    
    <item>
      <title>干掉搜狗输入法云代理SogouCloud.exe</title>
      <link>http://sotex.github.io/post/2019-06-24-%E5%B9%B2%E6%8E%89%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E4%BA%91%E4%BB%A3%E7%90%86sogoucloud.exe/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-06-24-%E5%B9%B2%E6%8E%89%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E4%BA%91%E4%BB%A3%E7%90%86sogoucloud.exe/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2019/06/24/10930945.html 搜狗输入法暂时还离不开，但是很讨厌搜狗输入法一直在后台的“搜狗云代理程序”（C:\Program Files (x86)\SogouInput\9.1.0.2657\SogouCloud.exe），占用大量CPU和网络，不知道进行什么活动。 2019年6月24日更新，我已经卸载了搜狗输入法，现在用微软拼音也习惯了。
方法一 删除SogouCloud.exe文件。 这个方法有效，但是搜狗会一直提示要修复，即便是你不修复，也会在某一时间就被修复了。 如果是删除之后替换为一个名为SogouCloud.exe的空文件或者目录，就会经常在启动一些程序的时候，会打开这个文件或目录。 可以通过设置只读权限，来防止被搜狗替换回来。
方法二 在组策略中限制SogouCloud.exe的运行。 打开组策略，定位到用户配置 --&amp;gt; 管理模板 --&amp;gt; 系统 --&amp;gt; 不允许指定 Windows 应用程序 --&amp;gt;点选“已启用” 方法三 写一个最简单的程序来替换掉SogouCloud.exe，这个程序什么都不干，足够的小即可。
#include &amp;lt;Windows.h&amp;gt; int main() { // 保证只有一个进程实例 HANDLE h = CreateMutexA(NULL, TRUE, &amp;quot;SouguCloud.exe&amp;quot;); DWORD dwRet = GetLastError(); if (!h || dwRet == ERROR_ALREADY_EXISTS) { return 0; } // 为了让程序不被替换掉，无限休眠下去 // https://docs.microsoft.com/zh-cn/windows/desktop/api/synchapi/nf-synchapi-sleep Sleep(0xFFFFFFFF); ReleaseMutex(h); return 0; }  编译链接
# 编译 cl SogouCloud.c /c /Fo:SogouCloud.</description>
    </item>
    
    <item>
      <title>cesium地形瓦片(HeightMap)格式</title>
      <link>http://sotex.github.io/post/2019-06-21-cesium%E5%9C%B0%E5%BD%A2%E7%93%A6%E7%89%87heightmap%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-06-21-cesium%E5%9C%B0%E5%BD%A2%E7%93%A6%E7%89%87heightmap%E6%A0%BC%E5%BC%8F/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/06/21/11063905.html
参考资料：
 heightmap 1.0 Tile Map Service Specification 国内主要地图瓦片坐标系定义及计算原理 HeightmapTerrainData  cesium支持多种地形瓦片数据（GoogleEarthEnterpriseTerrainData、QuantizedMeshTerrainData、HeightmapTerrainData），这里不详细叙述每一个，以下说的地形瓦片都是指HeightmapTerrainData。
1、瓦片切分规则 地形瓦片(heightmap-1.0)格式的terrain瓦片集是根据TMS（瓦片地图服务）global-geodetic（全球大地坐标）规则进行切分。
TMS特性简述：
 TMS中一个瓦片地图(TileMap)由一组具有不同比例尺瓦片集(TileSet)组成，每个瓦片集由相同大小格式的规则瓦片平铺而成。下一级的瓦片集由上一级的四叉分割而来（整个地图就是个四叉树结构）。
 对于一个瓦片地图(TileMap)只能支持一个空间参考系(SRS)和一种图像格式，如果需要支持多种就要做多个瓦片地图。
 瓦片地图具有边界范围(BoundingBox)和原点(Origin)，原点是0,0瓦片的左下角（也是-1,-1瓦片的右上角），也就是轴向是向左向上。
  global-geodetic切分规则：
 坐标系为WGS84大地坐标系（&amp;lt;SRS&amp;gt;EPSG:4326&amp;lt;/SRS&amp;gt;）
 对于任意级别（n），该级别瓦片集的瓦片像素分辨率为units-per-pixel = 0.703125/2^n
 0级为覆盖全球的2个256x256像素大小（地理大小为180*180度）的图块，其Origin为-180,90。
  heightmap 1.0 特定规则：
 所有图块都具有后缀名.terrain。
 图块大小为65x65像素大小，实际上图块的最后一行和最后一列是相邻的 东边/南边 图块的第一行/第一列。因为其大小不是256x256，所以其对应级别的分辨率也有所不同。
 图块获取URL示例如下：
 对于顶级的两个图块：
 (-180°, -90°) - (0 °, 90 °) - /path/tilesets/terrain/smallterrain/0/0/0.terrain ( 0°, -90 °) - (180 °, 90 °) - /path/tilesets/terrain/smallterrain/0/1/0.</description>
    </item>
    
    <item>
      <title>Proj.4 升级新版本5.x和6.x</title>
      <link>http://sotex.github.io/post/2019-05-31-proj.4-%E5%8D%87%E7%BA%A7%E6%96%B0%E7%89%88%E6%9C%AC5.x%E5%92%8C6.x/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-05-31-proj.4-%E5%8D%87%E7%BA%A7%E6%96%B0%E7%89%88%E6%9C%AC5.x%E5%92%8C6.x/</guid>
      <description>Proj.4 升级新版本5.x和6.x [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/05/31/10955620.html
0、缘起 今天（2019年5月30日）去编译最新版本的GDAL，发现其对Proj.4的依赖已经要求为6.x版本了。于是去https://github.com/OSGeo/proj.4看了一下最新的代码，又去https://proj4.org/看了一下文档，感觉5.x和6.x的更新挺大的，有必要测试一下，看工作中的项目是不是要升级过来。
1、5.x和6.x更新情况简述 我没有仔细去看5.x版本的代码，仅看了一下最新的Proj.4 版本6的代码，与早前使用的4.9.3版本简单对比了一下，感觉区别还是挺大的，这里列出几点我关注的地方的对比。
1、新版本改用C++编写，相比4.9版本代码量增加了不少，功能也多了不少。代码层次结构清晰了许多，比如各种转换算法都在src/transformations目录下可以找到，各种投影方法相关的算法都在src/projections目录可以找到。
2、支持了从WKT/WKT2字符串和EPSG代码直接创建坐标系对象，也支持导出WKT字符串。老版本中记录EPSG坐标系定义的的nad/epsg被弃用，改用SQLite数据库来记录（在data/sql目录下保存着用于生成proj.db文件的SQL脚本），不过新版本需要依赖SQLite3。
3、新版的实现使用了缓存机制，在创建操作坐标系对象及搜索查找等都有用到。代码可见 src/iso19111/factory.cpp、src/iso19111/crs.cpp、src/iso19111/coordinateoperation.cpp、
src/iso19111/coordinateoperation.cpp 等文件。
4、新版添加了proj_math.h、math.cpp，添加了pj_hypot等函数，这解决了一些编译问题（因为之前版本projects.h中声明了hypot函数，但这个函数在非_WIN32环境中也可能是存在math.h中的）。
以下主要翻译自：PROJ.4 News
PROJ 5.x 更新 此版本的 PROJ 对系统的大地测量功能 (主要是) 引入了一些重要的扩展和改进。
引入新功能的主要驱动因素是动态参考框架的出现、高精度全球导航卫星系统的使用日益增加以及对精确坐标变换的相关需求的增加。虽然旧版本的 PROJ 包含一些大地测量功能, 但新框架为将 PROJ 转变为通用地理空间坐标转换引擎奠定了基础。
内部架构也有了许多变化和改进。到目前为止，这些改进都遵循现有的编程接口。但是这个过程已经显示出需要简化和减少代码库，以支持持续的主动开发。
新的主要版本号使该项目在名称上留下了一些难题。在产品的大部分使用寿命中，它被称为PROJ.4，但由于我们现在已达到版本5，因此名称不再与版本号对齐。
因此，我们决定将名称与版本号和该版本分离，然后将产品简称为PROJ。为了表彰软件的历史，我们将PROJ.4作为组织项目的名称。同一个项目团队也会生成datum-grid 包。
综上所述:
 PROJ.4项目提供产品PROJ，现在版本为5.0.0。 PROJ的基础组件是库libproj。 其他PROJ组件包括应用程序proj，它为libproj提供命令行界面。 PROJ.4项目还分发了基准网格(datum-grid)包，在编写本文时，它是1.6.0版本。  5.0.0 更新  推出新的API在proj.h
 新版API增加了4D空间坐标转换功能 新API中的函数使用proj_命名空间(名称前缀) 新API中的数据类型使用PJ_命名空间(名称前缀)  引入“转换管道”(transformation pipelines)的概念，可以通过 菊花链 的方式简化坐标操作，可以对坐标进行复杂的大地转换。
 采用 OGC/ISO-19100 地理空间标准系列术语。关键定义是：
 在通用层面上，坐标操作是基于从一个坐标参考系统到另一个坐标参考系统的一对一关系的坐标变换。 变换(transformation )是一种坐标操作，其中两个坐标参考系统基于不同的基准，例如，从全局参考框架改变到区域框架。 转换(conversion )是一种坐标操作，其中两个坐标参考系统都基于相同的数据，例如，坐标单位的变化。 投影是从椭球坐标系到平面坐标系的坐标转换。虽然投影只是根据标准进行的转换, 但它们在 PROJ 中被视为单独的实体, 因为它们占库中绝大多数操作。  新操作</description>
    </item>
    
    <item>
      <title>SQLite R*Tree 模块测试</title>
      <link>http://sotex.github.io/post/2019-05-29-sqlite-rtree-%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-05-29-sqlite-rtree-%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/</guid>
      <description>SQLite R*Tree 模块测试 [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/05/29/10941099.html
相关参考：
 MySQL空间索引简单使用
MongoDB地理空间数据存储及检索
The SQLite R*Tree Module
Memory-Mapped I/O
In-Memory Databases
libspatialindex
R* tree - Wikipedia
 我另外做了GEOS STRtree/Quadtree 空间检索的性能，测试代码和数据可见Spatial_Index_Test
1、SQLite R*Tree 模块特性简介 关于SQLite的空间索引相关介绍可以查看官方文档 The SQLite R*Tree Module ，这里只做简单的介绍。
1、SQLite R *Tree模块实现部分在其源代码内（源码下载页面），无需另外合并。但是默认是没有启用的，启用需要定义SQLITE_ENABLE_RTREE=1宏再编译。
2、SQLite R *Tree模块采用虚拟表实现，每个R *Tree索引都是一个虚拟表。对于这个表，其第一列必须是64位有符号整数类型，作为主键。其它的列（2-12列）根据空间维度确定，每个维度包含一对（两列），分别是该维度的最小和最大值。例如：一维R *Tree索引虚拟表包含3列，分别是Int64主键| 最小值| 最大值；二维R*Tree索引虚拟表包含5列，分别是Int64主键| 第一维最小值| 第一维最大值| 第二维最小值| 第二维最大值；3、4、5维R*Tree索引虚拟表列数情况的以此论推，SQLite R *Tree实现不支持宽度超过5维的R *树。
3、对于各个维度的最大最小值列，SQLite中可以使用int32或者float32类型进行数据存储。与其它常规表中的列不同，这里存储就是二进制类型的值，而不是转换为字符串。如果在插入数据的时候，使用了这两者之外的类型，则会进行隐式转换。
-- 创建整型坐标rtree索引虚拟表 CREATE VIRTUAL TABLE intrtree USING rtree_i32(id,x0,x1,y0,y1,z0,z1); -- 创建浮点型坐标rtree索引虚拟表 CREATE VIRTUAL TABLE floatrtree USING rtree(id,x0,x1,y0,y1,z0,z1);  4、SQLite R *Tree中查询并不限制查询的维度一定要与所查询的表中的维度一致，可以仅查询其中的某几个维度（如3维空间仅查询2个维度）。一般来说，约束（维度）越多，查询的范围框越小，速度越快。</description>
    </item>
    
    <item>
      <title>使用 ArcGIS Desktop 切瓦片</title>
      <link>http://sotex.github.io/post/2019-05-28-%E4%BD%BF%E7%94%A8-arcgis-desktop-%E5%88%87%E7%93%A6%E7%89%87/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-05-28-%E4%BD%BF%E7%94%A8-arcgis-desktop-%E5%88%87%E7%93%A6%E7%89%87/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/05/28/10936522.html
1、生成切片缓存切片方案 ArcGIS有默认的切片方案，如果需要自定义切片规则，需要先生成一个切片方案。
打开ArcMap，打开 工具箱(Tools Box) &amp;ndash;&amp;gt; 系统工具箱(System Tools Box) &amp;ndash;&amp;gt; 数据管理工具(Data Managment Tools) &amp;ndash;&amp;gt; 切片缓存(Tile Cache)&amp;ndash;&amp;gt;生成切片缓存切片方案(Generate Tile Cache Tiling Scheme)
各个选项简要说明：
 1、输入数据源：这个是用来确定这个切片方案能够切多少级的，切片的最大级别的分辨率最多能够是小于等于输入的数据源的分辨率，也就是说最多能切到刚好等于或者小于数据源的分辨率，就不能再继续往下切了。 2、输出切片方案：也就是这个切片方案的保存位置，不能是一个已经存在的文件。 3、生成方案：二选一，NEW 表示创建一个新的，PREDEFINED 表示基于一个已有的切片方案来创建。 4、比例级数：指定要切多少级，这个数据会自动根据输入数据源的分辨率进行调整。 5、比例：指定比例级数后，会自动计算出相应的比例系数列表，如果需要添加，则可以在这里输入后，点击右侧的+按钮进行添加。移除则是在表格中选择后，点击右侧的X按钮进行移除。 6、切片原点：就是切片的第一个瓦片(0,0)的左上角点坐标。 7、每英寸的点数(像素)：就是DPI的设置，一般国内的切片96（天地图），但是WMTS服务通常是90.714（WMTS标准里面就是，但是ArcGIS Desktop10.2/3版本，由于计算使用的经纬度与米的换算系数偏小的原因，导致其计算比例尺与分辨率的结果有问题，其加载WMTS图层时可见） 8、切片大小（以像素为单位）：瓦片的大小，通常是256 x 256。经过我的测试，大部分情况下512 x 512的瓦片大小，在切瓦片的速度和发布成服务后的浏览速度上，都是优于256大小的，1024大小的瓦片在大多数时候也是优于256的，但与512差异不大。 9、切片格式：主要是PNGx、JPEG、MIXED。MIXED混合格式，指的是在切片的时候，如果检测到瓦片内有透明区域，则这个瓦片使用PNG32格式，如果没有，则使用JPEG格式。这样做可以在不失去透明通道的前提下，有效降低瓦片数据文件的大小。 10、切片压缩质量：仅对JPEG（包括MIXED中使用JPEG的瓦片）有效，参数值需要介于1-100之间，默认是75。 11、存储格式：COMPACT 紧凑格式，也就是把多个瓦片（最多128x128个）存储到一个bundle/bundlx文件的形式，避免出现大量碎文件。EXPLODED 分散格式，就是把每一个瓦片存储成一个图片文件，这个形式的瓦片不能和tpk包一起使用。  参考：Generate Tile Cache Tiling Scheme
2、切瓦片 切瓦片在ArcGIS里面没有直接使用这个名称，在“管理切片缓存”里面。
打开ArcMap，打开 工具箱(Tools Box) &amp;ndash;&amp;gt; 系统工具箱(System Tools Box) &amp;ndash;&amp;gt; 数据管理工具(Data Managment Tools) &amp;ndash;&amp;gt; 切片缓存(Tile Cache)&amp;ndash;&amp;gt;管理切片缓存(Manage Tile Cache)</description>
    </item>
    
    <item>
      <title>使用hdfs-mount挂载HDFS</title>
      <link>http://sotex.github.io/post/2019-05-22-%E4%BD%BF%E7%94%A8hdfs-mount%E6%8C%82%E8%BD%BDhdfs/</link>
      <pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-05-22-%E4%BD%BF%E7%94%A8hdfs-mount%E6%8C%82%E8%BD%BDhdfs/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/05/22/10906275.html
hdfs-mount是一个将HDFS挂载为本地Linux文件系统的工具，使用go语言开发，不依赖libdfs和java虚拟机。它允许将远程HDFS作为本地Linux文件系统挂载，并允许任意应用程序或shell脚本以高效和安全的方式访问HDFS作为普通文件和目录。
1、特性(计划)简介 以下翻译自 hdfs-mount/README.md
 高性能  使用protocol buffers协议直接连接HDFS和Linux内核FUSE接口（无需Java虚拟机） 针对吞吐量密集型工作负载进行设计和优化（尽可能以延迟交换吞吐量） 完全流式传输和自动预读支持 并发操作 在内存中缓存元数据 (速度非常快 l!)  高稳定性和强大的故障处理行为  自动重试和故障转移，全部可配置 可选的延迟挂载, 在 HDFS 可用之前  读写操作都支持  支持随机写入[慢，但功能正确] 支持文件截断  （可选）扩展ZIP存档，并根据需要提取内容  这为”数百万个小文件在HDFS上“(millions of small files on HDFS)问题提供了有效的解决方案  对CoreOS和Docker友好  可选择打包为静态链接的独立可执行文件   2、构建程序 我的系统环境是CentOS 7.0 x86_64，以下所有操作都是基于此。
先安装编译所需的必要工具软件：
yum install make golang  然后下载hdfs-mount的源码回来，源码仓库地址:https://github.com/microsoft/hdfs-mount.git
git clone https://github.com/microsoft/hdfs-mount.git  然后就可以编译了，先进入源码目录
# 进入源码根目录 cd hdfs-mount # 执行构建 make  编译的过程中因为要下载依赖（bazil/fuse、x/net/context、protobuf/proto），所以需要保持网络通畅。</description>
    </item>
    
    <item>
      <title>Qt Multimedia Backends（多媒体后端）翻译</title>
      <link>http://sotex.github.io/post/2019-04-30-qt-multimedia-backends%E5%A4%9A%E5%AA%92%E4%BD%93%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-04-30-qt-multimedia-backends%E5%A4%9A%E5%AA%92%E4%BD%93%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/04/30/10795485.html
原文地址：
Qt Multimedia Backends
Qt 5.11 Multimedia Backends
对于大多数功能，Qt Multimedia建立在底层系统的多媒体框架之上。因此，有基于不同技术和API的多个多媒体后端。平台特定的库和Qt Multimedia之间使用插件进行结合。 Qt Multimedia目前有三种插件：
 MediaService（媒体服务）插件，提供媒体播放器，摄像头，收音机和录音功能。 Audio（音频）插件，提供低延迟（low-latency）音频支持。 PlaylistFormat（播放列表格式）插件，支持特定的播放列表文件格式。  插件不一定实现所有可能的功能, 不同的后端具有不同的功能。下表概述了 Qt 5.11 中每个后端所支持的内容。
MediaService plugins 媒体服务插件 不同后端支持的媒体播放器功能:     DirectShow (Windows) Media Foundation (Windows) AV Foundation (OSX/ iOS) GStreamer (Unix) Android BlackBerry WinRT     媒体播放控制（MediaPlayer control） √ √ √ √ √ √ √   URL 媒体源 (本地和远程) √ √ √ √ √ √ √   流媒体源（Stream source） √ √  √   √   媒体元信息（Metadata） √ √ 部分 √ √ √    播放速率（Playback rate） √ √ √ √  √ √   轨道选择（Track selection）    √      硬件解码（HW decoding） √ √ √  √ √ √   视频窗口(输出)控制（Video window control） √ √ √ √  √    视频部件(输出)控制（Video widget control）   √ √      视频渲染控制（Video renderer control）(包括OpenGL纹理) √ √ √ √ √ √ √   音频Audio probe √ √  √      视频探针（Video Probe） √ √  √       后端支持的摄像头（相机）功能     DirectShow (Windows) Media Foundation (Windows) AV Foundation (OSX/ iOS) GStreamer (Unix) Android BlackBerry WinRT     s摄像头控制（Camera control） √  √ √ √ √ √   视频窗口(输出)控制（Video window control）    √      视频部件(输出)控制（Video widget control） √   √      视频渲染控制（Video renderer control）(包括OpenGL纹理) √  √ √ √ √ √   音频探针（Audio probe）          视频探针（Video probe） √  √  √  √   视口查找设置（ViewFinder settings） √  √ √ √ √    影像捕获（Image capture） √  √ √ √ √ √   捕获目标（Capture destination） 文件, 内存缓存区  文件 文件, 内存缓存区 文件, 内存缓存区 文件, 内存缓存区 文件   影像设置（Image settings）   分辨率 分辨率 分辨率, 质量 分辨率, 质量 分辨率   缩放（Zoom） √(depends on HW)  √(only iOS &amp;gt;= 7.</description>
    </item>
    
    <item>
      <title>MinFilter(MaxFilter)快速算法C&#43;&#43;实现</title>
      <link>http://sotex.github.io/post/2019-04-23-minfiltermaxfilter%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95c&#43;&#43;%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-04-23-minfiltermaxfilter%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95c&#43;&#43;%E5%AE%9E%E7%8E%B0/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/04/23/10758029.html
参考资料：
 MinFilter - Wolfram 语言与系统参考资料中心 ImageFilter - Wolfram 语言与系统参考资料中心 Streaming Maximum-Minimum Filter Using No More than Three Comparisons per Element [SSE图像算法优化系列七：基于SSE实现的极速的矩形核腐蚀和膨胀（最大值和最小值）算法。]  1、算法简述 1.1、MinFilter(MaxFilter) 算法简述 MinFilter（MaxFilter）算法是用于对一维或多维数据进行滤波的算法，滤波的结果为原数据中对应位置领域r内的最小（最大）值。在数据的边界处，使用较小（较大）的邻域.。
1.2、MinFilter(MaxFilter) 快速算法简述 对于MinFilter(MaxFilter)的快速算法，思想来自于这篇论文Streaming Maximum-Minimum Filter Using No More than Three Comparisons per Element。在网上找到了这张图，但这个图也没有什么文字说明，并不是很清楚。
下面按照我实现的时候的思路，来说一下我的理解。
首先，对于一个多维的数据，都可以逐个维度进行处理。比如说一个图片，也就是二维数据，可以先对每一行进行处理，然后再对每一列进行处理，这样得到的结果与行列同时处理是一样的。
假设r=1 原始数据 --&amp;gt; 逐行处理 --&amp;gt; 逐列处理 5 2 1 3 4 2 1 1 1 3 2 1 1 1 3 6 9 8 4 7 6 6 4 4 4 2 1 1 0 0 7 3 8 2 0 3 3 2 0 0 0 0 0 0 0 9 0 1 5 6 0 0 0 1 5 0 0 0 0 0 原始数据 --&amp;gt; 逐行列处理 5 2 1 3 4 2 1 1 1 3 6 9 8 4 7 2 1 1 0 0 7 3 8 2 0 0 0 0 0 0 9 0 1 5 6 0 0 0 0 0  因此算法的关键在于提高一行数据处理的效率。</description>
    </item>
    
    <item>
      <title>RGBA alpha 透明度混合算法实现和测试</title>
      <link>http://sotex.github.io/post/2019-04-17-rgba-alpha-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-04-17-rgba-alpha-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/04/17/10724803.html
1、算法叙述 算法参考自：【RGBA alpha 透明度混合算法】 ，下面的叙述和实现中有一些个人修改在里面。
1.1、透明度混合算法1 **R1、G1、B1、Alpha1 为前景颜色值，R2、G2、B2、Alpha2** 为背景颜色值，则：
Alpha = 1 - (1 - Alpha1) * ( 1 - Alpha2) R = (R1 * Alpha1 + R2 * Alpha2 * (1-Alpha1))/Alpha G = (G1 * Alpha1 + G2 * Alpha2 * (1-Alpha1))/Alpha B = (B1 * Alpha1 + B2 * Alpha2 * (1-Alpha1))/Alpha  这里的Alpha取值范围是[0,1]，需要使用到浮点计算（实数计算）。对于我们常见的8位图像，我们可以将其值域改为[0,255]进行计算，具体的见下面测试代码。
1.2、AlphaBlend算法介绍 混合算法目前在常用到的算法是AlphaBlend。 计算公式如下:假设一幅图像是A，另一幅透明的图像是B，那么透过B去看A，看上去的图像C就是B和A的混合图像， 设B图像的透明度为alpha(取值为0-1，1为完全透明，0为完全不透明). Alpha混合公式如下：
R(C)=(1-alpha)*R(B) + alpha*R(A) G(C)=(1-alpha)*G(B) + alpha*G(A) B(C)=(1-alpha)*B(B) + alpha*B(A)  R(x)、G(x)、B(x)分别指颜色x的RGB分量原色值。从上面的公式可以知道，Alpha其实是一个决定混合透明度的数值。</description>
    </item>
    
    <item>
      <title>libfacedetection简单使用记录</title>
      <link>http://sotex.github.io/post/2019-04-16-libfacedetection%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-04-16-libfacedetection%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2019/04/16/10716214.html
1、源码下载 直接从github上克隆项目仓库。
git clone https://github.com/ShiqiYu/libfacedetection.git  2、编译 2.1、linux 这个项目使用了cmake脚本，先生成makefile。（我这里是在ArchLinux x86_64环境下测试的）
cmake -DENABLE_NEON=OFF -DCMAKE_BUILD_TYPE=RELEASE .  执行上面的命令成功后，执行下面语句进行编译
make -j4  编译完成后会同时生成动态库和静态库
[ 90%] Linking CXX static library libfacedetection.a [100%] Linking CXX shared library libfacedetection.so  2.2、Windows MINGW64 这里和上面也是一样的。先使用cmake生产Makefile文件，然后执行编译即可。这里我指定了使用g++作为C++的编译器，因为如果不指定会使用gcc去链接，导致生成动态库的时候找不到c++标准库的一些定义。
cmake -DENABLE_NEON=OFF -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_CXX_COMPILER=g++ .  其它的与上面linux的一致。
备注：我这里使用的是MSYS2环境，直接使用pacman命令安装的gcc/g++。
2.3、VS2017 NMake编译 因为就这么几个文件，生成一个庞大的VS工程实在有点多余，所以我简单写了一个Makefile.vc文件，使用nmake脚本来生成静态库（因为源码中并没有对函数接口进行export，所以只生成静态库）。
Makefile.vc 文件内容如下：
# 编译参数设置 CXX = cl DEFINES = -DWIN32 -DWIN64 -DNDEBUG -D_WINDLL CXXFLAGS = -nologo -Zc:wchar_t -FS -Zc:rvalueCast -Zc:inline -Zc:strictStrings -Zc:throwingNew -Zc:referenceBinding -O2 -MD -W3 -w34100 -w34189 -w44996 -w44456 -w44457 -w44458 -wd4577 -wd4467 -EHsc $(DEFINES) INCPATH = -I.</description>
    </item>
    
    <item>
      <title>GDAL指定自定义的金字塔目录</title>
      <link>http://sotex.github.io/post/2019-02-21-gdal%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-02-21-gdal%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94%E7%9B%AE%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2019/02/21/10411893.html
缘起 对于一般的遥感影像文件，金字塔文件默认都是与影像文件放在同一个目录下，金字塔文件名一般与源影像文件名相同，但后缀名不同。或者金字塔内建于影像内部，但这不是这里所涉及的。 在使用ArcGIS桌面版或者Erdas遥感影像处理软件打开遥感影像文件的时候，如果影像不含(带有)金字塔，则会提示是否创建金字塔。
我们碰到这么一种情况，就是原始影像是不带金字塔的，并且所在的目录不允许修改，也就是不能将金字塔创建在其中，原始影像文件更是不允许修改，所以也不能更新内建金字塔。
解决 对于这个问题，为了加速影像的浏览，只能将金字塔建立在外部的目录，而读取的时候根据读取输出的分辨率，来确认是使用源影像读取还是使用金字塔文件读取，这都需要自己控制。 因为自己控制会将一些控制流程变复杂，所以我想让GDAL直接支持索引到这个外部的金字塔文件。
 在GDAL中，金字塔称之为Overviews(概览视图)，所以与之相关的接口都带有Overview单词。
 我看了GDAL的RasterIO流程相关的代码，简单的制作了如下的流程图：
GDALDefaultOverviews::OverviewScan()函数 与金字塔路径查找的关键代码在函数GDALDefaultOverviews::OverviewScan()中。
通过查看其实现代码，和被调用时候的参数（参数在GDALDefaultOverviews::Initialize函数被调用的时候确定，可以搜索poDS-&amp;gt;oOvManager.Initialize查看，都是在对应格式的XXXDataset::Open()函数中被调用，不同格式影像调用时候传的参数可能不同），可以知道GDAL搜寻金字塔的方式与顺序。
这里不详细说这里面的流程结构了，一些判断条件也略过，只大概说一下搜索顺序（如果有内建金字塔则不会读取外部金字塔）：
 1、.ovr后缀金字塔文件 2、.aux后缀金字塔文件 3、.rrd后缀金字塔文件（如果配置有USE_RRD=YES） 4、影像元数据Metadata中的OVERVIEW_FILE指定的金字塔路径  如果需要使用到自定义的金字塔文件，可以在此处修改，添加一段搜索代码,示例如下：
if( poODS == nullptr ) { osOvrFilename = MyOverviewFileSearch(pszInitName); poODS = GDALDataset::Open(osOvrFilename, GDAL_OF_RASTER | (poDS-&amp;gt;GetAccess() == GA_Update ? GDAL_OF_UPDATE: 0)); }  MyOverviewFileSearch是用于搜索自定义路径下金字塔的函数。
关于 GDALRasterBand::GetOverview 上面说如果有内建金字塔则不会读取外部金字塔，这个实际上是各个影像文件格式的相关代码里面自己定义的。 因为virtual GDALRasterBand* GDALRasterBand::GetOverview(int);本来就是一个虚函数，而GDAL中又基本都是依赖指针进行操作，所以实际上会调用各自的实现。
以GeoTiff格式为例，在它的Overview相关函数中就是先搜索Tiff目录内的金字塔，如果找不到才调用GDALRasterBand中对应的接口，进而访问外部金字塔文件。
例如以下代码：
/************************************************************************/ /* GetOverviewCount() */ /************************************************************************/ int GTiffRasterBand::GetOverviewCount() { poGDS-&amp;gt;ScanDirectories(); if( poGDS-&amp;gt;nOverviewCount &amp;gt; 0 ) { return poGDS-&amp;gt;nOverviewCount; } const int nOverviewCount = GDALRasterBand::GetOverviewCount(); if( nOverviewCount &amp;gt; 0 ) return nOverviewCount; // Implicit JPEG overviews are normally hidden, except when doing // IRasterIO() operations.</description>
    </item>
    
    <item>
      <title>在GDAL中添加GDALRasterizeGeometriesBuf函数</title>
      <link>http://sotex.github.io/post/2019-02-13-%E5%9C%A8gdal%E4%B8%AD%E6%B7%BB%E5%8A%A0gdalrasterizegeometriesbuf%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-02-13-%E5%9C%A8gdal%E4%B8%AD%E6%B7%BB%E5%8A%A0gdalrasterizegeometriesbuf%E5%87%BD%E6%95%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2019/02/13/10368595.html
缘起 GDAL的栅格化算法中有GDALRasterizeLayers、GDALRasterizeLayersBuf和GDALRasterizeGeometries函数，但是没有GDALRasterizeGeometriesBuf函数（GDAL项目不打算添加这个函数，因为增加一个函数会增加维护成本）。而栅格化算法的实际实现函数gv_rasterize_one_shape并不导出，所以在使用的时候造成了一定的不便。 虽然可以通过MEMDataset的方式，调用GDALRasterizeGeometries达到目的，但是不够直接和高效，所以我写了GDALRasterizeGeometriesBuf函数。 个人认为比较灵活的方式，还是将gv_rasterize_one_shape函数导出，以便自由使用。
代码 修改gdal/alg/gdal_alg.h头文件，在GDALRasterizeGeometries函数声明下添加GDALRasterizeGeometriesBuf函数声明。
CPLErr CPL_DLL GDALRasterizeGeometriesBuf( void *pData, int nBufXSize, int nBufYSize, GDALDataType eBufType, int nPixelSpace, int nLineSpace, int nGeomCount, OGRGeometryH *pahGeometries, const char *pszGeomProjection, const char *pszDstProjection, double *padfDstGeoTransform, GDALTransformerFunc pfnTransformer, void *pTransformArg, double dfBurnValue, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg );  修改gdal/alg/gdalrasterize.cpp文件，添加GDALRasterizeGeometriesBuf函数的实现，代码如下：
/************************************************************************/ /* GDALRasterizeGeometriesBuf() */ /************************************************************************/ /** * Burn geometries into raster. * * Rasterize a list of geometric objects into a raster dataset.</description>
    </item>
    
    <item>
      <title>多时相地图瓦片简单设想</title>
      <link>http://sotex.github.io/post/2019-02-12-%E5%A4%9A%E6%97%B6%E7%9B%B8%E5%9C%B0%E5%9B%BE%E7%93%A6%E7%89%87%E7%AE%80%E5%8D%95%E8%AE%BE%E6%83%B3/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-02-12-%E5%A4%9A%E6%97%B6%E7%9B%B8%E5%9C%B0%E5%9B%BE%E7%93%A6%E7%89%87%E7%AE%80%E5%8D%95%E8%AE%BE%E6%83%B3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2019/02/12/10364660.html
地图、遥感影像及瓦片地图相关文章  瓦片地图的前世今生 国内主要地图瓦片坐标系定义及计算原理 地图瓦片与四叉树（二） 地图瓦片与四叉树（二） 一个有意思的坐标系投影介绍网站 一个小游戏让你彻底弄懂墨卡托投影 百度JavaScript API中经纬度坐标转瓦片坐标bug OpenGIS Web Map Tile Service Implementation Standard 揭秘Google地图背后的秘密：隐藏的算法与人工操作  地图点聚合优化方案 动态地图标注算法 ArcGIS支持栅格文件格式  多时相遥感影像相关文章  百度百科-多时相 如何查看下载不同年份的历史影像(多时相影像)卫星地图 影像信息提取之——多时相影像动态检测 【测绘学报-多时相遥感影像变化检测的现状与展望】 【国土资源遥感-融合时间特征的高分辨率遥感影像分类】 遥感的本质——远程收集的信息  多时相地图的一种实现原理——视频瓦片 对于同一位置的不同时期的影像，大部分地区在很大几率上其变化是极小的，所以如果每一时期的影像都做成单独的地图瓦片图层，是极不划算的做法。
使用类似于视频压缩的方式（关键帧+前向/后向帧），则可以节约很大的数据量。与视频存在固定帧率参数不同，不同遥感影像的时间往往不是等差数列关系，所以应该对每一帧都带有独立的时间记录。在利用这个视频瓦片的时候，应用程序可根据关键帧解析出所有时间的影像帧。
如果是用于对外提供多时相的可视化影像地图服务（多时相瓦片地图），那么这将是一种极大节省数据传输量的方式，因为每一个瓦片都带有了多个时期的影像数据，完全可以由客户端控制显示那一时期影像（帧）。或者还可以在客户端实现快速的变化检测统计输出（每一个瓦片非关键帧的大小等相关信息就可以粗略统计变化程度）。</description>
    </item>
    
    <item>
      <title>记录一次使用VS2015编译错误的原因查找(boost&#43;gdal)</title>
      <link>http://sotex.github.io/post/2019-01-08-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8vs2015%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9F%A5%E6%89%BEboost&#43;gdal/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2019-01-08-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8vs2015%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9F%A5%E6%89%BEboost&#43;gdal/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2019/01/08/10240286.html
编译错误说明 在一个解决方案中的项目A中使用到了boost，完全没有问题。在项目B中也使用了boost库，编译的时候就产生了一堆错误。 原因查找 两个项目通过对比，唯一的不同就是项目B使用了gdal库，通过报错可以看到 因为我使用的boost是通过vcpkg安装的，而GDAL库是在http://www.gisinternals.com下载的。 下载的GDAL库中包含了一部分boost库的内容，而两个不同位置的头文件内容不一样，导致在include的时候没有使用到正确的那一个头文件（两个boost编译的配置信息不一样），所以在编译的时候导致了错误。
解决办法 这里需要屏蔽掉GDAL\include目录下的boost相关文件，但是我在VS的工程设置以及cl.exe的参数中都没有找到禁用某个include目录的选项。如果不屏蔽也要使得vcpkg安装的boost库先被搜索，那么就需要调整搜索顺序，这个也不好弄。 因为gdal中的boost并不被使用，使用直接改名或删除算了。</description>
    </item>
    
    <item>
      <title>MongoDB下Map-Reduce使用简单翻译及示例</title>
      <link>http://sotex.github.io/post/2018-12-10-mongodb%E4%B8%8Bmap-reduce%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%BF%BB%E8%AF%91%E5%8F%8A%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-12-10-mongodb%E4%B8%8Bmap-reduce%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%BF%BB%E8%AF%91%E5%8F%8A%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/12/10/10097035.html
  原文地址https://docs.mongodb.com/manual/core/map-reduce/ Map-Reduce 示例   Map-reduce是一种数据处理范例，用于将大量数据压缩为有用的聚合结果。 对于map-reduce操作，MongoDB提供了mapReduce数据库命令。 一个简单的map-reduce示例如下：
在此map-reduce操作中，MongoDB将映射(map)操作应用于每个输入文档（即集合中与查询条件匹配的文档）。map函数提交(emit)一个键值对(key-value)。对于具有多个值的key钥，MongoDB应用reduce操作，该操作用于聚合数据。然后MongoDB将结果存储在一个集合中。reduce函数的输出还可以选择通过finalize函数以进一步压缩或处理聚合的结果。
MongoDB中的所有map-reduce函数都是JavaScript，并在mongod进程中运行。 Map-reduce操作将单个集合的文档作为输入，并可在开始映射阶段之前执行任意排序和限制。 mapReduce可以将map-reduce操作的结果作为文档返回，也可以将结果写入集合。 输入和输出集合可以分片。
对于大多数聚合操作，聚合管道( Aggregation Pipeline)[https://docs.mongodb.com/manual/core/aggregation-pipeline/]提供更好的性能和更一致的接口。 但是，map-reduce操作提供了一些目前在聚合管道中不可用的灵活性。
Map-Reduce JavaScript 函数 在MongoDB中，map-reduce操作使用自定义JavaScript函数将值(value)映射或关联到键(key)。 如果某个键(key)有对应多个值(value)，则该操作应该将键的值reduces为单个对象。
使用自定义JavaScript函数可以灵活地进行map-reduce操作。 例如，在处理文档时，map函数可以创建多个键和值映射或不进行映射。 Map-reduce操作还可以使用自定义JavaScript函数对映射的结果进行最终修改，并在映射操作的最后阶段进行reduce操作，执行其他计算。
Map-Reduce 行为 在MongoDB中，map-reduce操作可以将结果写入集合或返回结果内联。 如果将map-reduce输出写入集合，则可以在合并替换，合并或减少新结果与先前结果的同一输入集合上执行后续map-reduce操作。 有关详细信息和示例，请参阅mapReduce和Perform Incremental(执行增量) Map-Reduce。
当返回map-reduce操作的内联结果时，结果文档必须在BSON文档大小限制内，该限制当前为16兆字节。 有关map-reduce操作的限制和限制的其他信息，请参阅mapReduce参考页面。
MongoDB支持分片集合上的map-reduce操作。 Map-reduce操作还可以将结果输出到分片集合。 请参见Map-Reduce and Sharded Collections。
Views(视图)不支持map-reduce操作。
一个简单的测试 MongoDB地理空间数据存储及检索 上面链接是之前曾经做过一个全国县级行政边界矢量入库到MongoDB的记录，这里用它来测试一下。
简单的测试一下全国每个省都有多少个县
db.getCollection(&#39;xzbj&#39;).mapReduce( function() { emit(this.properties.sheng,1);}, function(key,values){return Array.sum(values);}, { query:{}, out:&amp;quot;xian_count&amp;quot; } )  这里将结果输出到了xian_count这个新的集合中，可以打开这个集合查看结果。 上面的query也可以没有，就是默认集合内全部文档。 如果不想把结果输出到一个集合，直接显示结果，则可以使用out: { inline: 1 }。</description>
    </item>
    
    <item>
      <title>Pilosa文档翻译（三）示例</title>
      <link>http://sotex.github.io/post/2018-12-03-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%89%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-12-03-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%89%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/12/03/10058051.html
 原文地址：https://www.pilosa.com/docs/latest/examples/ 位图数据库：Pilosa查询十亿级出租车搭乘数据案例
 简单说明 Introduction 纽约市发布了一个非常详细的包含了超过10亿条出租车搭乘数据的集合。该数据已经成为科技博客分析的热门目标，并且已经得到了很好的研究。出于这个原因，我们认为将这些数据导入Pilosa，以便确定同一数据集情况下与其他数据存储和技术进行比较。
一般来说，传输(Transportation)是Pilosa的值得关注的用例，因为它通常涉及多个不同的数据源，以及高速率，实时和极大量的数据（特别是如果想得出合理的结论）。
我们编写了一个工具来帮助将NYC(纽约市)出租车数据导入Pilosa这个工具是PDK（Pilosa开发工具包）的一部分，并利用了许多可重复使用的模块，这些模块也可以帮助您导入其他数据。 接下来，我们将逐步解释整个过程。
初始设置之后，PDK导入工具会执行我们定义Pilosa架构所需的一切，相应地将数据映射到位图，然后将其导入Pilosa。
数据模型 Data Model 纽约出租车数据由以下列出的许多csv文件组成：http：//www.nyc.gov/html/tlc/html/about/trip_record_data.shtml。 这些数据文件大约有20列，其中大约一半与我们正在研究的基准查询相关：
 距离(Distance): miles(英里), floating point(浮点值) 车费(Fare): dollars(美元), floating point(浮点值) 乘客人数(Number of passengers): integer(整数值) 下车位置(Dropoff location): latitude and longitude(经纬度), floating point(浮点值) 上车位置(Pickup location): latitude and longitude(经纬度), floating point(浮点值) 下车时间(Dropoff time): timestamp(时间戳) 上车时间(Pickup time): timestamp(时间戳)  注意：下面表格中的row ID是指记录的取值范围，不要理解成MySQL等数据库的rowID。 我们导入这些字段，从每个字段创建一个或多个Pilosa字段：
   字段(Field) 映射(Mapping)     cab_type(出租车类型) 直接映射整数枚举值 → row ID   dist_miles(距离) 四舍五入round(dist) → row ID   total_amount_dollars(总金额) 四舍五入round(dist) → row ID   passenger_count(乘车人数) 直接映射整数值 → row ID   drop_grid_id(下车位置网格ID) (lat, lon) → 100x100矩形分割网格 → cell(格子) ID   drop_year 年份year(timestamp) → row ID   drop_month 月份month(timestamp) → row ID   drop_day 该月第几天day(timestamp) → row ID   drop_time(下车时间) 该天中的时间映射到48个半小时组成的桶中   pickup_grid_id(下车位置网格ID) (lat, lon) → 100x100矩形分割网格 → cell ID   pickup_year year(timestamp) → row ID   pickup_month month(timestamp) → row ID   pickup_day day(timestamp) → row ID   pickup_time(上车时间) time of day mapped to one of 48 half-hour buckets → row ID    我们还创建了两个附加字段表示持续时间和每一次乘坐的平均速度：</description>
    </item>
    
    <item>
      <title>Pilosa文档翻译（二）入门指南</title>
      <link>http://sotex.github.io/post/2018-11-28-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-11-28-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%BA%8C%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/11/28/10027502.html
Pilosa支持默认使用JSON的HTTP接口。 任何HTTP工具都可用于与Pilosa服务器进行交互。 本文档中的示例将使用curl，默认情况下可用于许多类UNIX系统，包括Linux和MacOS。 Windows用户可以在这里下载curl。
 请注意，Pilosa服务器对打开文件的上限有要求。 检查系统文档，了解如何在达到该限制时增加它。 有关详细信息，请参阅Open File Limits。
 开始 Pilosa 按照安装文档中的步骤安装Pilosa。 在终端中执行以下命令，以使用默认配置运行Pilosa（Pilosa将在localhost：10101中可用）：
pilosa server  如果您使用的是Docker镜像，则可以使用以下命令在默认地址上运行短暂的Pilosa容器：
docker run -it --rm --name pilosa -p 10101:10101 pilosa/pilosa:latest  确保Pilosa正在运行：
curl localhost:10101/status  {&amp;quot;state&amp;quot;:&amp;quot;NORMAL&amp;quot;,&amp;quot;nodes&amp;quot;:[{&amp;quot;id&amp;quot;:&amp;quot;91715a50-7d50-4c54-9a03-873801da1cd1&amp;quot;,&amp;quot;uri&amp;quot;:{&amp;quot;scheme&amp;quot;:&amp;quot;http&amp;quot;,&amp;quot;host&amp;quot;:&amp;quot;localhost&amp;quot;,&amp;quot;port &amp;quot;:10101},&amp;quot;isCoordinator&amp;quot;:true}],&amp;quot;localID&amp;quot;:&amp;quot;91715a50-7d50-4c54-9a03-873801da1cd1&amp;quot;}  简单项目 为了更好地理解Pilosa的功能，我们将创建一个名为Star Trace的示例项目，其中包含有1000个流行的Github存储库的信息，这些存储库名称中包含go。Star Trace索引将包括数据点，例如编程语言，标签和star者(已经为项目加星标的人)。
尽管Pilosa没有以表格形式保存数据，但在描述数据模型时我们仍然使用术语列和行。我们将主对象放在列中，并将这些对象的属性放在行中。 例如，Star Trace项目将包含一个名为repository的索引，其中包含表示Github存储库的列，以及表示编程语言和标签等属性的行。我们可以通过将行分组为名为Fields的集合来更好地组织行。因此，repository(存储库)索引可能具有languages(语言)字段以及tags(标签)字段。您可以在文档的Data Model(数据模型)部分中了解有关索引和字段的更多信息。
创建架构(Create the Schema) 注意：如果您想在任何时候验证数据结构，可以按如下方式请求架构：
curl localhost:10101/schema  {&amp;quot;indexes&amp;quot;:null}  在我们在导入数据或运行查询之前，需要创建索引及其中的字段。 下面先创建存储库索引： 下面命令成功的创建一个名为repository的索引
curl localhost:10101/index/repository -X POST  {&amp;quot;success&amp;quot;:true}  接下来创建一个stargazer字段，该字段的行内容(数据)为star者的用户ID
curl localhost:10101/index/repository/field/stargazer \ -X POST \ -d &#39;{&amp;quot;options&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;time&amp;quot;, &amp;quot;timeQuantum&amp;quot;: &amp;quot;YMD&amp;quot;}}&#39;  {&amp;quot;success&amp;quot;:true}  由于我们的数据包含时间戳，这些时间戳代表用户start的时间，因此我们将字段类型设置为time。timeQuantum(时间量)是我们想要使用的时间分辨率，我们将其设置为star的YMD（年月日）。</description>
    </item>
    
    <item>
      <title>Pilosa文档翻译（一）导言、安装</title>
      <link>http://sotex.github.io/post/2018-11-27-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%80%E5%AF%BC%E8%A8%80%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-11-27-pilosa%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%80%E5%AF%BC%E8%A8%80%E5%AE%89%E8%A3%85/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/11/27/10027254.html
导言 原文地址 Pilosa是一个开源的分布式索引（搜索引擎）。它主要设计用于高速和可横向扩展的场景。如果您拥有数十亿个对象数据，这些对象数据可能具有数百万个属性，并且您想探索这些关系，Pilosa可以为您提供帮助。
 哪种属性最常见？ 哪些对象具有这些特定属性？ 哪些属性组经常出现在一起？ Pilosa旨在实时应答这些类型的查询，适用具有于高速率数据流的使用，或为用户界面提供支持。 一旦安装了Pilosa，入门指南将向您展示与Pilosa交互的基础知识，并为您提供更深入探索的一些指导。  安装 原文地址 Pilosa目前适用于MacOS和Linux。
安装在MacOS 在MacOS上安装Pilosa的四种方法。
使用HomeBrew 1、更新您的HomeBrew
brew update  2、安装Pilosa
brew install pilosa  3、查看是否安装成功
pilosa  如果有如下形式输出，表示安装成功
Pilosa is a fast index to turbocharge your database. This binary contains Pilosa itself, as well as common tools for administering pilosa, importing/exporting data, backing up, and more. Complete documentation is available at https://www.pilosa.com/docs/. Version: v1.1.0 Build Time: 2018-05-14T22:14:01+0000 Usage: pilosa [command] Available Commands: check Do a consistency check on a pilosa data file.</description>
    </item>
    
    <item>
      <title>GDAL多光谱与全色图像融合简单使用</title>
      <link>http://sotex.github.io/post/2018-11-23-gdal%E5%A4%9A%E5%85%89%E8%B0%B1%E4%B8%8E%E5%85%A8%E8%89%B2%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-11-23-gdal%E5%A4%9A%E5%85%89%E8%B0%B1%E4%B8%8E%E5%85%A8%E8%89%B2%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/11/23/10005926.html
简述 最近在GDAL的代码中看见了gdalpansharpen.cpp，于是简单的尝试了一下。
融合后的效果比较差，这应该是我对这个算法的使用还不熟悉，还有些地方没有弄清楚。这个代码比较新，是2.1版本才加上的，我在看的时候，代码还有一些小问题，已经在github上提交了issuse了。
融合使用的数据是我在网上找到的高分一号的一景数据，先做了校正，形成全色波段TIFF(单波段)和多光谱波段TIFF(4波段)。
相关知识参考： - 遥感影像的“全色”与“多光谱” - 高分一号（GF-1）卫星影像数据介绍 - 国内遥感卫星资源综述 - 高分一号影像处理流程 - 遥感影像融合方法(英文) - ENVI 遥感图像融合 - 为何全色影像分辨率高于多光谱影像分辨率 - 全色锐化的基础知识
C++代码 代码基于当前https://github.com/OSGeo/gdal仓库的master分支构建。
// g++ gdal_pansharpen.cpp -o gdal_pansharpen -I../include -L../lib -lgdal #include &amp;lt;gdalpansharpen.h&amp;gt; #include &amp;lt;cpl_auto_close.h&amp;gt; #include &amp;lt;cpl_error.h&amp;gt; int main() { GDALAllRegister(); // 打开全色波段(高分辨率)文件 GDALDatasetH hPanDset = GDALOpen(&amp;quot;/mnt/data/GF1_PMS2_E116.5_N39.6_20130501_L1A0000127213-PAN2_rpc.tiff&amp;quot;,GA_ReadOnly); CPL_AUTO_CLOSE_WARP(hPanDset,GDALClose); VALIDATE_POINTER1(hPanDset,&amp;quot;Open Pansharpen file failed&amp;quot;,1); // 打开多光谱(低分辨率)文件 GDALDatasetH hMssDset = GDALOpen(&amp;quot;/mnt/data/GF1_PMS2_E116.5_N39.6_20130501_L1A0000127213-MSS2_rpc.tiff&amp;quot;,GA_ReadOnly); CPL_AUTO_CLOSE_WARP(hMssDset,GDALClose); VALIDATE_POINTER1(hPanDset,&amp;quot;Open Spectral Band file failed&amp;quot;,1); int nSpectralBands = GDALGetRasterCount(hMssDset); GDALPansharpenOptions opts; opts.</description>
    </item>
    
    <item>
      <title>影像快速投影变换算法</title>
      <link>http://sotex.github.io/post/2018-11-08-%E5%BD%B1%E5%83%8F%E5%BF%AB%E9%80%9F%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-11-08-%E5%BD%B1%E5%83%8F%E5%BF%AB%E9%80%9F%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E7%AE%97%E6%B3%95/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/11/08/9235307.html
需求简述 对于一张栅格影像图，需要一个进行快速且正确的投影转换算法，以便能够快速的实时多源数据叠加显示。 因为只是用于显示，所以无需进行整体的重投影，只需要对显示区域范围进行重投影即可。
什么是地图投影？
逐点采样投影换算 正常的影像进行投影变换，原理是对影像的每一个像素点都进行投影转换(两个三维坐标系之间的转换)，然后输出到新的图像对应位置(实际算法应该是先计算出输出栅格的大小，然后通过坐标转换公式计算输出栅格中的像素点与之对应的源影像中的像素点，进行采样输出)。 这是比较严格的转换方式，其效果也不错，但是速度太慢。对于图像少的情况，还能够实时浏览，但是当影像图层非常多的时候，就不行了。
快速投影 这里主要说的是投影坐标系的影像转经纬度的情况。显示范围看做一个方格，则只需取出这个方格范围的像素点即可。
状况一 直接计算输出范围四个角点在图像投影坐标系上的坐标，然后计算UV进行透视(投影)变换。 快速一点的方法就是只对四个角点进行转换，以四个角点为基准，计算四点UV值，进行透视变换后得到新图像。 即以四个角点计算输出的行列范围（外包框，即临时取图范围），四个角点的行列坐标值与整个取出临时图像的角点的行列坐标值计算UV进行坐标转换。
1、计算方格四个角点(经纬度)在影像地理坐标系(投影)上对应的角点坐标pts1 2、计算pts1的外包矩形框rectbox1 3、计算pts1在rectbox1中相对位置关系，就是计算UV值 4、计算rectbox1在影像中的行列坐标范围，读取对应像素数据 5、对取出来的数据进行透视变换，得到数据就是要用来显示的数据  状况二 如果输出图像是经纬度的，且输入图像在输出图像中占的位置范围非常小，或者反过来，这时候就要使用不同的策略了。 考虑到投影变形（跨带问题），则需要计算图像的经纬度范围的四个角点在图像所在投影坐标系的坐标范围内的四点坐标（或者以图像四个角点坐标和其角点经纬度坐标形成点对），然后通过多项式公共点校正算法得到输出范围四个角点在投影坐标系的坐标，这时候的坐标不是正常的坐标转换得到的，但采用这种方式得到的四个角点坐标后，计算UV进行透视变换后得到的新图像是正确的。
1、计算影像的地理坐标(投影)角点坐标 pts2 在显示范围坐标系(经纬度)中对应的坐标 pts1 2、以pts1和pts2组成点对，获取GCP校正参数（pts1--&amp;gt;pts2） 3、使用GCP校正参数，计算显示范围角点在在影像地理范围内的坐标 pts3 (投影坐标，可能也可以超出投影坐标系有效范围) 4、计算 pts3 在影像地理范围内(是个矩形)相对位置，也就是UV值，这个UV值应该超出0~1的范围 5、对图像数据进行透视变换，使用的参数就是第四步计算出来的UV值  方法二 因为透视(投影)变换就是本身也是比较复杂的，而同一矩形区域在不同坐标系下的变形一般都是很小的，所以可以使用简单仿射变换来进行转换。 基本步骤与上面一致，只是将计算透视变换的参数改为计算仿射变换参数，然后进行像素点的转换即可。</description>
    </item>
    
    <item>
      <title>Win10一直弹出 用户账户控制 解决</title>
      <link>http://sotex.github.io/post/2018-10-18-win10%E4%B8%80%E7%9B%B4%E5%BC%B9%E5%87%BA-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E6%8E%A7%E5%88%B6-%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-18-win10%E4%B8%80%E7%9B%B4%E5%BC%B9%E5%87%BA-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E6%8E%A7%E5%88%B6-%E8%A7%A3%E5%86%B3/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/10/18/9771798.html
问题 自从更新了Windows后，就出现了一个问题，隔一段时间就弹出一次下面的对话框，而且如果时间稍长，会弹出多个。 解决方法一 对于这个CLSID:{FCC74B77-EC3E-4dd8-A80B-008A702075A9}这个真不知道是什么程序，打开注册表找到后才知道是appwiz.cpl。 修改注册表，给这个程序管理员权限运行。
定位到注册表HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers目录
添加一个字符串值，名称为%SystemRoot%\system32\appwiz.cpl，数据为RUNASADMIN。
将appwiz.cpl加入UAC白名单 先下载微软官方Windows Assessment and Deployment Kit 工具安装。 别的东西不重要，关键是安装应用程序兼容性工具 安装完成之后，打开对应版本(32/64bit)的Compatibility Administrator程序（一般都是64bit的），将appwiz.cpl程序加入UAC白名单即可。 之后一路下一步，最后点击完成。完成之后点击菜单栏上的Save按钮，保持一下文件，保持在哪里不重要。之后安装一下，就把appwiz.cpl加入UAC白名单了。 解决方法二 以管理员身份运行PowerShell，然后运行下面命令。 Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register “($_.InstallLocation)\AppXManifest.xml”} 如果像我这里这样，那么运行下面的命令。 Get-AppxPackage | % { Add-AppxPackage -DisableDevelopmentMode -Register &amp;quot;$($_.InstallLocation)\AppxManifest.xml&amp;quot; -verbose }</description>
    </item>
    
    <item>
      <title>MongoDB地理空间数据存储及检索</title>
      <link>http://sotex.github.io/post/2018-10-12-mongodb%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E6%A3%80%E7%B4%A2/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-12-mongodb%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8A%E6%A3%80%E7%B4%A2/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/10/12/9777141.html
之前写过MySQL空间索引简单使用，测试也是可用的，当时没有测试效率问题，因为存储的矢量数据都只是一个四点的多边形而已。这次使用mongoDB来做一个行政区划检索的功能，记录一下使用的过程。
参考资料： - MongDB二维球面索引(2dsphere Indexes) - MongoDB地理相关问题(Geospatial Queries) - MongoDB存储geojson数据 - GeoJSON规范文档
1、存入地理数据 MongoDB存储的数据是bson结构，所以只要你的数据符合这个结构都是可以存储的，但是要支持空间索引，就必须按照它的规定来。 早期版本的(2.6之前)仅仅支持简单的点数据的索引，也就是filed:[x,y]这样的结构，这个适用范围太有限了。现在的版本支持GeoJSON形式的数据类型，且支持OCG的空间数据查询模型，使用上非常方便。
GeoJSON数据存入 MongoDB要求把GeoJSON格式的数据以子文档的形式存入，但实际上并不是存入一个完整GeoJSON对象，只需要其中的type和coordinates两个字段就可以了。
下面以存入一个含有地理空间数据的文档为例，把所有支持的GeoJSON对象类型都做个示例。 这里假设存储一个县的信息，数据都以json格式表示。
{ &amp;quot;xian&amp;quot;:&amp;quot;潜山县&amp;quot;, &amp;quot;sheng&amp;quot;:&amp;quot;安徽&amp;quot; }  1、Ponit 点数据 现在假设为这个文档添加上中心点位置，那么这个文档就变成了如下样子：
{ &amp;quot;xian&amp;quot;:&amp;quot;潜山县&amp;quot;, &amp;quot;sheng&amp;quot;:&amp;quot;安徽&amp;quot; &amp;quot;center&amp;quot;:{ &amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[116.45,30.72]} }  2、LineString 线数据(多段线) 现在加上一个到省会合肥的路径连线，那么文档就变成了如下样子：
{ &amp;quot;xian&amp;quot;:&amp;quot;潜山县&amp;quot;, &amp;quot;sheng&amp;quot;:&amp;quot;安徽&amp;quot; &amp;quot;center&amp;quot;:{ &amp;quot;type&amp;quot;:&amp;quot;Point&amp;quot;,&amp;quot;coordinates&amp;quot;:[116.45,30.72]}, &amp;quot;toShengHui&amp;quot;:{ &amp;quot;type&amp;quot;:&amp;quot;LineString&amp;quot;,&amp;quot; coordinates&amp;quot;:[[116.55944824218749,30.58827267102698], [116.87667846679689,30.791396195188927],[116.96594238281249,31.038815104128687], [117.18292236328124,31.264465555752835],[117.22412109375,31.819230730326613]]} }  3、 Polygon 多边形数据 多边形是当前地理信息领域应用的比较多的数据类型。 多边形描述的是一个面对象，其由两部分组成，一个外壳shell和0或多个內洞holes。 外壳和內洞的表示都是一个闭合的线环(LinearRing)，表示一个闭合曲面。外壳包括的区域表示在多边形内的区域，內洞表示的区域则是从外壳表示的区域中排除的区域，如下图所示的样子，蓝色的是外壳，绿色部分的是內洞。 因为行政边界的涉及到的点太多，所以这里就只添加一个外包框作为示例： 因为GeoJSON中使用bbox字段(四个double值的数组)来描述范围外包框，所以这里不能使用bbox来存储一个多边形，否则将报错error inserting documents: location object expected, location array not in correct format。但奇怪的是，这个bbox用于搜索的时候却是无效的。 这里就不使用內洞了，有內洞的情况就是coordinates数组中后面加上线环即可。</description>
    </item>
    
    <item>
      <title>mingw 构建 gdal 2.1.2</title>
      <link>http://sotex.github.io/post/2018-10-11-mingw-%E6%9E%84%E5%BB%BA-gdal-2.1.2/</link>
      <pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-11-mingw-%E6%9E%84%E5%BB%BA-gdal-2.1.2/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/10/11/6856910.html
前两日有人在oschian上问我mingw编译gdal的一些问题，然后我简单的编译了一次，记录下编译过程。 此文是2017年5月写的，当时存在草稿箱，今天才看到。也许已经不适用于当前最新的版本了。
1、准备 1、安装mingw，我安装的是mingw-w64的x86_64-7.1.0-win32-seh-rt_v5-rev0版本。 2、准备一个类UNIX模拟运行环境。我这里直接使用了git自带的msys，你也可以下载cygwin。 3、下载并解压GDAL源码
注意：mingw的安装路径必须没有空格，如果有，后面编译的时候会找不到编译器（必须强制指定绝对路径，路径需要用引号括起来）。GDAL的源码解压路径也不要有空格。
2、生成Makefile 在msys环境下，进入gdal-2.1.2源码目录，运行一下命令生成GNUMakefile文件
# 将mingw的路径导入环境变量PATH export PATH=$PATH:/c/mingw-w64/x86_64-7.1.0-win32-seh-rt_v5-rev0/mingw64/bin # 生成Makefile文件 ./configure --prefix=/z/gdal_2.1.2_mingw64 --without-libtool ## --prefix 指定安装路径 ## --without-libtool 不使用libtool（因为我当前环境没有） ## 默认是静态库和动态库都生成，使用libtool可能只能生成静态库，因为它不知道在当前平台如何生成动态库。  注意 上述过程没有错误的话，会正常生成GNUMakefile和GDALmake.opt文件。 因为我们安装的mingw64并不能识别/c/xxx这样的路径（这是msys下的路径），所以需要修改GDALmake.opt文件，将其中的GDAL_ROOT的值修改为C:\xxx这种形式。
3、编译 运行下面命令编译
mingw32-make  4、编译遇到错误及解决办法 编译过程中出现了下面错误
1、生成静态库时候ar提示参数列表太长 ar r Z:/gdal-2.1.2/libgdal.a Z:/gdal-2.1.2/frmts/o/*.o Z:/gdal-2.1.2/gcore/*.o Z:/gdal-2.1.2/port/*.o Z:/gdal-2.1.2/alg/*.o Z:/gdal-2.1.2/apps/commonutils.o Z:/gdal-2.1.2/apps/gdalinfo_lib.o Z:/gdal-2.1.2/apps/gdal_translate_lib.o Z:/gdal-2.1.2/apps/gdalwarp_lib.o Z:/gdal-2.1.2/apps/ogr2ogr_lib.o Z:/gdal-2.1.2/apps/gdaldem_lib.o Z:/gdal-2.1.2/apps/nearblack_lib.o Z:/gdal-2.1.2/apps/gdal_grid_lib.o Z:/gdal-2.1.2/apps/gdal_rasterize_lib.o Z:/gdal-2.1.2/apps/gdalbuildvrt_lib.o Z:/gdal-2.1.2/ogr/ogrsf_frmts/o/*.o ./ogr/ogrgeometryfactory.o ./ogr/ogrpoint.o ./ogr/ogrcurve.o ./ogr/ogrlinestring.o ./ogr/ogrlinearring.o ./ogr/ogrpolygon.o ./ogr/ogrutils.o ./ogr/ogrgeometry.o ./ogr/ogrgeometrycollection.o ./ogr/ogrmultipolygon.o ./ogr/ogrsurface.o .</description>
    </item>
    
    <item>
      <title>CouchDB 简单HTTP接口使用说明</title>
      <link>http://sotex.github.io/post/2018-10-10-couchdb-%E7%AE%80%E5%8D%95http%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-10-couchdb-%E7%AE%80%E5%8D%95http%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/10/10/9767546.html
1、简介 Apache CouchDB 是一个面向文档的数据库管理系统。它提供以 JSON 作为数据格式的 REST 接口来对其进行操作，并可以通过视图来操纵文档的组织和呈现。 CouchDB 是 Apache 基金会的顶级开源项目。 CouchDB里面有一个小问题，就是它的一些预定义的key有时候有下划线，有时候又不能有下划线开头，例如idrev这样的。没有固定下来，不知道是为何。
参考资料： - CouchDB 视图简介及增量更新视图的方法 - 探索 CouchDB - 优化CouchDB的读性能
2、安装 直接去官网下载对应的安装包安装即可。 安装之后服务会自动启动，监听5984(HTTP)和6984(HTTPS)端口，可以直接在浏览器访问http://127.0.0.1:5984/_utils地址，打开Web交互操作页面。 在Your Account页面创建服务管理员用户或修改用户密码。 2、HTTP接口简单使用 CounchDB相关文档可以查阅http://docs.couchdb.org 这里只简单记录一下我用到的几个HTTP接口。
CouchDB HTTP接口返回状态码简述 这里只列出常用的状态码及其说明，特定的请求类型不同的状态码信息在相应的API参考文档中有详细说明。
   状态码 状态 说明     200 OK 请求已经成功完成   201 Created 文档创建成功   202 Accepted 请求已被接受，但相应的操作可能尚未完成。
这用于后台操作，例如数据库压缩   304 Not Modified 请求的其他内容尚未修改。这与ETag系统一起使用以识别返回的信息的版本   400 Bad Request 不良请求。该错误可能由于请求URL、Path或Header出错。</description>
    </item>
    
    <item>
      <title>QGIS Server使用记录</title>
      <link>http://sotex.github.io/post/2018-10-09-qgis-server%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-09-qgis-server%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/10/09/QGIS.html
0. 简述 关于QGIS Server相关的文档很少，我也没有找到其源码在哪里，所以有些问题也不知道怎么解决，只能慢慢摸索。 这里只记录了在windows 10上安装使用的过程，在linux下过程也差不多，但是简单多了，很多缺失的东西可以直接命令安装。 我这里使用了最高版本的，但是最好还是使用长期版本，没有这么多问题。
参考: - https://anitagraser.com/category/gis/qgis-server/ - https://github.com/qgis/docker-qgis-server
1. 下载QGIS桌面64位版本 也可以不下载，使用OSGeo4W在线安装程序，只安装qgis-server但我测试这个安装不全。我安装是最新的3.2.3版本。 使用在线安装的时候，下载站点最好选择http://download.osgeo.org，这个网站下载最快。
下载地址： https://qgis.org/downloads/QGIS-OSGeo4W-3.2.3-1-Setup-x86_64.exe 安装的时候最好不要安装在C盘（win10下会很多地方有权限问题），安装路径中也最好不要有空格，原因后面会提到。
2. 下载安装QGIS Server程序 下载地址：http://download.osgeo.org/osgeo4w/x86_64/release/qgis/qgis-server/ 这里没有找到32位版本程序的下载，只能下载64位版本。下载的版本要与桌面版本一致。
下载之后解压到QGIS的安装目录即可，压缩包内的目录结构与QGIS安装目录结构是对应的。 然后复制一份httpd.d目录下的httpd_qgis.conf.tmpl文件,改名为httpd_qgis.conf。 然后编辑这个新文件 - 将里面的@osgeo4w@替换为QGIS的安装目录 - 将@grassversion@替换为grass的版本号 - 将@windir@替换为windows的目录。 或者直接运行一下QGIS安装目录下的etc/postinstall下的qgis-server.bat脚本即可。 修改的结果大致如下： 3. 下载安装Apache服务器 qgis server实质上是一个cgis程序，所以需要Apache服务器来调用。 Apache下载地址:https://www.apachelounge.com/download/ 下载后直接解压即可，注意不要解压到有空格的目录。
解压之后修改conf目录下在httpd.conf 首先修改最前面的SVRROOT变量值
Define SRVROOT &amp;quot;C:/Apache24&amp;quot; ServerRoot &amp;quot;${SRVROOT}&amp;quot;  然后在最后位置，把httpd_qgis.conf包含进去
include &amp;quot;C:/Program Files/QGIS 3.2/httpd.d/*.conf&amp;quot;  因为qgis server是一个fastcgi程序，所以这里需要下载apache的fastcgi模块 下载地址：https://www.apachelounge.com/download/ 注意要下载与apache对应的版本。 下载之后解压到apache目录下的modules目录下即可。
4、使用及问题处理 完成上面的步骤之后，可以启动apache安装目录下的bin/httpd.exe程序了。 如果没有报错，则可以获取一下GetCapabilities试试 这里我在httpd.conf中修改了端口，所以访问的是8080端口。
Forbidden You don&#39;t have permission to access /qgis/qgis_mapserv.</description>
    </item>
    
    <item>
      <title>使用Træfɪk(traefik)来加速Qt在线更新</title>
      <link>http://sotex.github.io/post/2018-10-02-%E4%BD%BF%E7%94%A8tr%C3%A6f%C9%AAktraefik%E6%9D%A5%E5%8A%A0%E9%80%9Fqt%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-10-02-%E4%BD%BF%E7%94%A8tr%C3%A6f%C9%AAktraefik%E6%9D%A5%E5%8A%A0%E9%80%9Fqt%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/10/02/9736845.html
简述 在使用Qt的MaintenanceTool程序进行在线更新的时候遇到一个问题，就是访问download.qt.io实在太慢了，老是失败。所以想使用国内的镜像站来进行更新。 使用Qt的镜像站方法也很简单，下载Update.xml和Update_orig.xml回来，然后修改里面的url即可，这个网上有很多教程。 但是这个方法不是很好用，还需要自己手动把一些元数据文件下载回来。
最近在研究traefik，所以就用它做了一个简单的代理转发，来达到加速的目的。
traefik 简介 Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。 它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的配置文件设置。
关于traefik的介绍，网上资料不是很多，可以看它的官网和一个国内的网站 - 官网 https://traefik.io/ - 国内站 http://traefik.cn/
代理设置具体过程 1、下载traefik程序 这个可以去github上下载源码回来自己编，也可以直接下载编译好的文件。因为traefik是使用go语言编译的，所有的依赖都在一个程序里面，没有乱七八糟的依赖问题。 发布版本下载地址https://github.com/containous/traefik/releases
2、编写配置文件，添加前后端来配置代理。 我使用的是清华大学的镜像站，速度还比较快。地址:https://mirrors.tuna.tsinghua.edu.cn/qt/
写好配置文件之后，直接运行起来即可
./traefik --c config.toml  配置文件如何写，可以看官网上的文档。需要中文的也可以看这里http://docs.traefik.cn/basics 配置文件如下：
# 入口点 [entryPoints] # HTTP 入口点，只需要HTTP的就够了 [entryPoints.http] address = &amp;quot;:80&amp;quot; # 使用80端口，这样后面有用 # 管理界面监听端口 [web] address = &amp;quot;:8012&amp;quot; [web.statistics] ReccentError = 10 # 配置文件监测(有改变的时候无需重启服务程序，会自动更新) [file] filename = &amp;quot;.</description>
    </item>
    
    <item>
      <title>git rebase修改历史提交内容</title>
      <link>http://sotex.github.io/post/2018-09-29-git-rebase%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-29-git-rebase%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/09/29/9723783.html
简述 git提交历史中有一次提交的内容是有问题，因为每隔一段时间就要发一次版本，所以必须修改这次提交的内容，以便其不影响已经发布的版本。 大概是这样子的
 A --- B ---- C ---- D ---- E ----- F ------ | \ \ 有问题 \-----发布 \---- 发布  所以这里需要修改C这次提交的内容。
解决过程 相关的操作可以参考7.6 Git 工具 - 重写历史 这里我创建了一个新的仓库，用来描述解决这个问题的过程。
1、先看一下提交记录
$ git log commit aa3f6b723abf030b1692f9b573092ec782600d91 Author: solym &amp;lt;solym@sohu.com&amp;gt; Date: Sat Sep 29 14:34:36 2018 +0800 第三次提交 commit e186c75c5431a6eb683d4640ac30c4b8900ba0c1 Author: solym &amp;lt;solym@sohu.com&amp;gt; Date: Sat Sep 29 14:34:11 2018 +0800 第二次提交 commit ebcd3120d30c52125593601f296607c5dcc520a3 Author: solym &amp;lt;solym@sohu.</description>
    </item>
    
    <item>
      <title>使用quicklz缩小程序体积</title>
      <link>http://sotex.github.io/post/2018-09-27-%E4%BD%BF%E7%94%A8quicklz%E7%BC%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%A7%AF/</link>
      <pubDate>Thu, 27 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-27-%E4%BD%BF%E7%94%A8quicklz%E7%BC%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%A7%AF/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/09/27/9712473.html
简述 有一个需求是这样的，写的一个程序内置了一个很大的文件（实际就是抓取epsg.io的内容里面的epsg.io.json），这个文件筛选缩减后还有12MB，如果直接内置到程序中，编译后的程序就很大了。 因为这个程序是一个动态库，而使用upx压缩过的动态库有时候会有一些异常问题出现，所以不考虑使用upx进行压缩。 看到了quicklz后，感觉这是个好东西，于是就用这个来进行压缩，把压缩后的数据写入程序中，使用前进行解压即可。使用这个操作之后，程序大小从12MB缩小为不到1.5MB，效果很明显。
压缩和解压代码 关于quicklz的使用，在http://www.quicklz.com/网站上有比较详细的说明，各个编程语言的接口也都有封装好。 更多的可以参考https://github.com/robottwo/quicklz
压缩代码 压缩的代码很简单，因为我这里只做字符串的，所以压缩率还比较高，可以达到12%左右。
压缩的代码如下：
// 压缩字符串src，返回qlz编码格式的内容 std::string quicklz_compress(const std::string&amp;amp; src) { qlz_state_compress state; memset(&amp;amp;state, 0, sizeof(qlz_state_compress)); std::string dst; char buffer[4096 + 1024]; for(size_t pos = 0;pos&amp;lt;src.size();pos+=4096) { size_t len = src.size() - pos; len = len &amp;gt; 4096 ? 4096 : len; len = qlz_compress(src.data() + pos, buffer, len, &amp;amp;state); dst.append(buffer,len); } return dst; }  下面是quiz.c里面进行压缩的代码，可供参考
#include &amp;quot;quicklz.h&amp;quot; #define MAX_BUF_SIZE 1024*1024 #define BUF_BUFFER 400 #define bool int #define true 1 #define false 0 int stream_compress(FILE *ifile, FILE *ofile) { char *file_data, *compressed; size_t d, c, fd_size, compressed_size; qlz_state_compress *state_compress = (qlz_state_compress *)malloc(sizeof(qlz_state_compress)); fd_size = MAX_BUF_SIZE; file_data = (char*) malloc(fd_size); // allocate MAX_BUF_SIZE + BUF_BUFFER bytes for the destination buffer compressed_size = MAX_BUF_SIZE + BUF_BUFFER; compressed = (char*) malloc(compressed_size); // allocate and initially zero out the states.</description>
    </item>
    
    <item>
      <title>抓取epsg.io的内容</title>
      <link>http://sotex.github.io/post/2018-09-19-%E6%8A%93%E5%8F%96epsg.io%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Wed, 19 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-19-%E6%8A%93%E5%8F%96epsg.io%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/09/19/9674716.html
简述 epsg.io是一个查询EPSG坐标系相关信息的好网站，内容很全。有各种格式的定义可以直接下载，也有坐标系的范围名称等相关信息，所以想抓取这些信息下来，方便对接各个系统。 epsg.io本身是开源的，代码在https://github.com/klokantech/epsg.io上，但是这个我分析出数据来源，应该是在epsg.io/gml/gml.sqlite文件中，但是我打开这个文件发现没有相关的记录。
抓取说明 抓取的时候使用的是proj4项目里的nad/epsg文件中的记录作为索引，找到对应的epsg代码去拼成对应url去下载。 下面是代码，用的是libcurl进行的相关操作。日志记录简单的用了一下glog，可以去掉，去掉之后就是纯C的代码了。 抓取的结果直接写在程序目录下的epsg.io目录下，请先创建好这个目录。 保存的html文件的解析，可以参考HTML解析库Gumbo简单使用记录
抓取好的文件可以在这里epsg.io.7z下载，解压压缩之后会有三百多兆，共5754个文件。 分析后提取的内容，生成了一个超大的JSON文件，可以再这里epsg.io.json.7z下载。 我把抓取的内容处理成json后，又将其导入了MongoDB数据库。 这里将数据备份后上传在这里https://files.cnblogs.com/files/oloroso/epsg.io.mongodb.7z，这个数据可以直接使用mongorestore工具恢复到数据库。 导入MongoDB的数据中，wgs84_bound字段名改为84box，proj_bound字段改为projbox，中心点坐标经过处理，不会有null出现。
代码 // g++ epsg.spider.cpp -o epsg.spider -lcurl -lglog -lpthread #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;curl/curl.h&amp;gt; #include &amp;lt;glog/logging.h&amp;gt; int downpage(int epsgcode) { int ret = 0; char url[1024]; sprintf(url,&amp;quot;./epsg.io/%d.html&amp;quot;,epsgcode); FILE* fp = fopen(url,&amp;quot;wb&amp;quot;); if(fp == NULL){ fprintf(stderr,&amp;quot;\n创建输出文件失败i\n&amp;quot;); ret = -1; return ret; } sprintf(url,&amp;quot;http://epsg.io/%d&amp;quot;,epsgcode); CURL *hnd = curl_easy_init(); curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, &amp;quot;GET&amp;quot;); curl_easy_setopt(hnd, CURLOPT_URL, url); curl_easy_setopt(hnd, CURLOPT_COOKIEFILE, &amp;quot;.</description>
    </item>
    
    <item>
      <title>HTML解析库Gumbo简单使用记录</title>
      <link>http://sotex.github.io/post/2018-09-18-html%E8%A7%A3%E6%9E%90%E5%BA%93gumbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-18-html%E8%A7%A3%E6%9E%90%E5%BA%93gumbo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/09/18/9667642.html
Gumbo简介 Gumbo是谷歌开源的一个纯C编写的HTML解析库，性能很好，就是用起来比较麻烦。 github地址https://github.com/google/gumbo-parser 还有一个C++封装的版本https://github.com/lazytiger/gumbo-query.git
关于HTML的参考，可见https://developer.mozilla.org/zh-CN/docs/Web/HTML
最近准备写一个爬虫，用于爬取epsg.io上的数据，所以找了这个库用于HTML的解析。其实我这个简单的爬取固定位置的内容，用这个实在是有点杀鸡用牛刀了，直接做字符串搜索会更方便。
使用记录 关于这个的使用，网上找不到太多的资料。 这里有一个https://blog.csdn.net/fjb2080/article/details/78992851
这个图片上实际已经把相关的关系描述清楚了，我这里只做简单的补充。
1、GumboNode的类型 对于一个GumboNode结构体对象，需要通过它的GumboNodeType type字段判断其类型后，可根据类型对成员v进行操作。 v是一个union对象，它可以是GumboDocument、GumboElement、GumboText三种类型之一。
1、GUMBO_NODE_DOCUMENT 文档节点 文档节点表示的是一个完整的html文档，就是从&amp;lt;html&amp;gt;到&amp;lt;/html&amp;gt;之间的全部信息。对于v可取GumboDocument类型的成员document。 对于文档节点，其内部包含的元素节点都在GumboVector children中。
2、GUMBO_NODE_ELEMENT 元素节点 只要是含有标签tag的部分，都是元素节点。这个可以简单的理解为，只要是&amp;lt;标签名&amp;gt;到&amp;lt;/标签名&amp;gt;之间的就是一个元素节点的内容(有的元素是单标签的)，元素节点可以有包含嵌套关系，子节点都在GumboVector children中。
/** * 用于表示所有HTML元素的结构。 它包含有关标记，属性和子节点的信息。 */ typedef struct { /** * GumboNodes数组，包含此元素的子元素。 保存的是GumboNode的指针。 */ GumboVector /* GumboNode* */ children; /** 这个元素的GumboTag(标签，HTML的标签是定义好的)枚举值 */ GumboTag tag; /** 此元素的GumboNamespaceEnum值(表示这个是HTML、SVG还是MATHML)*/ GumboNamespaceEnum tag_namespace; /** * 指向此元素的原始标记文本的GumboStringPiece，直接指向源缓冲区。 * 如果标记是通过算法插入的（例如，&amp;lt;head&amp;gt;或&amp;lt;tbody&amp;gt;插入），则这将是一个零长度字符串。 */ GumboStringPiece original_tag; /** * 指向此元素的原始结束标记文本的GumboStringPiece。 * 如果以算法方式插入结束标记（例如，关闭自闭标记），则这将是一个零长度字符串。 */ GumboStringPiece original_end_tag; /** 记录元素开始标签在来源字符串中的起始位置。 */ GumboSourcePosition start_pos; /** 记录元素结束标签在来源字符串中的起始位置。 */ GumboSourcePosition end_pos; /** * GumboAttributes数组，按照解析顺序包含此元素标签的属性 * 数组保存的是GumboAttribute的指针 */ GumboVector /* GumboAttribute* */ attributes; } GumboElement;  3、GUMBO_NODE_TEXT 文本节点 文本节点，对于v可取GumboText类型的成员text。 Gumbo在解析的时候，对于\r\n这种都会解析为一个独立的文件节点。</description>
    </item>
    
    <item>
      <title>GDALSetProjection使用的一个注意事项</title>
      <link>http://sotex.github.io/post/2018-09-06-gdalsetprojection%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-06-gdalsetprojection%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/09/06/9597067.html
GDALSetProjection 简述 GDALSetProjection是用来给GDALDataset设定投影信息(坐标系统)的接口，实际上是GDALDataset::SetProjection这个虚函数的转调而已。官网文档描述如下： &amp;gt; **CPLErr GDALDataset::SetProjection (const char * pszProjection ) ** &amp;gt; Set the projection reference string for this dataset. &amp;gt; The string should be in OGC WKT or PROJ.4 format. An error may occur because of incorrectly specified projection strings, because the dataset is not writable, or because the dataset does not support the indicated projection. Many formats do not support writing projections. &amp;gt; This method is the same as the C GDALSetProjection() function.</description>
    </item>
    
    <item>
      <title>外网IP监测上报程序(使用Poco库的SMTPClientSession发送邮件)</title>
      <link>http://sotex.github.io/post/2018-09-04-%E5%A4%96%E7%BD%91ip%E7%9B%91%E6%B5%8B%E4%B8%8A%E6%8A%A5%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8poco%E5%BA%93%E7%9A%84smtpclientsession%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-04-%E5%A4%96%E7%BD%91ip%E7%9B%91%E6%B5%8B%E4%B8%8A%E6%8A%A5%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8poco%E5%BA%93%E7%9A%84smtpclientsession%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</guid>
      <description> [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/09/04/9583854.html
IPReport 代码地址https://gitee.com/solym/IPReport
项目介绍 外网IP变动自动上报工具。 写这个工具的目的是为了监测一台服务器的外网IP的变动情况。之前办理的电信宽带是有外网IP的，因此把一台小服务器上的ut管理端口开放出来，以便随时都能添加下载任务。 但是这个外网IP不是固定的，大概每周都会变动一次，变动的时间不固定，所以写了个程序来检测它，改变的时候主动发送信息给我。
编译说明 程序依赖于Poco库，需要自己准备。 因为我的服务器装的是ArchLinux，所以直接使用pacman -Syu poco安装就好了。 如果是Windows可以直接使用vcpkg来编译安装poco库。
linux下直接使用make编译即可。
安装使用说明 无需安装，编译之后可以直接运行。 linux下可以使用nohup ./IPReport 2&amp;gt;&amp;amp;1 1&amp;gt;/dev/null &amp;amp;来放在后台运行。 Windows下你可以在VS工程属性页-&amp;gt;链接器-&amp;gt;系统里面选择子系统为窗口(SUBSYSTEM:WINDOWS)来生成一个无窗口的窗口应用，就可以无控制台运行了。
获取外网IP方式 外网IP可以通过访问淘宝的https://www.taobao.com/help/getip.php获取。
邮件发送关键代码 // 发送邮件通知 // 发送的消息内容 Poco::Net::MailMessage message; message.setSubject(&amp;quot;外网IP地址改变通知&amp;quot;); message.setDate(Poco::DateTime().timestamp()); message.addContent(new StringPartSource(lastResult,&amp;quot;text/plain&amp;quot;)); message.setSender(mailuser); message.addRecipient(MailRecipient(MailRecipient::PRIMARY_RECIPIENT,mailrecipient)); // 开始发送邮件 // 第一个是非SSL连接的，第二个是SSL连接的 //Poco::Net::SMTPClientSession smtpSession(mailhost); Poco::Net::SecureSMTPClientSession smtpSession(mailhost); smtpSession.open(); // 下面两行是SSL连接必须的 smtpSession.login(); smtpSession.startTLS(); // 登录邮件服务 smtpSession.login(Poco::Net::SMTPClientSession::LoginMethod::AUTH_LOGIN, mailuser, mailpasswd); // 发送出邮件内容 smtpSession.sendMessage(message); // 发送后关闭会话 smtpSession.close();  </description>
    </item>
    
    <item>
      <title>MySQL空间索引简单使用</title>
      <link>http://sotex.github.io/post/2018-09-03-mysql%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-03-mysql%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/09/03/9579720.html
简述 MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。国内的MySQL相关的书籍都比较老了，在这方面有详细描述的还没有见过。有一本比较新的PostgreSQL的数据介绍过空间搜索相关的内容，但是也不够详细。所以对于这方面的内容，不管是MySQL还是PostgreSQL，都建议直接去看官方文档，都有很详细的示例。
参考资料： - MySQL官方文档主页 - MySQL5.7版本空间数据参考文档 - MySQL支持的空间数据格式 - 空间索引和 ST_Geometry - ST_Geometry 的关系函数
MySQL在空间索引这方面遵循OpenGIS几何数据模型规则，详情可见 - MySQL中 OpenGIS Geometry Model - OpenGIS Implementation Specification for Geographic information - Simple feature access - Part 2: SQL option
下面记录一下简单的使用。
1、创建一个带有空间索引的表 我这里主要是用于检索遥感影像数据的，这里就只创建了两个字段，一个是影像路径path，一个是有效外包框box。
CREATE TABLE `gim` ( `path` varchar(512) NOT NULL, `box` geometry NOT NULL, PRIMARY KEY (`path`), SPATIAL KEY `box` (`box`) ) ;  这里创建好之后，就可以往里面插入数据了。
2、插入数据 数据的插入和普通的数据插入一样，只是geometry数据需要使用st_geomfromtext等函数来构造，相关的文档参考在这里gis-data-formats还有这个populating-spatial-columns。
这里只展示一个简单数据插入，这里我使用的是单多边形，只有四个点（逆时针顺序），使用WKT描述几何数据。</description>
    </item>
    
    <item>
      <title>libmongoc关于$pullAll和$addToSet的一个使用问题记录</title>
      <link>http://sotex.github.io/post/2018-09-03-libmongoc%E5%85%B3%E4%BA%8Epullall%E5%92%8Caddtoset%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 03 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-03-libmongoc%E5%85%B3%E4%BA%8Epullall%E5%92%8Caddtoset%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/09/03/9578888.html
问题描述及测试结果 在使用mongodb时，对一个document中的数组成员进行更新的时候，可以使用$pull $push $pop $addToSet $pullAll和$each $position $slice $sort等操作符。
以下问题出现在$addToSet和pullAll操作中，$set操作没有这个问题，其他的操作符没有测试，不知道有没有问题。
之前在libmongoc中更新一个对象，用到了这些操作的时候，对于添加进update这个bson对象中的数组成员，其key是没有要求的，大概如下：
// 更新对象的选择 bson_t* selector = BCON_NEW(&amp;quot;_id&amp;quot;,BCON_OID(_id)); // 更新的内容 bson_t* update = bson_new(); bson_t* each = bson_new(); bson_t array; bson_append_array_begin(each, &amp;quot;$each&amp;quot;, 5, &amp;amp;array); // 向数组中逐个添加元素,itemArray是要添加的数据保存的数组 for(auto&amp;amp; item:itemArray){ // 以前这里添加的时候，key都使用&#39;0&#39;是没有问题的 bson_append_utf8(&amp;amp;array,&amp;quot;0&amp;quot;,1,item.data(),item.size()); } bson_append_array_end(each, &amp;amp;array); bson_append_document(update,&amp;quot;$addToSet&amp;quot;,9,each); // 执行更新操作 mongoc_collection_update( coll, MONGOC_UPDATE_NONE, selector, update, NULL, &amp;amp;error);  这是去年我写代码的时候的做法，这样的操作是一点问题都没有的。当时使用的MongoDB是3.4.0版本，使用的libmongoc是1.3.1版本。最近一个新项目中再次使用到了MongoDB，这次使用的是4.0.2版本，libmongoc使用的是1.9.3版本。 经过测试(lobmongoc1.9.3)，这样的代码在MongoDB 4.0.2版本中，$addToSet和pullAll两个有问题，无法实现多个成员的操作。在MongoDB3.4.0中，$addToSet是没有问题的，但是$pullAll也是只能移除一个，不能移除多个。我这里没有测试更多操作，因为只用到了这两个，也没有测1.3.1版本的lobmongoc，因为不能回退到这个版本了。
做如下修改可以完成正常想要的操作
// 更新对象的选择 bson_t* selector = BCON_NEW(&amp;quot;_id&amp;quot;,BCON_OID(_id)); // 更新的内容 bson_t* update = bson_new(); bson_t* each = bson_new(); bson_t array; bson_append_array_begin(each, &amp;quot;$each&amp;quot;, 5, &amp;amp;array); // 向数组中逐个添加元素,itemArray是要添加的数据保存的数组 uint32_t i = 0; for(auto&amp;amp; item:itemArray){ // 以前这里添加的时候，key都使用&#39;0&#39;是没有问题的 // bson_append_utf8(&amp;amp;array,&amp;quot;0&amp;quot;,1,item.</description>
    </item>
    
    <item>
      <title>SkinTK编译使用</title>
      <link>http://sotex.github.io/post/2018-09-02-skintk%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-09-02-skintk%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/09/02/9574491.html
简介 MFC这个东西已经落伍了，不建议使用。我就是吃饱了撑着，还在折腾这个。 平时写点带界面的小程序一般都用Qt来做，简单好用，也很容易做的比较漂亮。我觉得唯一一个算不得多大缺点的缺点就是Qt体积太大了。 之前用MFC写过几个小程序，那天看见一个介绍MFC美化的文章，就想着也给来加个皮肤。只是MFC没有像Qt的qss这么方便的东西。 网上看到一个开源的库SkinTK，就下载回来试试。 这个库不知道与CJ60Lib有什么关系，在这里下载的源码里面有一部分是来自cj60的。附上CJ60LIB的一篇编译说明http://www.cnblogs.com/icmzn/p/6724969.html
修改后的代码上传到了gitee，下载地址https://gitee.com/solym/SkinTK_VS2017
编译 编译过程倒是不难，就是有些地方需要改动一下，比较烦。 这个库依赖于Detours，来Hook与Windows窗口操作相关的一些系统函数。 Detours这个库已经微软已经开源了，下载地址https://github.com/Microsoft/Detours.git 因为它原本使用的是老版本的，不支持64位系统，所以我给替换成了最新的。
编译的时候要修改一些地方。
 1、针对64位的修改 很多用到了SetWindowLong和GetWindowLong以及GetClassLong的地方需要修改为SetWindowLongPtr和GetWindowLongPtr和GetClassLongPtr。
 2、CMemDC的修改 因为VC2010版本已经包含了CMemDC的实现，而这个库自己实现了一个，在使用的时候会有冲突，所以进行以下修改
// 文件 include\MenDC.h // 类 CMemDC声明前加上 #if _MSC_VER &amp;gt;= 1600 #define CMemDC SkinCMemDC #endif  否则可能出现 uafxcwd.lib(afxglobals.obj) error LNK2005: &amp;ldquo;public: virtual __thiscall CMemDC::~CMemDC(void)&amp;rdquo; (??1CMemDC@@UAE@XZ) already defined in
 3、修改SKINTKDLL宏定义 因为我要编译静态库版本，所以这里SKINTKDLL宏的定义修改为空
 4、问题 这里还有很多问题，我没有去解决。64位编译的结果回出现崩溃的状况，具体来说是在SetWindowLongPtr函数调用的时候出现0x5c00000000异常的问题。 32位也有问题，不加载皮肤没有问题，加载皮肤运行一会就崩溃。
  使用 具体的使用方法见使用SkinTK进行换肤 下面是使用前后的一个对比图
  </description>
    </item>
    
    <item>
      <title>修改QGIS来支持DPI为96的WMTS/WMS服务</title>
      <link>http://sotex.github.io/post/2018-08-29-%E4%BF%AE%E6%94%B9qgis%E6%9D%A5%E6%94%AF%E6%8C%81dpi%E4%B8%BA96%E7%9A%84wmts.wms%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-08-29-%E4%BF%AE%E6%94%B9qgis%E6%9D%A5%E6%94%AF%E6%8C%81dpi%E4%B8%BA96%E7%9A%84wmts.wms%E6%9C%8D%E5%8A%A1/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/08/29/9553207.html
缘由 因为各种各种wmts地图客户端产品的标准的支持不一定是一致的，就像ArcGIS不同版本加载WMTS图层的时候计算的规则就有差别（米和经纬度之间转换系数的区别），导致会出现适应各个客户端而出的WMTS服务，里面的ScaleDenominator值有细微的差别。 例如都是Google经纬度(天地图经纬度直投)，其切分规则是一样的，但其DPI不一致导致计算的ScaleDenominator是不一致的。 虽然OGC标准里面对DPI大小的定义就是90.714，但是国内天地图使用的DPI标准为96，这里也有一个计算的差值。DPI不同对应的也就是每个像素的大小不一致，也就是分辨率不一致，造成瓦片的行列号计算有差异。
QGIS是支持OGC WMTS标准的，其DPI的大小就是90.714(像素大小0.00028)。为了让QGIS能够支持DPI为96的WMTS服务，需要对QGIS进行一点修改。
解决过程 为了解决这个问题，看了一下QGIS的源码，相关的定义如下： 文件qgis\src\providers\wms\qgswmscapabilities.cpp 1382行前后
m.tileWidth = e1.firstChildElement( QStringLiteral( &amp;quot;TileWidth&amp;quot; ) ).text().toInt(); m.tileHeight = e1.firstChildElement( QStringLiteral( &amp;quot;TileHeight&amp;quot; ) ).text().toInt(); m.matrixWidth = e1.firstChildElement( QStringLiteral( &amp;quot;MatrixWidth&amp;quot; ) ).text().toInt(); m.matrixHeight = e1.firstChildElement( QStringLiteral( &amp;quot;MatrixHeight&amp;quot; ) ).text().toInt(); // the magic number below is &amp;quot;standardized rendering pixel size&amp;quot; defined // in WMTS (and WMS 1.3) standard, being 0.28 pixel m.tres = m.scaleDenom * 0.00028 / metersPerUnit; QgsDebugMsg( QString( &amp;quot; %1: scale=%2 res=%3 tile=%4x%5 matrix=%6x%7 topLeft=%8&amp;quot; ) .</description>
    </item>
    
    <item>
      <title>linux下使用mingw编译NSIS-3.03</title>
      <link>http://sotex.github.io/post/2018-08-23-linux%E4%B8%8B%E4%BD%BF%E7%94%A8mingw%E7%BC%96%E8%AF%91nsis-3.03/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-08-23-linux%E4%B8%8B%E4%BD%BF%E7%94%A8mingw%E7%BC%96%E8%AF%91nsis-3.03/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/08/23/9523351.html
简述 最近在研究使用NSIS做安装包，语法不算复杂，插件也很多，中文资料也不少，还挺好用的。先后用NSIS做出了安装和卸载需要输入密码，通过自定义页面实现安装时候选择多个目录、安装的时候输入配置文件信息，禁止在某些平台或环境下安装，检测是否已经安装或正在运行等，稍后将把这些都放出来，做个记录。
有一个问题就是NSIS打包的文件可以直接使用7zip解压，安装过程做的事情就被跳过了。为了解决这个问题，我想修改一下NSIS的源码，来使得打包的程序无法使用7zip等软件解压。这里记录一下编译过程。
修改过的文件及编译好的文件下载nsis-3.03-src_修改.7z
准备工作 我是在linux下使用mingw32进行编译的，所以先要安装mingw32。
然后是下载zlib库，我是在这里下载的https://jaist.dl.sourceforge.net/project/mingw/MinGW/Extension/zlib/zlib-1.2.3-1-mingw32/libz-1.2.3-1-mingw32-dev.tar.gz，这个说不定哪天就过期了，这是项目的页面https://sourceforge.net/projects/mingw/files/MinGW/Extension/zlib/。
下载之后解压，将其中lib目录下的文件拷贝到/usr/lib/gcc/i686-w64-mingw32/6.3-win32/lib目录下，将include目录下的文件拷贝到/usr/lib/gcc/i686-w64-mingw32/6.3-win32/include目录下。
然后是下载NSIS-3.03的源码，地址在这里https://jaist.dl.sourceforge.net/project/nsis/NSIS 3&amp;frasl;3.03/nsis-3.03-src.tar.bz2，下载之后解压即可。
因为NSIS使用scons进行构建，所以还需要安装python2.7和scons工具。
编译过程 关于NSIS的编译，在这里Appendix G: Building NSIS有部分介绍。
准备工作做好后，使用下面命令进行构建。
scons SKIPSTUBS=all XGCC_W32_PREFIX=i686-w64-mingw32- SKIPPLUGINS=all SKIPUTILS=all SKIPMISC=all NSIS_CONFIG_CONST_DATA_PATH=no PREFIX=./build  如果没有问题的话，正常会构建成功。但是会发现一个问题，build/urelease/makensis下面没有生成makensis.exe文件，只有一个makensis文件，而且使用readelf查看，这是一个ELF文件，而不是PE格式文件。 使用PETool查看结果如下： 这个错误的原因在这里： 根据这个报错，查看了Sconstruct文件后，找到错误的原因，是因为其中一个环境变量没有设置对。 打开nsis-3.03-src/SCons/Config/gnu文件，找到364行，在下面添加一行内容makensis_env.Replace(CXX = stub_env[&#39;CXX&#39;])。
然后重新执行构建命令。
解决完g++的问题后，继续编译遇到下面的问题。
下面有些修改其实是因为PLATFROM没有识别或者设置为win32的原因。
错误 Source/scriptpp.cpp:1054:93: error: call to non-constexpr function &amp;lsquo;size_t wcslen(const wchar_t*)&amp;rsquo; i686-w64-mingw32-g++ -o build/urelease/makensis/scriptpp.o -c -Wno-non-virtual-dtor -Wall -O2 -DNSISCALL= -D_UNICODE -DUNICODE -DMAKENSIS -D_WIN32_IE=0x0500 -Ibuild/urelease/config Source/scriptpp.cpp In file included from /usr/share/mingw-w64/include/minwindef.h:163:0, from /usr/share/mingw-w64/include/windef.</description>
    </item>
    
    <item>
      <title>Windows视频桌面壁纸实现(libvlc)(类似于wall paper engine效果)</title>
      <link>http://sotex.github.io/post/2018-08-08-windows%E8%A7%86%E9%A2%91%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%AE%9E%E7%8E%B0libvlc%E7%B1%BB%E4%BC%BC%E4%BA%8Ewall-paper-engine%E6%95%88%E6%9E%9C/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-08-08-windows%E8%A7%86%E9%A2%91%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%AE%9E%E7%8E%B0libvlc%E7%B1%BB%E4%BC%BC%E4%BA%8Ewall-paper-engine%E6%95%88%E6%9E%9C/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/08/08/9446299.html
简介 这个项目是很久之前的事情了，当时一个朋友正在研究一个国外的软件（wall paper engine ），可以在桌面壁纸层播放视频，也就差不多是动态壁纸的意思。 后来我也动手来实现这个功能，因为手头一直有别的事，也就没有一直弄。 最近看到这个项目的工程文件，就继续拿起来改了改了，稍微完善了一下，基本能用了。
编译后的程序下载链接: Win64 密码: 6bxk
2018年8月22日更新 代码已经上传到Gitee https://gitee.com/solym/video_wallpaper.git，GitHub地址https://github.com/sotex/VideoWallpaper。
原理 原理比较简单，就是找到桌面壁纸层的句柄，然后将VLC的播放窗口设置为桌面壁纸层窗口。 在windows 10上使用的时候，会发现找不到桌面壁纸层，或者说找不到与图标层分离的壁纸层。这个解决的办法在这里https://www.codeproject.com/articles/856020/draw-behind-desktop-icons-in-windows可以找到。
效果如下 </description>
    </item>
    
    <item>
      <title>C&#43;&#43; 获取程序编译时间</title>
      <link>http://sotex.github.io/post/2018-07-25-c&#43;&#43;-%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-07-25-c&#43;&#43;-%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/07/25/9365749.html 一个简单的需求，就是需要程序判断当前系统的时间是不是在程序编译之后的，如果系统当前时间在编译之前，那说明这台机器的时间是不正确的，需要终止程序运行。 因为要在程序编译时候获取时间，如果每次编译前手动修改的话，稍微显得麻烦了一点。
Windows下VS2015 VC中可以使用Visual c + + 编译器预定义的宏来获取编译时间，有__DATE__ __TIME__(这两个是ISO C99 和 ISO C + + 14 标准预定义的宏)__TIMESTAMP__(这个是VS预定义的)三个宏可以获取，但是获取到的是字符串形式的时间，所以不太利于进行比较。 这里写一个函数，用来获取编译时候的时间。
// 获取编译时间 VOID GetCompileTime(LPSYSTEMTIME lpCompileTime) { char Mmm[4] = &amp;quot;Jan&amp;quot;; sscanf_s(__DATE__, &amp;quot;%3s %hu %hu&amp;quot;, Mmm,sizeof(Mmm), &amp;amp;lpCompileTime-&amp;gt;wDay, &amp;amp;lpCompileTime-&amp;gt;wYear); Mmm[3] = Mmm[2]; Mmm[2] = Mmm[0]; Mmm[0] = Mmm[3]; Mmm[3] = 0; switch (*(DWORD*)Mmm) { case (DWORD)(&#39;Jan&#39;): lpCompileTime-&amp;gt;wMonth = 1; break; case (DWORD)(&#39;Feb&#39;): lpCompileTime-&amp;gt;wMonth = 2; break; case (DWORD)(&#39;Mar&#39;): lpCompileTime-&amp;gt;wMonth = 3; break; case (DWORD)(&#39;Apr&#39;): lpCompileTime-&amp;gt;wMonth = 4; break; case (DWORD)(&#39;May&#39;): lpCompileTime-&amp;gt;wMonth = 5; break; case (DWORD)(&#39;Jun&#39;): lpCompileTime-&amp;gt;wMonth = 6; break; case (DWORD)(&#39;Jul&#39;): lpCompileTime-&amp;gt;wMonth = 7; break; case (DWORD)(&#39;Aug&#39;): lpCompileTime-&amp;gt;wMonth = 8; break; case (DWORD)(&#39;Sep&#39;): lpCompileTime-&amp;gt;wMonth = 9; break; case (DWORD)(&#39;Oct&#39;): lpCompileTime-&amp;gt;wMonth = 10; break; case (DWORD)(&#39;Nov&#39;): lpCompileTime-&amp;gt;wMonth = 11; break; case (DWORD)(&#39;Dec&#39;): lpCompileTime-&amp;gt;wMonth = 12; break; default:lpCompileTime-&amp;gt;wMonth = 0; } sscanf_s(__TIME__, &amp;quot;%hu:%hu:%hu&amp;quot;, &amp;amp;lpCompileTime-&amp;gt;wHour, &amp;amp;lpCompileTime-&amp;gt;wMinute, &amp;amp;lpCompileTime-&amp;gt;wSecond); lpCompileTime-&amp;gt;wDayOfWeek = lpCompileTime-&amp;gt;wMilliseconds = 0; }  因为编译器给出的时间实际上是本地时间，所以这里如果进行判断的话，可以与GetLocalTime的结果进行比较。</description>
    </item>
    
    <item>
      <title>GDAL对TIF创建内建金字塔一个问题</title>
      <link>http://sotex.github.io/post/2018-07-15-gdal%E5%AF%B9tif%E5%88%9B%E5%BB%BA%E5%86%85%E5%BB%BA%E9%87%91%E5%AD%97%E5%A1%94%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-07-15-gdal%E5%AF%B9tif%E5%88%9B%E5%BB%BA%E5%86%85%E5%BB%BA%E9%87%91%E5%AD%97%E5%A1%94%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/07/15/9313339.html gdalwarp输出tif图像的时候，默认如果没有使用BIGTIFF=YES选项，则会根据输出影像的大小进行判断，低于4G则不适用bigtiff格式。 对于非bigtiff图像，如果这时候使用gdaladdo创建金字塔（内建模式），如果出现了文件总大小超过4G的情况，则会导致图像文件出错。 gdaladdo会输出相关信息，但不会终止金字塔的创建，于是导致金字塔是黑色的。
C:\Program Files\GDAL&amp;gt;gdaladdo D:\data\fs\ID_Guangdong.shp.tif 2 4 8 16 32 64 128 0...10...20...30..ERROR 1: TIFFAppendToStrip:Maximum TIFF file size exceeded. Use BIGTIFF=YES creation option. ERROR 1: An error occurred while writing a dirty block from GDALRasterBand::RasterIO ERROR 1: TIFFAppendToStrip:Maximum TIFF file size exceeded. Use BIGTIFF=YES creation option. ERROR 1: TIFFAppendToStrip:Maximum TIFF file size exceeded. Use BIGTIFF=YES creation option. ERROR 1: WriteEncodedTile/Strip() failed. .40...50...60...70...80...90...100 - done.  </description>
    </item>
    
    <item>
      <title>使用zlib库进行目录打包</title>
      <link>http://sotex.github.io/post/2018-06-06-%E4%BD%BF%E7%94%A8zlib%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%9B%AE%E5%BD%95%E6%89%93%E5%8C%85/</link>
      <pubDate>Wed, 06 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-06-06-%E4%BD%BF%E7%94%A8zlib%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%9B%AE%E5%BD%95%E6%89%93%E5%8C%85/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/06/06/9144776.html 代码很简单，具体过程就不写了。 关于加密压缩，可以看http://www.zlib.net/zlib_faq.html#faq38 中的描述，说是不支持的，但是创建的时候可以传入密码进去，不过我还没有搞清楚这个密码要如何设置。
压缩算法模式参数: 0 - 存储文件 (无压缩) 8 - 文件使用Deflated算法压缩 9 - 使用Deflate64&amp;trade;压缩 10 - PKWARE数据压缩库 12 - 文件使用BZIP2算法压缩
#include &amp;quot;zlib.h&amp;quot; #include &amp;quot;zip.h&amp;quot; #ifdef _WIN32 #define USEWIN32IOAPI #include &amp;quot;iowin32.h&amp;quot; #endif #include &amp;lt;QFile&amp;gt; #include &amp;lt;QDir&amp;gt; #include &amp;lt;QDateTime&amp;gt; /*转换Qstring到utf8字符串*/ inline std::string ToUtf8(const QString&amp;amp; str) { QByteArray u8 = str.toUtf8(); return std::string(u8.data(),u8.size()); } QStringList FileListR(const QDir&amp;amp; dir) { QFileInfoList fileinfolist = dir.entryInfoList( QDir::NoDotAndDotDot|QDir::Files|QDir::Dirs); QStringList files; for(int i=0;i&amp;lt;fileinfolist.size();++i){ QFileInfo&amp;amp; info = fileinfolist[i]; if(info.</description>
    </item>
    
    <item>
      <title>Windows下libjpeg-trubo-1.5.3编译（VS2015）</title>
      <link>http://sotex.github.io/post/2018-06-04-windows%E4%B8%8Blibjpeg-trubo-1.5.3%E7%BC%96%E8%AF%91vs2015/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-06-04-windows%E4%B8%8Blibjpeg-trubo-1.5.3%E7%BC%96%E8%AF%91vs2015/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/06/04/9132665.html
简述 https://libjpeg-turbo.org/的网站上是有已经编译好的版本下载的，但是VC下是使用的VC10.0编译的。虽然在VC14.0下也能用，但是我还是需要编译一个VC14.0版本的。
准备工作 先去下载源码包https://jaist.dl.sourceforge.net/project/libjpeg-turbo/1.5.3/libjpeg-turbo-1.5.3.tar.gz 然后需要安装一下NASM汇编工具，这个可以在https://www.nasm.us/网站找到。 nasm-2.13.03-installer-x86.exe nasm-2.13.03-installer-x64.exe
使用cmake生成VS工程 我使用的CMake命令如下： 32位
cmake -DCMAKE_CONFIGURATION_TYPES:STRING=&amp;quot;Release&amp;quot; -DCMAKE_LINKER:FILEPATH=&amp;quot;C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/link.exe&amp;quot; -DNASM:FILEPATH=&amp;quot;C:/Program Files (x86)/NASM/nasm.exe&amp;quot; -DCMAKE_C_FLAGS:STRING=&amp;quot;/DWIN32 /D_WINDOWS /W3&amp;quot; -DCMAKE_INSTALL_PREFIX:PATH=&amp;quot;Z:/compiler/out/libjpeg-turbo&amp;quot; .  64位
cmake -DCMAKE_CONFIGURATION_TYPES:STRING=&amp;quot;Release&amp;quot; -DCMAKE_LINKER:FILEPATH=&amp;quot;C:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/bin/x86_amd64/link.exe&amp;quot; -DNASM:FILEPATH=&amp;quot;C:/Program Files/NASM/nasm.exe&amp;quot; -DCMAKE_C_FLAGS:STRING=&amp;quot;/DWIN32 /D_WINDOWS /W3&amp;quot; -DCMAKE_INSTALL_PREFIX:PATH=&amp;quot;Z:/compiler/out/libjpeg-turbo64&amp;quot; -DCMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=&amp;quot;/debug /INCREMENTAL&amp;quot; .  生成后直接VS打开编译或者进入工程目录使用下面命令进行编译
msbuild libjpeg-trurbo.sln  编译好的文件 64位版本 libjpeg-turbo_v140x86.7z 32位版本 libjpeg-turbo_v140x64.7z</description>
    </item>
    
    <item>
      <title>使用Amalgamate将C/C&#43;&#43;项目合并成一个.h/.c[pp]文件</title>
      <link>http://sotex.github.io/post/2018-06-01-%E4%BD%BF%E7%94%A8amalgamate%E5%B0%86c.c&#43;&#43;%E9%A1%B9%E7%9B%AE%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA.h..cpp%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-06-01-%E4%BD%BF%E7%94%A8amalgamate%E5%B0%86c.c&#43;&#43;%E9%A1%B9%E7%9B%AE%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA.h..cpp%E6%96%87%E4%BB%B6/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/06/01/9121728.html
简述 C/C++开源库一般是一堆的头文件和源文件，做到声明和实现分离，减小单个模块大小，这在设计上是很好的，但是用起来稍显麻烦。在网上看到有好心人推荐了一个开源工具Amalgamate，专门用来对C/C++的头文件和源文件进行合并用的，于是尝试了一下。 编译过sqlite源码的应该知道，sqlite3源码包有一个是指包含sqlite3.h、sqlite3_ext.h、sqlite.c等为数不多几个代码文件的（也有分开的），嵌入到项目中非常方便。这就是用Amalgamate进行合并的。
下载并编译Amalgamate 下载很简单，这里就不细述了
git clone https://github.com/vinniefalco/Amalgamate.git  编译也很简单，直接使用VS打开Amalgamate\Builds\VisualStudio2010\Amalgamate.vcxproj，然后编译生成即可。 最后的示例下载中有我编译的程序。
# gcc 编译 g++ Amalgamate.cpp juce_core_amalgam.cpp -o Amalgamate -lpthread -ldl # clang编译 clang++ Amalgamate.cpp juce_core_amalgam.cpp -o Amalgamate -lpthread -ldl  具体的使用可以参考程序的帮助信息。
将libuv合并为单一头文件和源文件版本(Windows下) 用于合并的模板文件编写可以参考https://github.com/vinniefalco/Amalgams.git中的几个。
以libuv为例进行简单的说明。 先下载libuv的源码，目录结构如下： 首先先合并头文件 先编写一个头文件uv_all.h，里面把libuv-v1.9.1\include下的文件都include进来。 源码如下：
#include &amp;quot;android-ifaddrs.h&amp;quot; #include &amp;quot;pthread-barrier.h&amp;quot; #include &amp;quot;stdint-msvc2008.h&amp;quot; #include &amp;quot;tree.h&amp;quot; #include &amp;quot;uv.h&amp;quot; #include &amp;quot;uv_all.h&amp;quot; #include &amp;quot;uv-errno.h&amp;quot; #include &amp;quot;uv-threadpool.h&amp;quot; #include &amp;quot;uv-version.h&amp;quot; #include &amp;quot;uv-win.h&amp;quot;  一个简单的做法就是cygwin或msys下使用命令ls *.h |xargs -I{} echo &#39;#include &amp;quot;{}&amp;quot;&#39;直接输出。 因为我这里只做windows平台的，所以把多余的都给删除了。 实际上因为uv.</description>
    </item>
    
    <item>
      <title>利用fstream进行文件拷贝测试</title>
      <link>http://sotex.github.io/post/2018-05-02-%E5%88%A9%E7%94%A8fstream%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-05-02-%E5%88%A9%E7%94%A8fstream%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%8B%E8%AF%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/05/02/8979507.html 今天翻到一个早期写测试代码的目录，找到几个以前的测试代码，于是拿出来贴到博客中。（只是简单的测试，并不严谨。注意这里windows和linux的硬件环境不一样）
这一个是使用fstream进行文件拷贝的代码，测试机器的环境大概如下（时间久了，机器有更新）
CPU： i7 低压版 硬盘：两个60G的SSD，好像是建兴的 内存：8G DDR3  当时仅在Arch Linux上做了测试，今天顺便在windows下做一个测试。 CentOS7_gcc4.9.4.ova其实是虚拟机的镜像文件，1.8G大小。
代码如下：
#include &amp;lt;fstream&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;iterator&amp;gt; #include &amp;lt;algorithm&amp;gt; bool copy_file(const char* src_file_path,const char* dst_file_path) { // 检测目标文件是否存在 { std::ifstream exsit(dst_file_path); if(exsit){ std::cout&amp;lt;&amp;lt;&amp;quot;目标文件 &amp;quot;&amp;lt;&amp;lt; dst_file_path&amp;lt;&amp;lt; &amp;quot; 已经存在&amp;quot;&amp;lt;&amp;lt;std::endl; return false; } } std::ifstream fin(src_file_path,std::ios::binary); std::ofstream fout(dst_file_path,std::ios::binary); if(!fin || !fout){ std::cout&amp;lt;&amp;lt;&amp;quot;打开源文件或目标文件失败&amp;quot;&amp;lt;&amp;lt;std::endl; return false; } // rdbuf返回streambuf* // 速度比迭代器拷贝快太多 // Linux下测试结果 // time ./fstream_copy_file.exe CentOS7_gcc4.9.4.ova /mnt/data/CentOS7_gcc4.9.4.ova // 0.23s user 8.</description>
    </item>
    
    <item>
      <title>gcc下inline的一个问题</title>
      <link>http://sotex.github.io/post/2018-04-25-gcc%E4%B8%8Binline%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-25-gcc%E4%B8%8Binline%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/25/8944230.html 今天发现一个问题，与inline有关,也与编译时候是不是优化有关。 大概问题可以用下面的代码来描述：
先写一个libtest1，代码如下 libtest1.h
#ifndef LIBTEST_H #define LIBTEST_H class Test{ public: inline void fun1()const; void fun2()const; }; #endif //!LIBTEST_H  libtest1.cpp
#include &amp;lt;stdio.h&amp;gt; #include &amp;quot;libtest.h&amp;quot; void Test::fun1()const { puts(&amp;quot;fun1&amp;quot;); } void Test::fun2()const { fun1(); puts(&amp;quot;fun2 call fun1&amp;quot;); }  编译为动态库，使用命令为：gcc -shared -fpic libtest.cpp -o libtest1.so
然后第二个动态库libtest2，代码如下
#include &amp;quot;libtest.h&amp;quot; extern &amp;quot;C&amp;quot; void fun3() { Test t; t.fun1(); t.fun2(); }  编译命令为:gcc -shared -fpic libtest2.cpp -o libtest2.so -Wl,-rpath=. -L. -ltest1</description>
    </item>
    
    <item>
      <title>链接选项-rpath的一个问题记录</title>
      <link>http://sotex.github.io/post/2018-04-24-%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9-rpath%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-24-%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9-rpath%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/24/8931926.html
问题简述 大概是这么一个情况，有一个过去已经写好的程序，这个程序用于处理网络通信，接收一些操作指令。具体的指令操作通过运行时加载动态库的形式进行扩展。（类似于net-snmp二次开发的一种形式） 问题是这样的，用于扩展功能的动态库，其本身又链接了一系列的动态库，这些库的位置与这个扩展用的动态库存放的位置是相对的。大概如下
 程序 program | | 运行时加载(dlopen/LoadLibrary等) sodir/lib1.so | 相对路径存放 sodir/lib2/lib2.so  问题在于编译lib1.so的时候，并不知道将来lib1.so会存放于相对程序program的工作路径的什么位置，导致不知道lib2.so的位置在哪里。 如果链接的时候直接使用-rpath=./lib2的话，这就需要lib2.so在程序工作路径下的lib2目录下方可，因为运行时加载路径并不是相对于lib1.so而是相对于program的。
这里还有一个问题，那就是如果lib2.so还有依赖，且生成lib2.so的时候没有使用-rpath选项那就比较麻烦了，因为没有相对路径，必须放置在系统默认的so搜索路径或者在/etc/ld.so.conf中添加。 假定lib2.so依赖lib3.so，那么即便是将lib3.so加入到lib1.so的链接选项中，也不会链接进去（很早之前的时候ld程序应该是把所以的都链接进去的，不管有没有使用，但最近我测试都是没有的,应该是默认使用--as-needed选项），所以查找的时候没有使用lib1.so中指定的runpath路径。这个可以使用readelf -d lib1.so命令查看。这个可以给ld添加--no-as-needed选项来强制链接所有指定的库，而不是仅仅链接需要的。
解决办法 当前没有好的解决办法。 一个简单的方法是写一个libwarp来包装一下lib1，在libwarp中先设置一下LD_LIBRARY_PATH环境变量（设置自身进程的没有用，要设置父进程或全局的(加载自身进程的进程)），加上自身所在的路径（dladdr/GetModulePath获取），然后再使用ldopen的方式加载lib1。而程序则按照原来加载lib1.so的方式加载libwarp.so即可。 这种方式实现起来比较麻烦，需要把自己终结之后重新启动以使环境变量生效，不如直接写一个脚本去运行program，在这之前去设置LD_LIBRARY_PATH环境变量。
这个问题大概可以用下面的代码来表示（就不详细叙述了） https://files.cnblogs.com/files/oloroso/sopath.tar.gz</description>
    </item>
    
    <item>
      <title>OpenCV学习代码记录—— Snake轮廓</title>
      <link>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95-snake%E8%BD%AE%E5%BB%93/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95-snake%E8%BD%AE%E5%BB%93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/05/8722010.html 很久之前学习过一段时间的OpenCV，当时没有做什么笔记，但是代码都还在，这里把它贴出来做个记录。 代码放在码云上，地址在这里https://gitee.com/solym/OpenCVTest/tree/master/OpenCVTest
效果 代码 #include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; #include &amp;lt;opencv2/legacy/legacy.hpp&amp;gt;	// cvSnakeImage // http://blog.csdn.net/hongxingabc/article/details/51606520 //http://wiki.opencv.org.cn/index.php/Snake%E8%BD%AE%E5%BB%93%E4%BE%8B%E5%AD%90 static cv::Mat	src, src_bak;	// 原始图像及其备份 static int	thresholdness = 128;	// 阈值 // 下面的参数用于滑块的值传出 static int ialpha = 20;	// alpha代表点相互靠拢的权值(0-1.0) static int ibeta = 20;	// beta表示弯曲能量（越小越容易弯曲）(0-1.0) static int igamma = 20;	// gamma表示整体能量(0-1.0) void on_change(int pos,void*); int snakeContour() { // 创建窗口 cv::namedWindow(&amp;quot;win&amp;quot;, 0); // 添加四个进度条(滑块条) cv::createTrackbar(&amp;quot;Thd&amp;quot;, &amp;quot;win&amp;quot;, &amp;amp;thresholdness, 255, on_change); cv::createTrackbar(&amp;quot;alpha&amp;quot;, &amp;quot;win&amp;quot;, &amp;amp;ialpha, 100, on_change); cv::createTrackbar(&amp;quot;beta&amp;quot;, &amp;quot;win&amp;quot;, &amp;amp;ibeta, 100, on_change); cv::createTrackbar(&amp;quot;gamma&amp;quot;, &amp;quot;win&amp;quot;, &amp;amp;igamma, 100, on_change); cv::resizeWindow(&amp;quot;win&amp;quot;, 640, 480); // 调用一次on_change，以便显示出窗口 on_change(0,NULL); while (true){ if (cv::waitKey(40) == 27) { cv::destroyWindow(&amp;quot;win&amp;quot;); break;	// 按下ESC键就退出 } // 显示图像到窗口 cv::imshow(&amp;quot;win&amp;quot;, src_bak); } return 0; } void on_change(int,void*) { // 读取原图像 src_bak = cv::imread(&amp;quot;.</description>
    </item>
    
    <item>
      <title>OpenCV学习代码记录——Hough线段检测</title>
      <link>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95hough%E7%BA%BF%E6%AE%B5%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95hough%E7%BA%BF%E6%AE%B5%E6%A3%80%E6%B5%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/05/8722002.html 很久之前学习过一段时间的OpenCV，当时没有做什么笔记，但是代码都还在，这里把它贴出来做个记录。 代码放在码云上，地址在这里https://gitee.com/solym/OpenCVTest/tree/master/OpenCVTest
效果 代码 #include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; // http://blog.csdn.net/zhaocj/article/details/50281537 int houghLineDetection() { // 加载原图像 cv::Mat src = cv::imread(&amp;quot;../Image/houghline2.jpg&amp;quot;); if (src.empty()) { puts(&amp;quot;原图像读取失败!!!&amp;quot;); return -1; } cv::Mat	gray(src.size(), CV_8UC1);	// 原图的灰度图像 cv::cvtColor(src, gray, CV_BGR2GRAY); cv::Mat	edge(src.size(), CV_8UC1);	// 边缘图像 cv::Mat dst(src.size(), src.type());// 绘制直线的目标图像、 cv::cvtColor(gray, dst, CV_GRAY2BGR);	// 从灰度图转过来，便于后面绘制红色的线条 // 进行Canny边缘检测 cv::Canny(gray, edge, 50, 200, 3); #if 0 // 定义输出数组，用于存储直线的角度和距离这两个变量 std::vector&amp;lt;cv::Vec2f&amp;gt; lines; // 距离分辨率为1，角度分辨率为π/180，阈值为215 // 阈值的选取直接影响到输出直线的数量 cv::HoughLines(edge, lines, CV_HOUGH_PROBABILISTIC, CV_PI / 180.</description>
    </item>
    
    <item>
      <title>OpenCV学习代码记录——canny边缘检测</title>
      <link>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/05/8721981.html 很久之前学习过一段时间的OpenCV，当时没有做什么笔记，但是代码都还在，这里把它贴出来做个记录。 代码放在码云上，地址在这里https://gitee.com/solym/OpenCVTest/tree/master/OpenCVTest。
效果 代码 #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;	// cvtColor // http ://blog.csdn.net/hitwengqi/article/details/6877864 static cv::Mat image, edge;	// 原始图片，canny边缘保存图片 static cv::Mat	gray, gedge;	// 灰度图片，canny便于保存图片 int edgeThresh = 1;	// 控制进度条(传出进度条控制的值) void onTrackBar(int, void*); int CannyEdgeDetection() { // 加载原始图片 image = cv::imread(&amp;quot;../Image/sisy.jpg&amp;quot;); // 判断载入是否成功 if (image.empty()) { printf(&amp;quot;载入图片失败\n&amp;quot;); return -1; } // 生成灰度图片，因为只有灰度图片才能生成边缘图片 // gray.create(image.size(), image.type());	// 这里create是没有用的 cv::cvtColor(image, gray, CV_BGR2GRAY);	// 这里会自动去create到转换的目标保存类型，这里应该是UINT8 cv::imshow(&amp;quot;gray&amp;quot;, gray); // 新建一个窗口 cv::namedWindow(&amp;quot;Edge Map&amp;quot;, 1); // 生成一个进度条来控制边缘检测 cv::createTrackbar(&amp;quot;Canny Threshold&amp;quot;, &amp;quot;Edge Map&amp;quot;, &amp;amp;edgeThresh/*传出进度条的值*/,100/*进度条长度*/, onTrackBar /*进度条值改变时调用的函数*/); // 初始化图像 onTrackBar(0, NULL); // 等待按键 cv::waitKey(); return 0; } void onTrackBar(int, void*) { // blur 灰度图片(blur 模糊) cv::blur(gray, gedge, cv::Size(3, 3)); // Canny 边缘检测 cv::Canny(gray /*单通道输入图像.</description>
    </item>
    
    <item>
      <title>OpenCV学习代码记录——人脸检测</title>
      <link>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/05/8722016.html 很久之前学习过一段时间的OpenCV，当时没有做什么笔记，但是代码都还在，这里把它贴出来做个记录。 代码放在码云上，地址在这里https://gitee.com/solym/OpenCVTest/tree/master/OpenCVTest
效果 代码 我是直接使用OpenCV自带的分类器。如果有数据，可以自己训练得到。
 opencv之级联分类器训练属于自己的xml文件 opencv3.3版本训练自己的物体分类器  #include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;opencv2/objdetect.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; #include &amp;lt;cstdio&amp;gt; // g++ face.cpp -o face -std=c++11 -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_objdetect // 文件在opencv的安装目录下有 static const char* cascade_name = &amp;quot;D:\\OpenCV\\share\\OpenCV\\haarcascades\\&amp;quot; &amp;quot;haarcascade_frontalface_alt2.xml&amp;quot;; // http://wiki.opencv.org.cn/index.php/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B void frameFaceDetection(cv::Mat&amp;amp; src, cv::CascadeClassifier&amp;amp; cascade, const char* showWindowName); int FaceDetection(int c,char**v) { //cv::Mat	src,gray;	// 源图像，灰度图像 cv::VideoCapture	capture;	// 视频捕获对象 cv::Mat	frame;	// 视频帧 cv::CascadeClassifier	cascade;	//级联分类器 /** // 加载源图像 const char* picpath = &amp;quot;.</description>
    </item>
    
    <item>
      <title>OpenCV学习代码记录——轮廓(contour)检测</title>
      <link>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%E8%BD%AE%E5%BB%93contour%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-04-05-opencv%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95%E8%BD%AE%E5%BB%93contour%E6%A3%80%E6%B5%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/04/05/8721994.html 很久之前学习过一段时间的OpenCV，当时没有做什么笔记，但是代码都还在，这里把它贴出来做个记录。 代码放在码云上，地址在这里https://gitee.com/solym/OpenCVTest/tree/master/OpenCVTest
效果 代码 #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc/imgproc.hpp&amp;gt;	// cvtColor int contours_test(); int ContourDetection() { //return contours_test(); cv::Mat	image;	// 加载原始图片 cv::Mat	gary;	// 存储灰度图像 cv::Mat	dstimg;	// 绘制轮廓目标图片	// 创建两个窗口 cv::namedWindow(&amp;quot;src&amp;quot;);	// 原始图片显示窗口 cv::namedWindow(&amp;quot;dst&amp;quot;);	// 轮廓图片显示窗口 // 载入原始图片 image = cv::imread(&amp;quot;../Image/sisy.jpg&amp;quot;); if (image.empty()) { puts(&amp;quot;图片加载失败&amp;quot;); return -1; } cv::imshow(&amp;quot;src&amp;quot;, image);	// 显示原始图片 gary.create(image.size(), CV_8U);	// 申请灰度图存储空间 cv::cvtColor(image, gary, CV_BGR2GRAY);	// 转换原始图为灰度图 cv::threshold(gary, gary, 128, 255, cv::THRESH_BINARY);	// 转换为二值图	std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt; &amp;gt;	contours;	// 检测的轮廓数组 std::vector&amp;lt;cv::Vec4i&amp;gt;	hierarchy;	// int	mode = CV_RETR_EXTERNAL;	// 轮廓检测模式 //mode表示轮廓的检索模式 //	CV_RETR_EXTERNAL表示只检测外轮廓 //	CV_RETR_LIST检测的轮廓不建立等级关系 //	CV_RETR_CCOMP建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。 //	CV_RETR_TREE建立一个等级树结构的轮廓。具体参考contours.</description>
    </item>
    
    <item>
      <title>MSVC下使用Boost的自动链接</title>
      <link>http://sotex.github.io/post/2018-03-15-msvc%E4%B8%8B%E4%BD%BF%E7%94%A8boost%E7%9A%84%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Thu, 15 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-03-15-msvc%E4%B8%8B%E4%BD%BF%E7%94%A8boost%E7%9A%84%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/03/15/8574936.html
简述 好久没有用过boost库了，以前用也是在linux下，需要哪个部分就添加哪个部分到Makefile中。 最近要在Windows下使用，主要是mongocxx库依赖它，不想自己去编译它了，就直接在https://dl.bintray.com/boostorg/release/1.66.0/binaries/上下载已经编译好的版本。 下载安装后发现一个问题，就是它的lib目录下存在多个不同编译参数编译的版本，在VC中它会自己根据当前环境选择对应的库进行链接（通过#pragma comment(lib,&amp;quot;库路径&amp;quot;指令实现）。而我需要使用指定的版本。
关于boost在windows下编译出的库文件的命令方式可以在这里查到http://www.boost.org/doc/libs/1_66_0/more/getting_started/windows.html。 我就不做翻译了，网上找到了两篇介绍的文章 Boost库的命名规则 Boost库编译后命名方式
指定使用的boost编译版本说明 这里主要是要说一下如何指定使用特定编译版本的boost库。 在工程中可以通过定义下面几个宏变量来设置
   变量名 含义     BOOST_LIB_NAME 必需：包含库的基本名称的字符串，例如boost_regex   BOOST_LIB_TOOLSET 可选：工具集的基本名称，例如VS2015就是vc140   BOOST_LIB_THREAD_OPT 多线程版本选项，-mt用于多线程构建，否则为空   BOOST_LIB_RT_OPT 指示使用的运行时库的后缀在连字符后包含以下一个或多个字母：
s 使用静态运行时库的版本(对应VC的MT)，留空则为动态运行时库版本
g Debug版本运行时库版本(对应VC的MTd或MDd)，为空则为release运行时版本
y python Debug版本
d Debug版本库
p 使用STLport编译版本
n 没有使用iostream的STLport构建版本   BOOST_LIB_ARCH_AND_MODEL_OPT 架构和地址模型(-x32表示x86/32版本-x64表示x86/64版本)   BOOST_LIB_VERSION Boost版本，形式为x_y，用于Boost版本x.y.   以下是用于编译boost时候的    BOOST_DYN_LINK 可选：要设置链接dll而不是静态库时   BOOST_LIB_DIAGNOSTIC 可选：要设置头文件打印出选定的库名（用于调试）   BOOST_AUTO_LINK_NOMANGLE 指定应该连接到BOOST_LIB_NAME.</description>
    </item>
    
    <item>
      <title>XML文件生成C&#43;&#43;代码(基于rapidxml)</title>
      <link>http://sotex.github.io/post/2018-03-09-xml%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90c&#43;&#43;%E4%BB%A3%E7%A0%81%E5%9F%BA%E4%BA%8Erapidxml/</link>
      <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-03-09-xml%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90c&#43;&#43;%E4%BB%A3%E7%A0%81%E5%9F%BA%E4%BA%8Erapidxml/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/03/09/8532624.html
简述 与XML文件生成C++代码(基于pugixml)中的功能一致，只是这里改用的rapidxml来实现。就不多说了，直接放代码。
代码 #include &amp;quot;rapidxml-1.13/rapidxml.hpp&amp;quot; #include &amp;quot;rapidxml-1.13/rapidxml_utils.hpp&amp;quot; #include &amp;quot;rapidxml-1.13/rapidxml_iterators.hpp&amp;quot; #include &amp;quot;rapidxml-1.13/rapidxml_print.hpp&amp;quot; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; // XML节点名称中可以包含C++变量名不支持的字符 // 需要将其规范化，使之能够正常作为C++变量名 std::string normalVarName(std::string s) { // XML 元素必须遵循以下命名规则： // 名称可以含字母、数字以及其他的字符 // 名称不能以数字或者标点符号开始 // 名称不能以字符 “xml”（或者 XML、Xml）开始 // 名称不能包含空格 // 可使用任何名称，没有保留的字词。 // 如果只需要C++编译通过，完全可以将s转换为base16表示的字符串即可 // 这里我只对 : . , ; 做一下处理，其它的就先不管了 for(std::size_t pos = s.find_first_of(&amp;quot;:.,;&amp;quot;); pos != std::string::npos; pos = s.find_first_of(&amp;quot;:.,;&amp;quot;,pos+1)){ s[pos] = &#39;_&#39;; } return s; } // 对于节点的值，它有可能包含需要转义的字符，需要进行转义(未考虑C++原始字面常量) std::string toEscape(const std::string&amp;amp; s) { std::string s2; s2.</description>
    </item>
    
    <item>
      <title>windows 10 更新失败及应用商店重装问题解决记录</title>
      <link>http://sotex.github.io/post/2018-03-09-windows-10-%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E9%87%8D%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-03-09-windows-10-%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E9%87%8D%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/03/09/8532894.html 简单的记录一下这次遇到的问题及解决办法。 使用的windows 10 企业版一直不能更新成功，各种办法都试过了，都是失败然后回退。
这次直接下载了1709的映像进行升级安装的，因为我的是双系统，升级安装的时候居然也不能成功。 系统并不是EFI启动的，所以是直接将MBR引导记录重建了，重建之后在msconfig中可以看到引导页下有了win10的启动项。之后进行升级安装就没有问题了。
再记录一下应用商店重装的问题，这个在知乎上找到来了答案。
误删 Win10 应用商店应该如何恢复？ - 范泽栋的回答 - 知乎 https://www.zhihu.com/question/36090296/answer/162985011
2018年3月12日 补充 原本win10企业版更新安装后无需激活。
另一台笔记本是UEFI启动的，启动项也就win10一个，更新失败。 后来采取升级安装，安装成功，但是无法进入桌面（进入桌面后报错，点击确定之后自动注销）。</description>
    </item>
    
    <item>
      <title>XML文件生成C&#43;&#43;代码(基于pugixml)</title>
      <link>http://sotex.github.io/post/2018-03-06-xml%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90c&#43;&#43;%E4%BB%A3%E7%A0%81%E5%9F%BA%E4%BA%8Epugixml/</link>
      <pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-03-06-xml%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90c&#43;&#43;%E4%BB%A3%E7%A0%81%E5%9F%BA%E4%BA%8Epugixml/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/03/06/8515466.html
简述 在一个项目中需要用到XML的解析和生成，知乎上有人推荐rapidxml和pugixml等库。RapidXML一看库还比较大，就先研究一下pugixml了。 因为对解析XML的需求不大（都是一些很小的XML文本），但是对生成XML有较大的需求，且这些XML文本都很大，所以先写了一个根据XML文件生成对应的C++代码的项目。
对XML的规范并不熟悉，所以这里只做了读取节点属性和节点值生成对应代码的操作，对于其它的部分，我也不知道还有哪里需要做的。 这里没有考虑非UTF-8编码和宽字符的情况，我这里暂时用不上，需要的可以根据自己的情况改。
不知道是不是pugixml的bug，对于一个没有子节点的节点，也能获取其一个无名子节点
示例 假设有如下内容的XML文件
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt; &amp;lt;EnvelopeN xsi:type=&#39;typens:EnvelopeN&#39; xmlns:xsi=&#39;http://www.w3.org/2001/XMLSchema-instance&#39; xmlns:xs=&#39;http://www.w3.org/2001/XMLSchema&#39; xmlns:typens=&#39;http://www.esri.com/schemas/ArcGIS/10.1&#39;&amp;gt; &amp;lt;XMin&amp;gt;-180&amp;lt;/XMin&amp;gt; &amp;lt;YMin&amp;gt;-90&amp;lt;/YMin&amp;gt; &amp;lt;XMax&amp;gt;180&amp;lt;/XMax&amp;gt; &amp;lt;YMax&amp;gt;90&amp;lt;/YMax&amp;gt; &amp;lt;SpatialReference xsi:type=&#39;typens:GeographicCoordinateSystem&#39;&amp;gt; &amp;lt;WKT&amp;gt;GEOGCS[&amp;amp;quot;GCS_WGS_1984&amp;amp;quot;,DATUM[&amp;amp;quot;D_WGS_1984&amp;amp;quot;,SPHEROID[&amp;amp;quot;WGS_1984&amp;amp;quot;,6378137.0,298.257223563]],PRIMEM[&amp;amp;quot;Greenwich&amp;amp;quot;,0.0],UNIT[&amp;amp;quot;Degree&amp;amp;quot;,0.0174532925199433],AUTHORITY[&amp;amp;quot;EPSG&amp;amp;quot;,4326]]&amp;lt;/WKT&amp;gt; &amp;lt;XOrigin&amp;gt;-400&amp;lt;/XOrigin&amp;gt; &amp;lt;YOrigin&amp;gt;-400&amp;lt;/YOrigin&amp;gt; &amp;lt;XYScale&amp;gt;11258999068426.238&amp;lt;/XYScale&amp;gt; &amp;lt;ZOrigin&amp;gt;-100000&amp;lt;/ZOrigin&amp;gt; &amp;lt;ZScale&amp;gt;10000&amp;lt;/ZScale&amp;gt; &amp;lt;MOrigin&amp;gt;-100000&amp;lt;/MOrigin&amp;gt; &amp;lt;MScale&amp;gt;10000&amp;lt;/MScale&amp;gt; &amp;lt;XYTolerance&amp;gt;8.983152841195215e-009&amp;lt;/XYTolerance&amp;gt; &amp;lt;ZTolerance&amp;gt;0.001&amp;lt;/ZTolerance&amp;gt; &amp;lt;MTolerance&amp;gt;0.001&amp;lt;/MTolerance&amp;gt; &amp;lt;HighPrecision&amp;gt;true&amp;lt;/HighPrecision&amp;gt; &amp;lt;LeftLongitude&amp;gt;-180&amp;lt;/LeftLongitude&amp;gt; &amp;lt;WKID&amp;gt;4326&amp;lt;/WKID&amp;gt; &amp;lt;LatestWKID&amp;gt;4326&amp;lt;/LatestWKID&amp;gt; &amp;lt;/SpatialReference&amp;gt; &amp;lt;/EnvelopeN&amp;gt;  那么生成的代码如下
pugi::xml_document xmldoc; { pugi::xml_node decl = xmldoc.append_child(pugi::node_declaration); decl.append_attribute(&amp;quot;version&amp;quot;) = &amp;quot;1.0&amp;quot;; decl.append_attribute(&amp;quot;encoding&amp;quot;) = &amp;quot;utf-8&amp;quot;; } { {/*add EnvelopeN*/ pugi::xml_node EnvelopeN = xmldoc.append_child(&amp;quot;EnvelopeN&amp;quot;); EnvelopeN.append_attribute(&amp;quot;xsi:type&amp;quot;)=&amp;quot;typens:EnvelopeN&amp;quot;; EnvelopeN.append_attribute(&amp;quot;xmlns:xsi&amp;quot;)=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;; EnvelopeN.append_attribute(&amp;quot;xmlns:xs&amp;quot;)=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot;; EnvelopeN.</description>
    </item>
    
    <item>
      <title>CPLSetErrorHandlerEx函数Bug</title>
      <link>http://sotex.github.io/post/2018-02-06-cplseterrorhandlerex%E5%87%BD%E6%95%B0bug/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-02-06-cplseterrorhandlerex%E5%87%BD%E6%95%B0bug/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/02/06/8422758.html CPLSetErrorHandlerEx(gdal/gdal/port/cpl_error.cpp，当前github中代码)当前函数实现如下
CPLErrorHandler CPL_STDCALL CPLSetErrorHandlerEx( CPLErrorHandler pfnErrorHandlerNew, void* pUserData ) { CPLErrorContext *psCtx = CPLGetErrorContext(); if( psCtx == nullptr || IS_PREFEFINED_ERROR_CTX(psCtx) ) { fprintf(stderr, &amp;quot;CPLSetErrorHandlerEx() failed.\n&amp;quot;); return nullptr; } if( psCtx-&amp;gt;psHandlerStack != nullptr ) { CPLDebug( &amp;quot;CPL&amp;quot;, &amp;quot;CPLSetErrorHandler() called with an error handler on &amp;quot; &amp;quot;the local stack. New error handler will not be used &amp;quot; &amp;quot;immediately.&amp;quot; ); } CPLErrorHandler pfnOldHandler = nullptr; { CPLMutexHolderD( &amp;amp;hErrorMutex ); pfnOldHandler = pfnErrorHandler; if( pfnErrorHandler == nullptr ) pfnErrorHandler = CPLDefaultErrorHandler; else pfnErrorHandler = pfnErrorHandlerNew; pErrorHandlerUserData = pUserData; } return pfnOldHandler; }  这里if( pfnErrorHandler == nullptr )这一句判断应该改为if( pfnErrorHandlerNew== nullptr )。 否则调用过一次CPLSetErrorHandlerEx(NULL,NULL)后将无法再设置新的错误处理函数，必须再次调用使之变为CPLDefaultErrorHandler后方能重新设置(如果没有重新设置，程序将出现段错误)。 自己编译GDAL的时候可以改过了，或者调用的时候传参别传错了即可。 对于这个问题，我已经提交给GDAL开发者了，这个问题已经修正了。CPLSetErrorHandler(): avoid later crashes when passing a null callback.</description>
    </item>
    
    <item>
      <title>ArcGIS进行自定义投影转换(重投影)</title>
      <link>http://sotex.github.io/post/2018-01-22-arcgis%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%95%E5%BD%B1%E8%BD%AC%E6%8D%A2%E9%87%8D%E6%8A%95%E5%BD%B1/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-01-22-arcgis%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%95%E5%BD%B1%E8%BD%AC%E6%8D%A2%E9%87%8D%E6%8A%95%E5%BD%B1/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/01/22/8329750.html 这里记录一下使用自定义七参数进行投影转换的过程。
1、主动创建自定义地理(坐标)变换 首先在系统工具箱里面选择创建自定义地理(坐标)变换 在弹出的窗口中输入相关参数即可。 转换方法选择COORDINATE_FRAME(坐标系框架) 2、进行投影变换 在系统工具箱中选择投影栅格进行重投影操作。 在弹出的对话框中设置相应的参数，然后点击确定。 可以在结果窗口查看任务 3、动态投影 动态投影是指将不同坐标系的数据，动态投影到某一坐标系（数据框的坐标系）。
先设置数据框的坐标系 选择坐标系后点击应用。
然后设置使用的变换方式 这里你也可以新建一个地理变换，点击右侧新建按钮，在弹出框中设置相关参数即可。 4、其它补充 ArcGIS中自定义的坐标转换保存在%AppData%\Roaming\ESRI\Desktop10.2\ArcToolbox\CustomTransformations中 </description>
    </item>
    
    <item>
      <title>ArcGIS调整影像颜色输出</title>
      <link>http://sotex.github.io/post/2018-01-18-arcgis%E8%B0%83%E6%95%B4%E5%BD%B1%E5%83%8F%E9%A2%9C%E8%89%B2%E8%BE%93%E5%87%BA/</link>
      <pubDate>Thu, 18 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-01-18-arcgis%E8%B0%83%E6%95%B4%E5%BD%B1%E5%83%8F%E9%A2%9C%E8%89%B2%E8%BE%93%E5%87%BA/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/01/18/8310868.html 有碰到一些质量很差的遥感影像，颜色需要进行调整（主要是针对看）输出，这里记录一下ArcGIS中的调整输出方式。
1、首先把影像文件拖入ArcMap中，然后右键单击图层列表中的图像，选择属性。 2、选择符号系统然后调整好相关参数，点击应用即可。 我选择的拉伸类型为Esri，这种方式效果比较不错，你也可以选择直方图均衡化等。（如果你影像也有无效数据部分，注意设置下无效值NoData） 3、现在已经可以在ArcMap中看到图像渲染的结果了，现在可以将图像输出了。 4、输出图像的参数选择 在输出位置的选择上，必选选择一个文件夹（如果无法选择就连接一个目录，然后新建一个），不然无法选择输出格式。 输出的时候必须选择使用渲染器，否则输出的未调色的原始图像。 设置好输出参数之后，直接点击保存即可。</description>
    </item>
    
    <item>
      <title>GDALBuildVRT异构波段的支持</title>
      <link>http://sotex.github.io/post/2018-01-12-gdalbuildvrt%E5%BC%82%E6%9E%84%E6%B3%A2%E6%AE%B5%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2018-01-12-gdalbuildvrt%E5%BC%82%E6%9E%84%E6%B3%A2%E6%AE%B5%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2018/01/12/8275454.html
简述 GDALBuildVRT工具和函数默认都是不支持异构波段的（即要建立虚拟影像目录的文件中有波段与其它有异的，少于指定波段等特征的），公司一个项目中需要支持这个特性，不足的以第1波段替代（除非波段数为0，那这在影像质检的时候就已经检查完了），这里记录一下修改方式。
修改源码 使用的GDAL版本是2.2.3，修改的源码文件为gdal-2.2.3\apps\gdalbuildvrt_lib.cpp。
1、修改DatasetProperty结构体 修改这个结构体，增加用于记录每个影像波段数的成员变量，修改结果如下
大致在源文件的75-90行
typedef struct { int isFileOK; int nRasterXSize; int nRasterYSize; double adfGeoTransform[6]; int nBlockXSize; int nBlockYSize; GDALDataType firstBandType; int* panHasNoData; double* padfNoDataValues; int bHasDatasetMask; int nMaskBlockXSize; int nMaskBlockYSize; int nRasterBandCount; /*新增，记录影像波段数*/ } DatasetProperty;  2、修改VRTBuilder::AnalyseRaster函数 大致在源文件的406-789行 修改这个函数主要是去除对异构波段的检测，同时加上对来源影像波段数的记录。
将以下代码 大致在源文件的543行
int _nBands = GDALGetRasterCount(hDS);  修改为如下，记录来源影像的波段数
int _nBands = psDatasetProperties-&amp;gt;nRasterBandCount =GDALGetRasterCount(hDS);  将以下代码注释掉，跳过波段数的检测 大致在源文件的685-690行
if (!bSeparate) { // if (nMaxBandNo &amp;gt; _nBands) // { // CPLError(CE_Warning, CPLE_NotSupported, // &amp;quot;gdalbuildvrt does not support heterogeneous band numbers.</description>
    </item>
    
    <item>
      <title>CString与UTF8互转代码</title>
      <link>http://sotex.github.io/post/2017-12-25-cstring%E4%B8%8Eutf8%E4%BA%92%E8%BD%AC%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-12-25-cstring%E4%B8%8Eutf8%E4%BA%92%E8%BD%AC%E4%BB%A3%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/12/25/8108477.html 这个代码网上很多，留在这里做个备份。
static std::string ConvertCStringToUTF8( CString strValue ) { std::wstring wbuffer; #ifdef _UNICODE wbuffer.assign( strValue.GetString(), strValue.GetLength() ); #else /* * 转换ANSI到UNICODE * 获取转换后长度 */ int length = ::MultiByteToWideChar( CP_ACP, MB_ERR_INVALID_CHARS, (LPCTSTR) strValue, -1, NULL, 0 ); wbuffer.resize( length ); /* 转换 */ MultiByteToWideChar( CP_ACP, 0, (LPCTSTR) strValue, -1, (LPWSTR) (wbuffer.data() ), wbuffer.length() ); #endif /* 获取转换后长度 */ int length = WideCharToMultiByte( CP_UTF8, 0, wbuffer.data(), wbuffer.size(), NULL, 0, NULL, NULL ); /* 获取转换后内容 */ std::string buffer; buffer.</description>
    </item>
    
    <item>
      <title>std::accumulate使用的一个小细节</title>
      <link>http://sotex.github.io/post/2017-12-21-std-accumulate%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-12-21-std-accumulate%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/12/21/8080121.html 今天使用std::accumulate模板函数的时候出现了一个错误，特此记录一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;numeric&amp;gt; int main() { int LevelColRow[][3] = { 1, 2,	1, 2, 4,	2, 3, 8,	4, 4, 16,	8, 5, 32,	16, 6, 64,	32, 7, 128, 64, 8, 256, 128, 9, 512, 256, 10, 1024, 512, 11, 2048, 1024, 12, 4096, 2048, 13, 8192, 4096, 14, 16384, 8192, 15, 32768, 16384, 16, 65536, 32768 /*, 17, 131072, 65536/*, 18, 262144, 131072, 19, 524288, 262144*/ }; double xx = std::accumulate( std::begin( LevelColRow ), std::end( LevelColRow ), 0, [] (double val, int lcr[3]) { return(val + double(lcr[1]) * double(lcr[2]) ); } ); double xx2 = 0; for ( auto x : LevelColRow ) { xx2 += double(x[1]) * double(x[2]); } std::cout &amp;lt;&amp;lt; (int64_t) xx &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; (int64_t) xx2 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;quot;Hello, world!</description>
    </item>
    
    <item>
      <title>Windows下VS2017编译OpenCV 3.4.0-rc</title>
      <link>http://sotex.github.io/post/2017-12-20-windows%E4%B8%8Bvs2017%E7%BC%96%E8%AF%91opencv-3.4.0-rc/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-12-20-windows%E4%B8%8Bvs2017%E7%BC%96%E8%AF%91opencv-3.4.0-rc/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/12/20/8074783.html
简述 很久没有用过OpenCV了，这次需要做一点图像处理相关的工作，又需要用起来，这里记录一下编译的过程。之前介绍过使用vs2015编译opencv2.4的帖子在这里。 编译好的文件在这里https://pan.baidu.com/s/1qXCWxkw
1、下载源码 这里就不下载源码压缩包了，直接从github上克隆一下。
# 因为访问github较慢，这里直接使用的国内码云同步仓库 git clone https://gitee.com/mirrors/opencv.git # github上的地址为：https://github.com/opencv/opencv.git  克隆之后可以将3.4.0-rc分支打包出来，你也可以直接切换到3.4.0-rc分支或者直接使用master的代码。
cd opencv git archive -o ../opencv3.4.0.zip 3.4.0-rc  打包出来的压缩包是不含git仓库的相关文件的，不是很大，可以解压到你想解压的目录。
2、使用cmake生成VS工程 我这里就没有使用命令行，直接使用的cmake-gui进行的配置。 选择源码目录和构建目录之后，点击configure按钮，然后选择编译器为visual studio 2015 2017 win64，等待配置结束。（配置的过程中会去下载opencv_ffmpeg.dll等文件，过程可能比较慢）
我使用的构建选项改变如下（Tools&amp;ndash;&amp;gt;My Changes）
Commandline options: -DBUILD_JAVA:BOOL=&amp;quot;0&amp;quot; -DENABLE_LTO:BOOL=&amp;quot;1&amp;quot; -DWITH_GSTREAMER:BOOL=&amp;quot;0&amp;quot; -DCPACK_BINARY_ZIP:BOOL=&amp;quot;1&amp;quot; -DBUILD_TESTS:BOOL=&amp;quot;0&amp;quot; -DENABLE_CXX11:BOOL=&amp;quot;1&amp;quot; -DBUILD_PERF_TESTS:BOOL=&amp;quot;0&amp;quot; -DCPACK_SOURCE_7Z:BOOL=&amp;quot;0&amp;quot; -DCPACK_BINARY_NSIS:BOOL=&amp;quot;0&amp;quot; Cache file: BUILD_JAVA:BOOL=0 ENABLE_LTO:BOOL=1 WITH_GSTREAMER:BOOL=0 CPACK_BINARY_ZIP:BOOL=1 BUILD_TESTS:BOOL=0 ENABLE_CXX11:BOOL=1 BUILD_PERF_TESTS:BOOL=0 CPACK_SOURCE_7Z:BOOL=0 CPACK_BINARY_NSIS:BOOL=0  配置输出信息如下
General configuration for OpenCV 3.4.0-rc ===================================== Version control: unknown Platform: Timestamp: 2017-12-20T08:35:12Z Host: Windows 10.</description>
    </item>
    
    <item>
      <title>WinHttp编写HTTP服务器示例代码</title>
      <link>http://sotex.github.io/post/2017-10-17-winhttp%E7%BC%96%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-10-17-winhttp%E7%BC%96%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/10/17/7684672.html 这是微软提供的示例程序，原文地址在此https://msdn.microsoft.com/en-us/library/windows/desktop/aa364640(v=vs.85).aspx
HTTP Server示例程序 以下示例应用程序展示如何使用HTTP Server API处理HTTP请求任务。第一个示例中包含的precomp.h文件包含示例所需的所有头文件，如下：
#ifndef UNICODE #define UNICODE #endif #ifndef _WIN32_WINNT #define _WIN32_WINNT 0x0600 #endif #ifndef WIN32_LEAN_AND_MEAN #define WIN32_LEAN_AND_MEAN #endif #include &amp;lt;windows.h&amp;gt; #include &amp;lt;http.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #pragma comment(lib, &amp;quot;httpapi.lib&amp;quot;)  Main and Preliminaries(main和准备工作) #include &amp;quot;precomp.h&amp;quot; // // Macros.初始化HTTP响应体宏 // #define INITIALIZE_HTTP_RESPONSE( resp, status, reason ) \ do \ { \ RtlZeroMemory( (resp), sizeof(*(resp)) ); \ (resp)-&amp;gt;StatusCode = (status); \ (resp)-&amp;gt;pReason = (reason); \ (resp)-&amp;gt;ReasonLength = (USHORT) strlen(reason); \ } while (FALSE) #define ADD_KNOWN_HEADER(Response, HeaderId, RawValue) \ do \ { \ (Response).</description>
    </item>
    
    <item>
      <title>各个版本VS编译好的GDAL库下载</title>
      <link>http://sotex.github.io/post/2017-09-18-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%ACvs%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84gdal%E5%BA%93%E4%B8%8B%E8%BD%BD/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-09-18-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%ACvs%E7%BC%96%E8%AF%91%E5%A5%BD%E7%9A%84gdal%E5%BA%93%E4%B8%8B%E8%BD%BD/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/09/18/7544281.html
简单说明 自己编译GDAL比较繁琐且时间较长，而且很多 Driver 需要自己去编译。如果不是要学习怎么编译GDAL，可以直接使用已经编译好的库。
OSGeo官方没有提供编译好的GDAL，但是它有给出去哪里下载已经编译好的。下载GDAL二进制包说明
我已经下载好一份各个VS版本编译出来的GDAL库。 在使用的时候某些Driver是作为插件plugins存在的(如MrSid、HDF4、HDF5、NETCDF、ECW_JP2ECW等)，所以需要设置一下环境变量GDAL_DRIVER_PATH的值(各个driver位于压缩包内release-1XXX-x64-dev.zip\release-1XXX-x64\bin\gdal\plugins)。
下载地址如下 链接：http://pan.baidu.com/s/1miQMEes 密码：h0xa
来源链接</description>
    </item>
    
    <item>
      <title>C&#43;&#43;高性能转换大小写算法</title>
      <link>http://sotex.github.io/post/2017-08-17-c&#43;&#43;%E9%AB%98%E6%80%A7%E8%83%BD%E8%BD%AC%E6%8D%A2%E5%A4%A7%E5%B0%8F%E5%86%99%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-08-17-c&#43;&#43;%E9%AB%98%E6%80%A7%E8%83%BD%E8%BD%AC%E6%8D%A2%E5%A4%A7%E5%B0%8F%E5%86%99%E7%AE%97%E6%B3%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/08/17/7384709.html
简述 有一个需求，是需要将URL中的query参数的key全部转换为小写或者大写，键值对的数量有点多，但全部都是英文字母，无需考虑非字母的情况。 实现比较快的做法是使用STL或C标准库中的转换接口，如下：
#include &amp;lt;string&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; // 字符串中的大写字符转小写 std::string strtolower(std::string s) { transform(s.begin(), s.end(), s.begin(), ::tolower); return s; } // 字符串中的小写字符转大写 std::string strtoupper(std::string s) { transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }  这个方法虽然很好，但是效率不是很高。 分析了一下ascii码的码值，发现大小写字母的ascii码之间是有规律的。
原理 英文字母的ASCII码值表示如下 对比一下其二进制形式 对比使用的是OSChina的在线工具http://tool.oschina.net/diff/
从对比的结果可以看出，大写字母与小写字母的差别仅是一个比特位的不同。 因为它们的这个规律，可以写出下面的转换函数（如果输入不是字母，转出的结果会有错误） 可以查看数字0-9的ascii码值，可以看出它们的第6位都是0，所以转为小写的算法不会影响数字的值。 转小写算法中受到影响的，只有ascii码二进制表示中第六位为0的部分。其中非字母部分如下表 #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;stdint.h&amp;gt; // 更优化 std::string strtoupper(std::string s) { if(s.empty()){return s;} size_t len = s.size() + 1; size_t alignlen = len + 8 - (len % 8); s.</description>
    </item>
    
    <item>
      <title>VS编译 x64版本zlib库</title>
      <link>http://sotex.github.io/post/2017-08-04-vs%E7%BC%96%E8%AF%91-x64%E7%89%88%E6%9C%ACzlib%E5%BA%93/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-08-04-vs%E7%BC%96%E8%AF%91-x64%E7%89%88%E6%9C%ACzlib%E5%BA%93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/08/04/7284874.html 编译的过程倒也不是很难。我把编译的源码和脚本及说明都放在gitee上了。
详细的可以见这里 https://gitee.com/solym/zlib-1.2.11.git
可以参考这些文章 win10下Visual Studio 2015，C++ x64编译zlib zlib库VS2015编译步骤</description>
    </item>
    
    <item>
      <title>如何导出标准模板库(STL)类的实例化和包含STL类对象数据成员的类</title>
      <link>http://sotex.github.io/post/2017-08-01-%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%8C%85%E5%90%ABstl%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-08-01-%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%8C%85%E5%90%ABstl%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/08/02/7271720.html 本文翻译自 https://support.microsoft.com/zh-cn/help/168958/how-to-export-an-instantiation-of-a-standard-template-library-stl-clas
概要 本文讨论如何实现下面任务： - 导出标准模板库（STL）类的实例化。 - 导出包含STL类对象数据成员的类。
注意，您无法导出通用的模板，模板必须实例化才能导出。也就是说，必须提供所有的模板参数，并且在实例化时，模板的参数必须是完全定义的类型。例如stack&amp;lt;int&amp;gt;实例化STL堆栈类，实例化时强制生成类stack&amp;lt;int&amp;gt;的所有成员。 还要注意，一些STL容器（map、set、queue、list、deque）无法导出。
更多信息 从VC++ 5.0开始，可以强制对模板类进行实例化并导出实例化类。导出实例化模板类，可使用以下语法：
导出STL类  在.dll和.exe文件中，必须链接到相同版本的C运行时库dll。两个都链接msvcrt.lib(Release版本)或都链接到msvcrtd.lib(Debug版本)。 在dll中，在模板的实例化声明中使用__declspec修饰符，以便从dll中导出STL类的实例化。 在exe中，需提供使用extern和__declspec修饰的模板实例化声明，以便从dll中导入类。 这会导致警告 C4231 &amp;quot;nonstandard extension used : &#39;extern&#39; before template explicit instantiation.&amp;quot;。 您可以忽略此警告。  导出包含STL类对象数据成员的类  在.dll和.exe文件中，必须链接到相同版本的C运行时库dll。两个都链接msvcrt.lib(Release版本)或都链接到msvcrtd.lib(Debug版本)。 在dll中，在模板的实例化声明中使用__declspec修饰符，以便从dll中导出STL类的实例化。 注意：不能跳过上一步，用于创建数据成员的STL类必须导出其实例化。 在dll中，在类的声明中使用__declspec修饰符，以便从dll中导出类。 在exe中，在类的声明中使用__declspec修饰符，以便从dll中导入类。 如果要导出的类有一个或多个基类，那么其基类也必须导出。如果要导出的类中还包含某类类型的数据成员，则还必须导出数据成员类型的类。  注意：一些STL类使用到其它的STL类，这些依赖的类也必须导出。如果使用低于1的警告级别(也就是/W2、/W3、/W4)，则必须导出类会出现在编译器警告信息中。/W4级别编译时，会因为STL而生成大量警告信息，目前不推荐使用此级别警告。
一些STL类包含嵌套类，所以无法导出这些类。例如，deque包含一个嵌套类deque::iterator。如果导出deque，将产生警告信息。，提示你必须导出deque::iterator；如果你导出deque::iterator则会产生警告信息，提示你必须导出deque。这是受限于STL的设计，一旦模板类被实例化，它不能被重新实例化和导出。目前唯一可以导出的STL容器是vector，其它容器（map、set、queue、list、deque）都包含嵌套类无法导出。
导出使用用户定义类型（UDT）作为STL容器模板参数实例化的类时，必须为自定义类型（）UDT）重载&amp;lt;和==运算符。例如，如果导出vector&amp;lt;MyClass&amp;gt;，则必须定义MyClass::operator&amp;lt;和MyClass::==。这是因为所有的STL容器类都具有成员比较运算操作，需要使用到包含类型的&amp;lt;和==运算操作。通常，这些都不被实例化，因为它们没有被使用。当实例化一个模板类时，会生成所有的成员函数，因为STL容器类具有使用到&amp;lt;和==的成员函数，所有必须实现它们。如果比较UDT的对象没有意义，也可以在定义operator&amp;lt;和opeartor==的时候，简单的返回true。
当在编译期间发现_DLL已经定义（当使用/MD或/MDd编译与C运行时库的DLL版本链接时，该符号被隐含定义），以下STL类以及对这些类的操作的各种全局运算符和函数，已在C运行时库DLL中导出。因此，无法从DLL中导出它们。z只要导入类也使用相同的C运行时DLL版本，则不应该导致可执行程序出问题。
Header STL template class ------------------------------ &amp;lt;IOSFWD&amp;gt; basic_ios &amp;lt;IOSFWD&amp;gt; &amp;lt;IOSFWD&amp;gt; &amp;lt;IOSFWD&amp;gt; basic_istream &amp;lt;IOSFWD&amp;gt; basic_string (also typedef&#39;d as string and wstring) &amp;lt;IOSFWD&amp;gt; complex &amp;lt;LOCALE&amp;gt; messages &amp;lt;XLOCALE&amp;gt; codecvt &amp;lt;XLOCALE&amp;gt; ctype &amp;lt;XLOCMON&amp;gt; moneypunct &amp;lt;XLOCMON&amp;gt; money_get &amp;lt;XLOCMON&amp;gt; money_put &amp;lt;XLOCNUM&amp;gt; numpunct &amp;lt;XLOCTIME&amp;gt; time_get &amp;lt;XLOCTIME&amp;gt; time_put &amp;lt;XSTRING&amp;gt; basic_string (also typedef&#39;d as string and wstring)  有关使用哪些模板参数以及声明哪些全局函数和操作符的具体细节，请参阅相关的头文件。</description>
    </item>
    
    <item>
      <title>早前阅读live555源码做的笔记</title>
      <link>http://sotex.github.io/post/2017-07-22-%E6%97%A9%E5%89%8D%E9%98%85%E8%AF%BBlive555%E6%BA%90%E7%A0%81%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 22 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-07-22-%E6%97%A9%E5%89%8D%E9%98%85%E8%AF%BBlive555%E6%BA%90%E7%A0%81%E5%81%9A%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/07/23/7223353.html 早前阅读live555源码的时候做了一些简单的笔记。现在看来那个时候对C++的理解还是不够，还有很多不足。当时对很多名词也不是很熟悉，对一些类的描述也很生硬，所以笔记中有一些不通畅之处。 阅读live555是当时在流媒体服务器组的时候阅读的，后来应公司安排，改去做snmp协议支持，就少有更新这一部分了。非常感谢当时公司和同事给予的学习机会。
这里共享出当时的学习笔记。
下载地址 Live555源码阅读2015-05-20(1-4).pdf Live555源码阅读2015-05-20.pdf</description>
    </item>
    
    <item>
      <title>windows下 jemalloc编译</title>
      <link>http://sotex.github.io/post/2017-06-27-windows%E4%B8%8B-jemalloc%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-06-27-windows%E4%B8%8B-jemalloc%E7%BC%96%E8%AF%91/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2017/06/27/7085648.html
1、准备 Windows下使用VS2015进行编译，需要使用cmake构建版本。（如果有cygwin，在其中执行VS的vcvarsall.bat后使用&amp;quot;CC=cl ./autogen.sh&amp;quot;命令生成Makefile后编译也是可以的） 下载源码
git clone https://github.com/jemalloc/jemalloc-cmake.git  请确保已经安装好cmake工具。
还可以下载一个专门为win32修改的版本，支持VC6编译。
git clone https://github.com/BlzFans/jemalloc_win32.git  2、编译 分别使用VS2015和mingw编译。
VS2015编译jemalloc 方式一 直接使用VS2015打开源码目录下的msvc目录下的jemalloc_vc2015，然后进行编译即可。 使用这种方式编译的时候有很多问题。首先是VS2015不支持C11的atomic，没有stdatomic.h头文件，这需要注释掉JEMALLOC_C11ATOMICS这个宏定义。然后是大量__builtin_xxxxx函数未定义，这个可以使用自己实现的。
方式二 打开VS2015 x64本机工具命令提示符(VS2015 x64 Native Tools Command Prompt)。 进入源码目录，创建一个目录build，进入build目录后执行下面命令。
Z:\jemalloc\jemalloc-cmake\build&amp;gt;cmake -G&amp;quot;Visual Studio 14 Win64&amp;quot; -DCMAKE_INSTALL_PREFIX=Z:\vs140-64 ..  因为jemalloc的CMakeLists.txt文件中实际上没有写install部分(被注释掉)，所以指定安装目录是无效的。 还可以直接执行CMake_configure.cmd来生成VS工程。
如果没有问题，将在build目录下生成VS工程文件。 执行下面命令进行编译(这里将只编译Release版本)
Z:\jemalloc\jemalloc-cmake\build&amp;gt;msbuild /p:configuration=Release /maxcpucount:8 ALL_BUILD.vcxproj  生成的目标文件在build/Release目录下。
也可以使用CygWin来生成Makefile文件，相关介绍在ReadMe.txt文件中有写。
MinGW下编译jemalloc 打开mingw命令行工具(或者msys2/cygwin等)进入源码目录，新建目录build-mingw并进入。 运行下面命令生成Makefile文件
cmake -G&amp;quot;MSYS Makefiles&amp;quot; -DCMAKE_SYSTEM_NAME=Windows ..  生成过程中遇到以下错误 错误1
-- CMAKE_C_COMPILER_ID: GNU CMake Error at Utilities.cmake:778 (CHECK_C_COMPILER_FLAG): Unknown CMake command &amp;quot;CHECK_C_COMPILER_FLAG&amp;quot;.</description>
    </item>
    
    <item>
      <title>简单的BSON OID生成实现</title>
      <link>http://sotex.github.io/post/2017-06-26-%E7%AE%80%E5%8D%95%E7%9A%84bson-oid%E7%94%9F%E6%88%90%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-06-26-%E7%AE%80%E5%8D%95%E7%9A%84bson-oid%E7%94%9F%E6%88%90%E5%AE%9E%E7%8E%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/06/26/7079752.html 简单的OID生成测试实现，只是简单的用用，切勿用于生产环境。
/* 应该使用大端序的，这里没有做转换 * ObjectId是12-byte BSON类型,其结构为: * * 4-byte 值为Unix时间戳, * 3-byte 主机标识, * 2-byte 进程ID * 3-byte 计数值 */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;time.h&amp;gt; #ifdef _WIN32 #include &amp;lt;process.h&amp;gt; #include &amp;lt;Windows.h&amp;gt; #else #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/utsname.h&amp;gt; #endif /* 全局的主机标识(这个值可采用主机名散列得到) */ static unsigned char host[4] = {0,0,0,0}; /* 全局计数器(进程一个，要避免访问冲突,当前没有考虑) */ static int counter = 0; /* 进程ID值 */ static unsigned short pid = 0; // 简单的将主机名进行散列 void hashhostname(const char* hostname) { host[0] = 0x41; host[1] = 0xC6; host[2] = 0x4E; while(*hostname){ unsigned char v = *(hostname++); host[0] += v &amp;gt;&amp;gt; 2; host[1] += v &amp;gt;&amp;gt; 3; host[2] += v &amp;gt;&amp;gt; 4; } } void create_oid() { time_t t = time(NULL); unsigned char oid[12]; *((int*)oid) = (int)t; oid[4] = host[0]; oid[5] = host[1]; oid[6] = host[2]; oid[7] = pid; oid[8] = pid &amp;gt;&amp;gt; 8; oid[9] = counter; oid[10] = counter &amp;gt;&amp;gt; 8; oid[11] = counter &amp;gt;&amp;gt; 16; // 输出 ++counter; counter &amp;amp;= 0xffffff; int i=0; while(i&amp;lt;12){ printf(&amp;quot;%02X&amp;quot;,oid[i++]); } putchar(&#39;\n&#39;); } int main() { // 1、初始化主机标识和进程ID #ifdef _WIN32 char buffer[512]; DWORD buflen = 512; GetComputerNameA((LPSTR)buffer,&amp;amp;buflen); buffer[511] = &#39;\0&#39;; puts(buffer); hashhostname(buffer); pid = (unsigned short)_getpid(); #else struct utsname utn; if(uname(&amp;amp;utn) &amp;lt; 0 ){ perror(&amp;quot;uname&amp;quot;); return 0; }else{ printf(&amp;quot; sysname:%s\n nodename:%s\n release:%s\n version:%s\n machine:%s\n \n&amp;quot;, utn.</description>
    </item>
    
    <item>
      <title>Qt5.9静态库编译VS2015-x64</title>
      <link>http://sotex.github.io/post/2017-06-13-qt5.9%E9%9D%99%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91vs2015-x64/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-06-13-qt5.9%E9%9D%99%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91vs2015-x64/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/06/13/7004433.html 不多说。 编译配置参数如下
configure.bat -static -no-openssl -release  不支持OpenSSL，也没有安装各个数据库的Driver，所以数据库方面也只支持了SQLite。
下载地址如下 全部文件下载 链接: http://pan.baidu.com/s/1bp1rdCF 密码: dsve 头文件和库文件下载 链接: http://pan.baidu.com/s/1c2ep95m
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;2017年9月5日23:55:51 补充&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- 感谢 @蓝天白云-QT 提出的疑惑，这里简单的说一下。 在编译的静态库使用的是/MD链接，所以/MT参数的不能编过。 链接的时候可能会提示很多符号找不到，这个原因是静态库很多符号都是依赖于外部，具体可看各个lib文件同名的pri文件，将相应的库添加到工程中即可。
这里以一个Qt自带的计算器示例代码做了个简单的VS工程，测试可用。
https://files.cnblogs.com/files/oloroso/calculator.7z
然后还有就是编译出的结果运行的时候可能会出现
This application failed to start because it could not find or load the Qt platform plugin &amp;quot;windows&amp;quot; in &amp;quot;&amp;quot;. Reinstalling the application may fix this problem.  的问题，这个是因为找不到插件目录的原因，这个问题解决也很简单，将plugins/platforms目录整个拷贝到生成的exe文件目录。 同时在main函数中添加QCoreApplication::addLibraryPath(&amp;quot;./&amp;quot;);语句。 具体的可以看 https://stackoverflow.com/questions/21268558/application-failed-to-start-because-it-could-not-find-or-load-the-qt-platform-pl</description>
    </item>
    
    <item>
      <title>mingw 构建 mysql-connector-c-6.1.9记录</title>
      <link>http://sotex.github.io/post/2017-05-17-mingw-%E6%9E%84%E5%BB%BA-mysql-connector-c-6.1.9%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-17-mingw-%E6%9E%84%E5%BB%BA-mysql-connector-c-6.1.9%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/17/6867162.html
1、准备工作 首先需要下载mysql-connector-c-6.1.9的源码，然后解压。 然后需要准备编译环境，这里我使用的是msys2(下载地址http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20161025.exe)。 下载安装后执行下面命令：
# 先更新一下（这一步后面可能会报错，只需要关闭终端，再打开重新更新一下即可） pacman -Syu # 安装编译需要工具 pacman -S gcc make cmake # 下面这句也可以不要 # pacman -S mingw-w64-x86_64-extra-cmake-modules # 再安装一个vim，这个不是必须的 pacman -S vim  全部安装完成之后，即可进入下一步
2、生成makefile 进入解压后的源码目录 执行下面的命令生成`Makefile文件
# 先创建并进入一个构建目录 mkdir build &amp;amp;&amp;amp; cd build # 生成makefile cmake -G&amp;quot;Unix Makefiles&amp;quot; ..  执行过程中报下面的错误
$ cmake -G&amp;quot;Unix Makefiles&amp;quot; .. -- Running cmake version 3.6.2 System is unknown to cmake, create: Platform/MINGW64_NT-6.2 to use this system, please send your config file to cmake@www.</description>
    </item>
    
    <item>
      <title>fnmatch源码阅读</title>
      <link>http://sotex.github.io/post/2017-05-16-fnmatch%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-16-fnmatch%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/16/6861576.html 源码下载地址如下：
http://web.mit.edu/freebsd/csup/fnmatch.h http://web.mit.edu/freebsd/csup/fnmatch.c
代码整体不错，但是中有一些地方稍有不足。我没有去改（添加了一些{}，以便结构清晰）。
/* * Copyright (c) 1989, 1993, 1994 *	The Regents of the University of California. All rights reserved. * * This code is derived from software contributed to Berkeley by * Guido van Rossum. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * 1. Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</description>
    </item>
    
    <item>
      <title>无法启动此程序，因为计算机中丢失 api-ms-win-crt-stdio-l1-1-0.dll 解决</title>
      <link>http://sotex.github.io/post/2017-05-12-%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E6%AD%A4%E7%A8%8B%E5%BA%8F%E5%9B%A0%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%B8%A2%E5%A4%B1-api-ms-win-crt-stdio-l1-1-0.dll-%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-12-%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E6%AD%A4%E7%A8%8B%E5%BA%8F%E5%9B%A0%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%B8%A2%E5%A4%B1-api-ms-win-crt-stdio-l1-1-0.dll-%E8%A7%A3%E5%86%B3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/12/6846039.html
问题描述 最近用一台Windows Server 2012 R2系统的机器的时候碰到了这个问题。 因为在网上看了很多解决方案，都没有很好的解决。所以记录一下这个问题的解决。
之前使用VS2013编译出的程序，是没有这个问题的。这个问题仅仅出现在VS2015编译的程序上。
重新安装了一个 Windows server 2008 R2的虚拟机，然后安装了vc_redist.exe(VC2015x64版本)，运行程序是没有问题的。这个winserver2008的系统镜像是下载的微软原版的，所以这里猜测安装win server 2012的服务器安装的系统可能并不是完整的。
解决过程 通过在服务器上的C:\Windows\System32（64位系统System32下是64位dll，SysWOW64目录下是32位dll）下搜索也没有找到相关的dll文件。 根据网上的一些资料，解决的办法就是安装VC运行时库和KB2999226补丁。这个方法我尝试过了，但是没有效果。微软提供了WindowsUCRT.zip(Windows 10 通用 C 运行时 )下载，里面包含多个操作系统下的补丁。
既然上面的方法可能无法解决，那就先看看具体的依赖情况 使用VS2015自带dumpbin查看依赖
dumpbin /dependents uds_services.exe Microsoft (R) COFF/PE Dumper Version 14.00.24218.2 Copyright (C) Microsoft Corporation. All rights reserved. Dump of file uds_services.exe File Type: EXECUTABLE IMAGE Image has the following dependencies: uds_module_foundation.dll KERNEL32.dll MSVCP140.dll WS2_32.dll MSWSOCK.dll VCRUNTIME140.dll api-ms-win-crt-stdio-l1-1-0.dll api-ms-win-crt-heap-l1-1-0.dll api-ms-win-crt-convert-l1-1-0.dll api-ms-win-crt-runtime-l1-1-0.dll api-ms-win-crt-string-l1-1-0.dll api-ms-win-crt-environment-l1-1-0.dll api-ms-win-crt-math-l1-1-0.dll api-ms-win-crt-locale-l1-1-0.</description>
    </item>
    
    <item>
      <title>如何使用 MSBuild.exe 生成解决方案中的特定目标</title>
      <link>http://sotex.github.io/post/2017-05-10-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-msbuild.exe-%E7%94%9F%E6%88%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E7%9B%AE%E6%A0%87/</link>
      <pubDate>Wed, 10 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-10-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-msbuild.exe-%E7%94%9F%E6%88%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E7%9B%AE%E6%A0%87/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/10/6837099.html 以前都是直接使用VS或者msbuild生成整个解决方案，或者只构建单个工程。 这回使用msbuild构建单个工程的时候出现了问题，因为工程中使用了SolutionDir这个宏来定位第三方库路径。 对于这个文件，微软已经给出了解决方案。
解决 如何：使用 MSBuild.exe 生成解决方案中的特定目标
您可以使用MSBuild.exe生成解决方案中的特定项目的特定目标。 若要生成解决方案中的特定项目的特定目标
 在命令行中，键入MSBuild.exe &amp;lt;SolutionName&amp;gt;.sln, ，其中&amp;lt;SolutionName&amp;gt;对应于包含您想要执行的目标的解决方案的文件名称。 在后使用/t参数指定构建目标名/t:TargetName。  示例
下面的示例执行对NotInSlnFolder项目的Rebuild操作，然后再执行对NewFolder目录下的InSolutionFolder项目的Clean操作。
msbuild SlnFolders.sln /t:NotInSlnfolder:Rebuild;NewFolder\InSolutionFolder:Clean  上面把rebuild clean等操作在英文版中都是target，这个和makefile中的依赖 目标 动作概念是一样的。rebuild clean等都是目标。</description>
    </item>
    
    <item>
      <title>MBTiles 1.2 规范翻译</title>
      <link>http://sotex.github.io/post/2017-05-04-mbtiles-1.2-%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-04-mbtiles-1.2-%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/04/6806323.html
MBTiles 1.2 可以参考超图的文档MBTiles扩展 具体实现可以参考浅谈利用SQLite存储离散瓦片的思路和实现方法
mapbox提供了一个简单实现测试代码，github地址在这里https://github.com/mapbox/mbtiler.git
子标签:  Interaction: 实现交互所需的HTTP端点 UTFGrid:此规范依赖于UTFGrid 1.2进行交互.  抽象 MBTiles是在SQLite数据库中存储地图瓦片数据的规范，用于即时使用和传送. MBTiles文件称为tilesets(瓦片集)，必须实现以下规范，以确保与设备的兼容性。
数据库规格 Tilesets使用version 3.0.0或更高版本的SQLite数据库。 仅使用SQLite核心功能; tilesets 无需扩展.
MBTiles数据库可以选用官方分配幻数(magic number)去快速识别为MBTiles。
数据库 注意: 所概述的schemas尽量遵循接口。产生兼容结果的SQLite视图同样有效。 方便起见，本规范将表(tables)和虚拟表(virtual tables，视图views)都当做表(tables)。
Metadata 元数据 Schema 方案 数据库需要包含名为metadata的table或view。
该表必须具有名为name和value的两列。metadata表典型创建语句如下:
CREATE TABLE metadata (name text, value text);  Content 内容 metadata表用作key/value存储，用于保存一些配置settings。
以下五个key是必须的:
 name: tileset的纯英文名称. type: overlay(覆盖型)或baselayer(基本图层型). version: tileset的版本,纯数字. description: 描述图层(layer)的文本. format: 瓦片数据的图像文件格式: png或jpg  row在metadata中是推荐提供的,如有，可以提高性能。
 bounds: 呈现的地图区域的最大范围。Bounds必须定义所有缩放级别所覆盖的区域。范围bounds以WGS:84中经纬度值表示，在OpenLayers Bounds格式表示为- 左,下,右,上.全球范围为例: -180.0,-85,180,85.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; UTF8和UTF16互转代码</title>
      <link>http://sotex.github.io/post/2017-05-03-c&#43;&#43;-utf8%E5%92%8Cutf16%E4%BA%92%E8%BD%AC%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 03 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-05-03-c&#43;&#43;-utf8%E5%92%8Cutf16%E4%BA%92%E8%BD%AC%E4%BB%A3%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/05/03/6801076.html
简介 1、这段代码只考虑在小端序情况下的转换（一般的机器都是的）。 2、这段代码需要C++11的支持(只是用到了u16string)，如果不支持，可以添加下面代码
typedef uint16_t char16_t; typedef std::basic_string&amp;lt;char16_t&amp;gt;  utfconvert.h #ifndef __UTFCONVERT_H__ #define __UTFCONVERT_H__ #include &amp;lt;string&amp;gt; // 从UTF16编码字符串构建，需要带BOM标记 std::string utf16_to_utf8(const std::u16string&amp;amp; u16str); // 从UTF16 LE编码的字符串创建 std::string utf16le_to_utf8(const std::u16string&amp;amp; u16str); // 从UTF16BE编码字符串创建 std::string utf16be_to_utf8(const std::u16string&amp;amp; u16str); // 获取转换为UTF-16 LE编码的字符串 std::u16string utf8_to_utf16le(const std::string&amp;amp; u8str, bool addbom = false, bool* ok = NULL); // 获取转换为UTF-16 BE的字符串 std::u16string utf8_to_utf16be(const std::string&amp;amp; u8str, bool addbom = false, bool* ok = NULL); #endif //!</description>
    </item>
    
    <item>
      <title>Qt Installer Framework 使用说明（一）</title>
      <link>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%80/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%80/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2017/04/27/6775220.html
Qt Installer Framework 使用说明 这份教程是去年翻译的，有很多不准确或不正确的地方，请别介意。
原文链接 http://doc.qt.io/qtinstallerframework/index.html
以下offline翻译为离线，online翻译为联机。widgets翻译为小部件。
版本 2.0.3
The Qt Installer Framework提供了一套工具和实用程序用于创建桌面Qt安装程序。支持的平台有: Linux, Microsoft Windows, 和 OS X.
注意: 对于Qt Installer Framework中遇到的bug和错误可以通过Qt Bugtracker(Qt错误追踪)进行反馈。
1、Qt Installer Framework概述 Qt安装程序框架提供了一组工具和实用程序，只需创建安装程序一次，无需改动源码，即可将它们部署在所有支持桌面QT的平台。 安装程序将在运行它们的平台上具有原生外观和感觉，支持：Linux，Microsoft Windows和OS X.
Qt安装程序框架工具生成安装程序，其中包含一组在安装，更新或卸载过程中指导用户的页面。 您提供可安装的内容并指定有关它的信息，例如产品和安装程序的名称以及许可协议的文本。
您可以通过向预定义的页面添加窗口小部件或添加整个页面来为用户提供其他选项来自定义安装程序。 您可以创建脚本以向安装程序添加操作。
选择安装包类型 你可以为最终用户提供一个离线(offline)或联机(online)安装包，或者同时支持。具体取决于您的使用情况。 两个安装程序都安装了一个维护工具(maintenance tool)，以后可用于添加，更新和删除组件。 离线安装程序包含所有可安装的组件，并且在安装期间 不需要网络连接 。 联机安装程序仅安装维护工具，然后从Web服务器上的联机存储库下载和安装组件。 因此，在线安装程序二进制文件的大小较小，其下载时间比离线安装程序二进制文件的大。 如果最终用户没有安装所有可用的组件，则下载和运行联机安装程序所花费的总时间也可能短于下载和运行离线安装程序。
最终用户可以在初次安装后使用维护工具从 服务器安装其他组件 ，以及在服务器上发布更新后立即接收内容的自动更新。 但是，只有在离线安装程序配置中指定存储库地址或最终用户在维护工具设置中指定存储库地址时，这才适用于离线安装。
创建离线安装程序以便用户可以直接下载安装软件包在介质上，稍后在计算机上进行安装。 例如，您还可以将安装软件包分发到CD-ROM或USB盘。 创建联机安装程序以使用户始终安装最新版本的内容二进制文件。
促进更新 使在线存储库可用于向安装产品的最终用户推广更新。 提供更新的最简单方法是重新创建存储库并将其上传到Web服务器。 对于大型存储库，只能更新已更改的组件。
提供安装内容 您可以启用其他内容提供程序将组件作为附加组件添加到安装程序。 组件提供程序必须设置包含可安装组件的存储库，并将指向存储库的URL提供给最终用户。 最终用户必须在安装程序中配置URL。 该附加组件在包管理器中可见。
2、入门指南 Qt安装程序框架是作为Qt项目的一部分开发的。 框架本身使用Qt。 但是，它可以用于创建安装所有类型应用程序的安装程序，包括（但不限于）使用Qt构建的应用程序。</description>
    </item>
    
    <item>
      <title>Qt Installer Framework 使用说明（三）</title>
      <link>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%89/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%89/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2017/04/27/6775318.html
6、Qt Installer Framework 示例 这些示例说明如何使用组件脚本来定制安装程序。
   示例 说明     更改安装程序UI示例 Change Installer UI Example 使用组件脚本修改安装程序UI   组件错误示例 Component Error Example 如果无法安装组件，请使用组件脚本停止安装   依赖性解决示例 Dependency Solving Example 使用组件的package.xml文件来定义组件之间的依赖性和自动依赖性   动态页面安装程序示例 Dynamic Page Installer Example 使用组件脚本和动态页来构建安装程序   修改提取安装程序示例 Modify Extract Installer Example 在组件脚本中使用归档提取钩子来修改目标路径   在线安装程序示例 Online Installer Example 使用repogen工具和配置文件设置在线安装程序   打开ReadMe示例 Open ReadMe Example 使用组件脚本添加用于打开自述文件到最终安装程序页面的复选框   退出安装程序示例 Quit Installer Example 使用组件脚本退出安装程序   注册文件扩展示例 Register File Extension Example 使用组件脚本在Windows上注册文件扩展名   开始菜单快捷方式示例 Start Menu Shortcut Example 使用组件脚本将条目添加到Windows“开始”菜单   系统信息示例 System Information Example 在组件脚本中使用systemInfo API来检查操作系统版本和位数   翻译示例 Translation Example 使用翻译本地化安装程序页面和许可证    7、参考 Reference 以下部分包含有关Qt Installer Framework的详细信息：</description>
    </item>
    
    <item>
      <title>Qt Installer Framework 使用说明（二）</title>
      <link>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%BA%8C/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-27-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%BA%8C/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2017/04/27/6775243.html
4、教程: 创建一个安装程序 本教程介绍如何为小项目创建简单的安装程序：
本节介绍以下创建安装程序 必须 完成的任务：
 创建一个包(package)目录，其中将包含所有配置文件和可安装的包。 创建包含有关如何构建安装程序二进制文件和联机存储库的信息的配置文件。 创建包信息文件，其中包含有关可安装组件的信息。 创建安装程序内容并将其复制到软件包(package)目录中。 使用binarycreator工具创建安装程序。
安装程序页面是使用您在配置和程序包信息文件中提供的信息创建的。  示例文件位于Qt Installer Framework资源库中的examples\tutorial目录中。
创建软件包目录 创建一个反映安装程序设计的目录结构，并允许将来扩展安装程序。 该目录必须包含config和packages的子目录。
有关软件包目录的详细信息，请参阅Package Directory。
创建配置文件 在config目录中，创建一个名为config.xml的文件，其中包含以下内容：
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;Installer&amp;gt; &amp;lt;Name&amp;gt;Your application&amp;lt;/Name&amp;gt; &amp;lt;Version&amp;gt;1.0.0&amp;lt;/Version&amp;gt; &amp;lt;Title&amp;gt;Your application Installer&amp;lt;/Title&amp;gt; &amp;lt;Publisher&amp;gt;Your vendor&amp;lt;/Publisher&amp;gt; &amp;lt;StartMenuDir&amp;gt;Super App&amp;lt;/StartMenuDir&amp;gt; &amp;lt;TargetDir&amp;gt;@HomeDir@/InstallationDirectory&amp;lt;/TargetDir&amp;gt; &amp;lt;/Installer&amp;gt;  该配置文件指定介绍页面上显示以下信息：
&amp;lt;Title元素指定显示在标题栏 (下图[1]) 上的安装程序名称。 &amp;lt;Name元素指定添加到页面名称和简介文本 (下图[2]) 的应用程序名称。
其他元素用于自定义安装程序的行为：
 &amp;lt;Version&amp;gt;元素指定应用程序版本号。 &amp;lt;Publisher&amp;gt;元素指定软件的发布者（例如，在Windows控制面板中所示）。 &amp;lt;StartMenuDir&amp;gt;元素指定Windows开始菜单中产品的默认程序组的名称。 &amp;lt;TargetDir&amp;gt;元素指定显示给用户的默认目标目录是当前用户的主目录中的InstallationDirectory（因为预定义变量@HomeDir@用作值的一部分）。 有关详细信息，请参阅预定义变量。  有关配置文件格式和可用元素的详细信息，请参阅Configuration File。
创建程序包信息文件 在这种简单的情况下，安装程序只处理一个名为com.vendor.product的组件。 要向安装程序提供有关组件的信息，请创建一个名为package.xml的文件，其中包含以下内容，并将其放在meta目录中：
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;Package&amp;gt; &amp;lt;DisplayName&amp;gt;The root component&amp;lt;/DisplayName&amp;gt; &amp;lt;Description&amp;gt;Install this example.</description>
    </item>
    
    <item>
      <title>mingw 构建 Geos</title>
      <link>http://sotex.github.io/post/2017-04-25-mingw-%E6%9E%84%E5%BB%BA-geos/</link>
      <pubDate>Tue, 25 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-25-mingw-%E6%9E%84%E5%BB%BA-geos/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/04/25/6762624.html
简述 在做某个小程序时候用到了QT，而用的Qt是mingw版本的，所以使用mingw构建了一下geos库。
1、准备工作 首先需要先安装好mingw,这里直接使用http://www.mingw-w64.org里面下载的安装器。 下载之后进行安装，根据你的需求，可以选择64位版本或者32位版本。
如果是安装的mingw32版本的Qt，使用其自带的mingw编译套件也是可以的。
安装了之后还需要安装cmake这里就不介绍了。 安装之后进入mingw的安装目录下的bin目录，将其中的mingw32-make.exe拷贝一份，并改名为make.exe。
然后就是下载geos的源码了，直接点击下载http://download.osgeo.org/geos/geos-3.6.1.tar.bz2
下载之后解压。
2、生成Makefile 双击打开mingw安装目录下的mingw-w64.bat，然后进入geos源码目录，新建并进入目录build_mingw。 执行下面语句生成Makefile文件
cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=Z:/geos_mingw ..  上面使用了-DCMAKE_BUILD_TYPE=Release指定构建Release版本，如果不指定，则构建debug版本。
 实际上我是在安装的Git自带的MINGW64命令行工具(Git Bash实际上是msys，你也可以自己下载msys安装)下使用的，使用前先使用下面命令将mingw安装路径添加到PATH环境变量中。
export PATH=$PATH:/C/Program\ Files/mingw-w64/x86_64-5.4.0-win32-seh-rt_v5-rev0/mingw64/bin/  生成Makefile的命令是(只是路径风格不一样)
cmake -G &amp;quot;MinGW Makefiles&amp;quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/Z/geos_mingw ..  其余步骤是一致的。
 生成Makefile后还需要做点工作，就是将build_mingw\include\geos\目录下的platform.h和version.h文件拷贝到源码目录下的include\geos目录。
注意，上面应该是正常的做法，但是会有错误，就是error: &#39;isnan&#39; was not declared in this scope 对于这个错误，只需要将源码目录下的include\geos中platform.h.in重命名为platform.h即可（不使用cmake生成的）。
3、编译 生成Makefile之后，使用下面命令进行编译
# 编译 mingw32-make -f Makefile # 安装 mingw32-make -f Makefile install  我编译的64位版本下载地址在这里https://www.justbeamit.com/zup5i</description>
    </item>
    
    <item>
      <title>nmake构建Geos库</title>
      <link>http://sotex.github.io/post/2017-04-18-nmake%E6%9E%84%E5%BB%BAgeos%E5%BA%93/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-18-nmake%E6%9E%84%E5%BB%BAgeos%E5%BA%93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/04/18/6728506.html
1、下载源码包 下载地址 http://download.osgeo.org/geos/geos-3.6.1.tar.bz2 下载之后解压即可。
2、编译 geos源码包中自带了makefile.vc，所以可以直接使用nmake进行构建。 打开VS的命令行工具（我的是VS2015 x64 Native Build Tools Command Prompt） 进入源码目录，使用下面命令进行构建（构建前请先运行一下autogen.bat，也可手动将include目录下的version.h.vc和platform.h.vc，去掉.vc后缀名）
nmake -f makefile.vc BUILD_DEBUG=YES WIN64=YES ENABLE_INLINE=YES # 以下参数也可以在nmake.opt中修改 # BUILD_DEBUG=YES 构建Debug版本，构建Release版本改为NO（默认就是） # WIN64=YES 构建Win64版本 # ENABLE_INLINE=YES 开启内联（默认为NO）  geos的makefile.vc中是没有带install目标的，所以构建完成之后需要手动去拷贝相关的文件。 编译出的lib和dll文件在源码包的src目录下，头文件在include目录下。
编译出的geos.lib是静态库，geos_i.lib和geos_c_i.lib则是动态库接口导出文件。</description>
    </item>
    
    <item>
      <title>使用Dlib来运行基于CNN的人脸检测</title>
      <link>http://sotex.github.io/post/2017-04-13-%E4%BD%BF%E7%94%A8dlib%E6%9D%A5%E8%BF%90%E8%A1%8C%E5%9F%BA%E4%BA%8Ecnn%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-04-13-%E4%BD%BF%E7%94%A8dlib%E6%9D%A5%E8%BF%90%E8%A1%8C%E5%9F%BA%E4%BA%8Ecnn%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/04/13/6703711.html 检测结果如下 这个示例程序需要使用较大的内存，请保证内存足够。本程序运行速度比较慢，远不及OpenCV中的人脸检测。
注释中提到的几个文件下载地址如下 http://dlib.net/face_detection_ex.cpp.html http://dlib.net/dnn_introduction_ex.cpp.html http://dlib.net/dnn_introduction2_ex.cpp.html http://dlib.net/dnn_mmod_ex.cpp.html
/* 这个示例程序展示如何使用Dlib来运行基于CNN的人脸检测。示例程序加载现有训练模型数据，并使用它在图像中查找人脸。CNN模型在运行时比基于HOG模型的检测要精确很多，然而，只有在GPU上执行才能达到较快的速度。例如，在NVIDIA Titan X GPU上，此程序与face_detection_ex.cpp处理图像的速度相同。 另外，刚刚学习dlib深度学习API的用户应该阅读dnn_introduction_ex.cpp和dnn_introduction2_ex.cpp示例，来了解API的工作原理。有关对象检测方法的介绍，您应该阅读dnn_mmod_ex.cpp 训练模型 TRAINING THE MODEL 最后，有兴趣对面部检测器进行训练的用户，可以阅读dnn_mmod_ex.cpp示例程序。 应该注意的是，本示例程序中使用的面部检测器比dnn_mmod_ex.cpp中展示的具有更 大的训练数据集和更大的CNN架构，但是其他训练条件是相同的。如果和dnn_mmod_ex.cpp 代码中的net_type比较，可以看到它们非常相似，只是增加了参数的数量。 另外，训练中以下训练参数有所不同： dnn_mmod_ex.cpp中有以下更改 mmod_options options(face_boxes_train,40*40) trainer.set_iterations_without_progress_threshold(300); 在以下示例中使用训练数据中使用参数为: mmod_options options(face_boxes_train, 80*80); trainer.set_iterations_without_progress_threshold(8000); 此外，random_cropper保持默认设置，所以我们没有调用以下函数: cropper.set_chip_dims(200, 200); cropper.set_min_object_height(0.2); 用于训练的数据也可在下面地址中找到 http://dlib.net/files/data/dlib_face_detection_dataset-2016-09-30.tar.gz */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;dlib/dnn.h&amp;gt; #include &amp;lt;dlib/data_io.h&amp;gt; #include &amp;lt;dlib/image_processing.h&amp;gt; #include &amp;lt;dlib/gui_widgets.h&amp;gt; using namespace std; using namespace dlib; // ---------------------------------------------------------------------------------------- template &amp;lt;long num_filters, typename SUBNET&amp;gt; using con5d = con&amp;lt;num_filters,5,5,2,2,SUBNET&amp;gt;; template &amp;lt;long num_filters, typename SUBNET&amp;gt; using con5 = con&amp;lt;num_filters,5,5,1,1,SUBNET&amp;gt;; template &amp;lt;typename SUBNET&amp;gt; using downsampler = relu&amp;lt;affine&amp;lt;con5d&amp;lt;32, relu&amp;lt;affine&amp;lt;con5d&amp;lt;32, relu&amp;lt;affine&amp;lt;con5d&amp;lt;16,SUBNET&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;; template &amp;lt;typename SUBNET&amp;gt; using rcon5 = relu&amp;lt;affine&amp;lt;con5&amp;lt;45,SUBNET&amp;gt;&amp;gt;&amp;gt;; using net_type = loss_mmod&amp;lt;con&amp;lt;1,9,9,1,1,rcon5&amp;lt;rcon5&amp;lt;rcon5&amp;lt;downsampler&amp;lt;input_rgb_image_pyramid&amp;lt;pyramid_down&amp;lt;6&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;; // ---------------------------------------------------------------------------------------- int main(int argc, char** argv) try { argc = 3; char* v[] = { &amp;quot;test&amp;quot;, &amp;quot;D:\\Picture\\mmod_human_face_detector.</description>
    </item>
    
    <item>
      <title>DLib Http Server程序示例</title>
      <link>http://sotex.github.io/post/2017-03-27-dlib-http-server%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-27-dlib-http-server%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/27/6627003.html
/* 这个示例是一个使用了Dlib C++ 库的server组件的HTTP扩展 它创建一个始终以简单的HTML表单为响应的服务器。 要查看这个页面，你应该访问 http://localhost:5000 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;dlib/server.h&amp;gt; using namespace dlib; using namespace std; class web_server : public server_http { const std::string on_request ( const incoming_things&amp;amp; incoming, outgoing_things&amp;amp; outgoing ) { ostringstream sout; // 我们将发回一个包含HTML表单的页面，其中包含两个文本输入字段。一个字段是name(还有一个是pass) // HTML表单使用post方法，也可以使用get方法(只需将method=&#39;post&#39;改为method=&#39;get&#39;). sout &amp;lt;&amp;lt;&amp;quot; &amp;lt;html&amp;gt;&amp;lt;meta charset=\&amp;quot;utf-8\&amp;quot;&amp;gt;&amp;lt;body&amp;gt; &amp;quot; &amp;lt;&amp;lt; &amp;quot;&amp;lt;form action=&#39;http://sotex.github.io/form_handler&#39; method=&#39;post&#39;&amp;gt; &amp;quot; &amp;lt;&amp;lt; &amp;quot;用户名称: &amp;lt;input name=&#39;user&#39; type=&#39;text&#39;&amp;gt;&amp;lt;br&amp;gt; &amp;quot; &amp;lt;&amp;lt; &amp;quot;用户密码: &amp;lt;input name=&#39;pass&#39; type=&#39;text&#39;&amp;gt; &amp;lt;input type=&#39;submit&#39;&amp;gt; &amp;quot; &amp;lt;&amp;lt; &amp;quot; &amp;lt;/form&amp;gt;&amp;quot;; // 回写这个请求传入的一些信息，以便它们显示在生成的网页上 sout &amp;lt;&amp;lt; &amp;quot;&amp;lt;br&amp;gt; path = &amp;quot; &amp;lt;&amp;lt; incoming.</description>
    </item>
    
    <item>
      <title>DLib压缩解压程序示例</title>
      <link>http://sotex.github.io/post/2017-03-27-dlib%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-27-dlib%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/27/6626648.html
/* 这是一个示例程序，使用了Dlib库的compress_stream和cmd_line_parser组件。 这个示例实现了一个简单实用的命令行压缩程序。 当使用-h选项时候，程序输出如下: 使用: compress_stream_ex (-c|-d|-l) --in input_file --out output_file 选项: -c 表示要执行压缩文件操作. -d 表示要执行解压文件操作. --in &amp;lt;arg&amp;gt; 此选项带一个参数，指定要压缩或解压的文件名称. --out &amp;lt;arg&amp;gt; 此选项带一个参数，指定输出文件名称. 其他选项: -h 显示帮助信息. -l &amp;lt;arg&amp;gt; 设置压缩级别[1-3], 3是最大压缩,默认值是2. */ #include &amp;lt;dlib/compress_stream.h&amp;gt; #include &amp;lt;dlib/cmd_line_parser.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;string&amp;gt; // 为要使用的compress_stream版本做一个typedef定义 typedef dlib::compress_stream::kernel_1da cs1; typedef dlib::compress_stream::kernel_1ea cs2; typedef dlib::compress_stream::kernel_1ec cs3; using namespace std; using namespace dlib; int main(int argc, char** argv) { try { command_line_parser parser; // 首先，定义需要的命令行参数 // 添加 -c 选项，并给出描述信息 parser.</description>
    </item>
    
    <item>
      <title>GDAL添加ECW格式支持</title>
      <link>http://sotex.github.io/post/2017-03-27-gdal%E6%B7%BB%E5%8A%A0ecw%E6%A0%BC%E5%BC%8F%E6%94%AF%E6%8C%81/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-27-gdal%E6%B7%BB%E5%8A%A0ecw%E6%A0%BC%E5%BC%8F%E6%94%AF%E6%8C%81/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2017/03/27/6625669.html
GDAL添加ECW格式支持 本文翻译自 http://trac.osgeo.org/gdal/wiki/ECW，有少量的修改及补充。
ECW 这个驱动程序的最终用户文档:​http://www.gdal.org/frmt_ecw.html
下载ECW JPEG SDK 为了让GDAL可以使用ECW格式，你需要从Hexagon Geospatial网站下载ERDAS ECW/JP2 SDK。 4.3或更高版本的只读SDK(不支持写ECW文件)需要在同意许可条款后免费下载。如果要通过ECW SDK写ECW或JPEG2000文件，必须从Hexagon Geospatial/ERDAS购买可写版本的SDK.
如果可以找到过期的libecwj 3.3 SDK，也可以使用它。它的许可信息有显著不同。下面的叙述和讨论基于3.3 SDK。
在Unix平台构建支持ECW的GDAL 假设您已经在默认位置(LIBRARY_PATH)安装了libecwj库，那么将ECW支持添加到GDAL的过程很简单。 只需要在生成编译GDAL的Makefile的configure命令中添加ecw库的安装路径：
$ cd /path/to/gdal $ ./configure --with-ecw=/usr/local $ make # make install  如果在构建中存在问题，可以查看gdal/frmts/ecw/GNUmakefile中的CPPFLAGS是否定义了-DPOSIX和-DLINUX。参考#3344
在完成上面步骤后，可以查看GDAL已安装支持格式列表，可以看到有ECW:
$ gdalinfo --formats|grep ECW ECW (rw): ERMapper Compressed Wavelets JP2ECW (rw+): ERMapper JPEG2000  注意:所有依赖GDAL的服务都应该重启。例如：Apache需要重新加载PHP MapScript。
二进制ECW SDK和GCC &amp;gt;= 5.1 由于GCC 5.1以后，GCC默认使用新的C++ ABI和libstdc++，它与ECW SDK二进制文件不兼容（至少当前如此）。解决的办法是使用CXXFLAGS=&amp;quot;-D_GLIBCXX_USE_CXX11_ABI=0&amp;quot;选项去构建GDAL。
./configure CXXFLAGS=&amp;quot;-D_GLIBCXX_USE_CXX11_ABI=0&amp;quot;  注意:如果你还使用别的使用新的C++ ABI的库（例如：likbml，podofo，poppler，cryptopp等，这通常来自发行版自带的），则这个方法无法正常使用。如果你必须使用这些库，你必须找到它们的源码，并使用CXXFLAGS=&amp;quot;-D_GLIBCXX_USE_CXX11_ABI=0&amp;quot;选项重新编译。
在Linux上构建的教程 ​http://trac.</description>
    </item>
    
    <item>
      <title>DLib库Base64编解码示例</title>
      <link>http://sotex.github.io/post/2017-03-23-dlib%E5%BA%93base64%E7%BC%96%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-23-dlib%E5%BA%93base64%E7%BC%96%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/23/6605288.html
代码 #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;dlib/compress_stream.h&amp;gt; #include &amp;lt;dlib/base64.h&amp;gt; using namespace dlib; int main(int argc, char** argv) { system(&amp;quot;title Base64 Encoder&amp;quot;); if (argc != 2) { std::cout &amp;lt;&amp;lt; &amp;quot;Usage: &amp;quot;&amp;lt;&amp;lt;argv[0]&amp;lt;&amp;lt;&amp;quot; filename&amp;quot; &amp;lt;&amp;lt; std::endl; return EXIT_FAILURE; } // 打开命令行指定的文件 std::ifstream fin(argv[1], std::ios::binary); if (!fin) { std::cout &amp;lt;&amp;lt; &amp;quot;can&#39;t open file &amp;quot; &amp;lt;&amp;lt; argv[1] &amp;lt;&amp;lt; std::endl; return EXIT_FAILURE; } std::ostringstream sout; std::istringstream sin; // base64编码器对象 base64 base64_coder; // 数据压缩流对象 compress_stream::kernel_1ea compressor; // 压缩文件的内容并将结果存储在字符串流sout compressor.</description>
    </item>
    
    <item>
      <title>Dlib机器学习指南图翻译</title>
      <link>http://sotex.github.io/post/2017-03-23-dlib%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%9B%BE%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-23-dlib%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E5%9B%BE%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/23/6607888.html 原图地址 http://dlib.net/ml_guide.svg 翻译的文件 http://files.cnblogs.com/files/oloroso/ml_guide.zip</description>
    </item>
    
    <item>
      <title>Dlib三维点云示例</title>
      <link>http://sotex.github.io/post/2017-03-21-dlib%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-21-dlib%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/21/6594804.html
Dlib三维点云示例 源代码来自Dlib的示例代码http://dlib.net/3d_point_cloud_ex.cpp.html 在windows下需要链接winmmcomctl32gdi32imm32user32等库。
下面的代码生成一个像是三维螺旋状的点云。
源码如下
#include &amp;lt;dlib/gui_widgets.h&amp;gt; #include &amp;lt;dlib/image_transforms.h&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace dlib; using namespace std; int main() { // 做一个看起来像一个3D螺旋的点云。 std::vector&amp;lt;perspective_window::overlay_dot&amp;gt; points; // 点云的点(透视窗口覆盖点类型) dlib::rand rnd; // 随机数产生器 for (double i = 0; i &amp;lt; 20; i+=0.001) { // 获取螺旋曲线上的一个点 dlib::vector&amp;lt;double&amp;gt; val(sin(i),cos(i),i/4); // 给这个点添加一些随机噪声 dlib::vector&amp;lt;double&amp;gt; temp(rnd.get_random_gaussian(), rnd.get_random_gaussian(), rnd.get_random_gaussian()); val += temp/20; // 沿着螺旋走，根据距离选择颜色 rgb_pixel color = colormap_jet(i,0,20); // 将点添加到待显示的点列表 points.push_back(perspective_window::overlay_dot(val, color)); } // 现在在窗口展示点云 perspective_window win; // 创建透视窗口 win.</description>
    </item>
    
    <item>
      <title>Mingw编译DLib</title>
      <link>http://sotex.github.io/post/2017-03-21-mingw%E7%BC%96%E8%AF%91dlib/</link>
      <pubDate>Tue, 21 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-21-mingw%E7%BC%96%E8%AF%91dlib/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/21/6593758.html
Mingw编译DLib 因为机器上安装了qt-opensource-windows-x86-mingw530-5.8.0，所以准备使用其自带的mingw530来编译DLib使用。 因为DLib使用CMake的构建脚本，所以还请先安装好CMake。 cmake的下载地址如下https://cmake.org/files/v3.7/cmake-3.7.2-win64-x64.msi 
编译出的文件在这里https://share.weiyun.com/1e6d7dc98bc8a9fa2922f99ee11dcdac
下载Dlib源码 可以直接去DLib的官网http://dlib.net/找到你想要版本进行下载。 这里给出DLib-19.4的下载链接http://dlib.net/files/dlib-19.4.zip 
或者直接从github克隆一个
git clone https://github.com/davisking/dlib.git  生成Makefile 使用Cmake来生成Makefile文件。 打开开始菜单里面的Qt 5.8下面的Qt 5.8 for Desktop (MinGW 5.3.0 32 bit)命令行工具，然后输入下面的命令生成Makefile文件。
如果你不是使用的Qt自带的mingw，那么也可以使用你自己下载安装的mingw。前提是需要先把mingw的bin目录路径添加到环境变量Path中。可以使用set Path=%Path%;mingw的bin路径来临时使用。
D:\dlib-19.4\build&amp;gt;cmake -DCMAKE_INSTALL_PREFIX=D:/libs/dlib -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ -DCMAKE_BUILD_TYPE=Release -DCMAKE_MAKE=mingw32-make ..  实际上上面的命令还有些不对，请看后面的说明。
使用上面命令之后出现了如下错误输出
-- The C compiler identification is GNU 5.3.0 -- The CXX compiler identification is GNU 5.3.0 -- Check for working C compiler: C:/Qt/Qt5.8.0/Tools/mingw530_32/bin/gcc.exe CMake Error: Generator: execution of make failed.</description>
    </item>
    
    <item>
      <title>使用gprof2dot和graphivz生成程序运行调用图</title>
      <link>http://sotex.github.io/post/2017-03-14-%E4%BD%BF%E7%94%A8gprof2dot%E5%92%8Cgraphivz%E7%94%9F%E6%88%90%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E5%9B%BE/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-03-14-%E4%BD%BF%E7%94%A8gprof2dot%E5%92%8Cgraphivz%E7%94%9F%E6%88%90%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E5%9B%BE/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/03/14/6548189.html
使用gprof2dot和graphivz生成程序运行调用图 gprof2dot是一个将gprof生成的输出转换为dot脚本的工具。通过给定一个gprof的输出文件，将其转换为生成程序调用图的dot脚本。dot脚本可以生成图像来进行查看。
1、下载gprof2dot工具 gprof2dot工具由JoséFronseca维护，并托管在Google代码（http://code.google.com/p/jrfonseca/w/list）,但是这个已经无法访问了。这里提供一个github的地址[https://github.com/jrfonseca/gprof2dot.git](https://github.com/jrfonseca/gprof2dot.git)。
git clone https://github.com/jrfonseca/gprof2dot.git  这个工具需要python环境的支持，请提前安装好python3。
2、使用gprof生成概要分析数据 2.1 gprof简介 Gprof 是GNU gnu binutils工具之一，默认情况下linux系统当中都带有这个工具。 - 1. 可以显示“flat profile”，包括每个函数的调用次数，每个函数消耗的处理器时间。 - 2. 可以显示“Call graph”，包括函数的调用关系，每个函数调用花费了多少时间。 - 3. 可以显示“注释的源代码”－－是程序源代码的一个副本，标记有程序中每行代码的执行次数。
2.2 使用gprof生成分析数据 1、在编译的时候使用-pg选项，可以写入makefile中。（链接时不需要）
# 普通程序编译 $ gcc -pg -g source.c -o binary # cuda程序编译 $ nvcc -Xcompiler“-g -pg”-g -pg -arch = sm_20 source.cu -o binary  2、执行编译出的程序。 执行方式与没有加pg选项前是一样的，执行后将在程序运行目录下生成gmon.out文件。这是一个二进制文件，需要进一步分析生成文本文件。如果已经存在了gmon.out文件，将会被覆盖。
./binary	# 必须先运行一遍生成gmon.out文件，后面才能使用gprof工具继续操作  3、用gprof工具生成概要分析数据文件。
$ gprof ./binary&amp;gt; gprof_output.txt  3、生成调用图 配置好gprof2dot运行环境后，就可以使用其来生成dot脚本。</description>
    </item>
    
    <item>
      <title>linux下编译Zero C ICE</title>
      <link>http://sotex.github.io/post/2017-02-27-linux%E4%B8%8B%E7%BC%96%E8%AF%91zero-c-ice/</link>
      <pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-27-linux%E4%B8%8B%E7%BC%96%E8%AF%91zero-c-ice/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/27/6473334.html
0、简介 ZeroC ICE 是指ZeroC公司(www.zeroc.com)的ICE（Internet Communications Engine）中间件平台。
目前ICE平台中包括Ice，Ice-E，Ice Touch。 Ice为主流平台设计，包括Windows和Linux，支持广泛的语言，包括C++，Java，C#（和其他.Net的语言，例如Visual Basic），Python，Ruby，PHP和ActionScript。也包括所有的ICE服务，例如Ice Grid，IceStorm等。 Ice-E是Ice在资源受限的平台上的一个实现，支持C++和嵌入式操作系统，例如Windows CE，Linux。Ice-E本身不包含任何服务，但是可以利用在Ice上提供的各种服务。因此，通过Ice-E，移动设备也能无缝的集成到分布式系统中。 Ice Touch是为iphone和ipod touch开发的版本，包括Object-C映射，支持Iphone OS，并为MAC OS X开发图形界面应用程序提供完整的Cocoa框架的访问。
本文由乌合之众瞎写，如有错漏之处,敬请指正。http://www.cnblogs.com/oloroso/
1、下载源码 git clone https://github.com/zeroc-ice/ice.git  2、编译和安装 先安装依赖项libmcpp、openssl、lmdb等。
sudo dnf install libmcpp-devel openssl-devel lmdb-devel # defora下安装 sudo apt install libmcpp-dev libssl-dev # debian系下安装  编译并安装
make -j4 # 编译(时间比较久，可以把Makefile中对test的编译注释掉) make prefix=/opt/zero-c-ice install  上面命令会编译所有支持语言的版本，如果不需要那么多，可以通过修改config/Make.rules来改变支持的语言。 打开config/Make.rules文件，跳到最后，修改supported-languages的值。 例如：
supported-languages ?= cpp python  或者在编译的时候直接指定语言。
make supported-languages=&#39;cpp python java js&#39; make supported-languages=&#39;cpp python java js&#39; prefix=/opt/zero-c-ice install  如果需要支持java语言，在编译的时候会去下载gradle工具，所以需要确保能够正常访问https://gradle.</description>
    </item>
    
    <item>
      <title>Qt Installer Framework 使用说明</title>
      <link>http://sotex.github.io/post/2017-02-24-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-24-qt-installer-framework-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/24/6437542.html
Qt Installer Framework 使用说明 翻译这个有一段时间了，大概是去年10月份开始的吧。英文比较差，翻译的不好。后面还有一部分没有翻译，暂时没有太多时间去做这个，就先留着吧。
我的邮箱:solym@sohu.com
原文链接 http://doc.qt.io/qtinstallerframework/index.html
以下offline翻译为离线，online翻译为联机。widgets翻译为小部件。
版本 2.0.3
The Qt Installer Framework提供了一套工具和实用程序用于创建桌面Qt安装程序。支持的平台有: Linux, Microsoft Windows, 和 OS X.
注意: 对于Qt Installer Framework中遇到的bug和错误可以通过Qt Bugtracker(Qt错误追踪)进行反馈。
1、Qt Installer Framework概述 Qt安装程序框架提供了一组工具和实用程序，只需创建安装程序一次，无需改动源码，即可将它们部署在所有支持桌面QT的平台。 安装程序将在运行它们的平台上具有原生外观和感觉，支持：Linux，Microsoft Windows和OS X.
Qt安装程序框架工具生成安装程序，其中包含一组在安装，更新或卸载过程中指导用户的页面。 您提供可安装的内容并指定有关它的信息，例如产品和安装程序的名称以及许可协议的文本。
您可以通过向预定义的页面添加窗口小部件或添加整个页面来为用户提供其他选项来自定义安装程序。 您可以创建脚本以向安装程序添加操作。
选择安装包类型 你可以为最终用户提供一个离线(offline)或联机(online)安装包，或者同时支持。具体取决于您的使用情况。 两个安装程序都安装了一个维护工具(maintenance tool)，以后可用于添加，更新和删除组件。 离线安装程序包含所有可安装的组件，并且在安装期间 不需要网络连接 。 联机安装程序仅安装维护工具，然后从Web服务器上的联机存储库下载和安装组件。 因此，在线安装程序二进制文件的大小较小，其下载时间比离线安装程序二进制文件的大。 如果最终用户没有安装所有可用的组件，则下载和运行联机安装程序所花费的总时间也可能短于下载和运行离线安装程序。
最终用户可以在初次安装后使用维护工具从 服务器安装其他组件 ，以及在服务器上发布更新后立即接收内容的自动更新。 但是，只有在离线安装程序配置中指定存储库地址或最终用户在维护工具设置中指定存储库地址时，这才适用于离线安装。
创建离线安装程序以便用户可以直接下载安装软件包在介质上，稍后在计算机上进行安装。 例如，您还可以将安装软件包分发到CD-ROM或USB盘。 创建联机安装程序以使用户始终安装最新版本的内容二进制文件。
促进更新 使在线存储库可用于向安装产品的最终用户推广更新。 提供更新的最简单方法是重新创建存储库并将其上传到Web服务器。 对于大型存储库，只能更新已更改的组件。
提供安装内容 您可以启用其他内容提供程序将组件作为附加组件添加到安装程序。 组件提供程序必须设置包含可安装组件的存储库，并将指向存储库的URL提供给最终用户。 最终用户必须在安装程序中配置URL。 该附加组件在包管理器中可见。
2、入门指南 Qt安装程序框架是作为Qt项目的一部分开发的。 框架本身使用Qt。 但是，它可以用于创建安装所有类型应用程序的安装程序，包括（但不限于）使用Qt构建的应用程序。</description>
    </item>
    
    <item>
      <title>Qt安装框架说明文档翻译</title>
      <link>http://sotex.github.io/post/2017-02-24-qt%E5%AE%89%E8%A3%85%E6%A1%86%E6%9E%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-24-qt%E5%AE%89%E8%A3%85%E6%A1%86%E6%9E%B6%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/24/6437581.html Qt Installer Framework 使用说明 翻译这个有一段时间了，大概是去年10月份开始的吧。英文比较差，翻译的不好。后面还有一部分没有翻译，暂时没有太多时间去做这个，就先留着吧。
我的邮箱:solym@sohu.com
原文链接 http://doc.qt.io/qtinstallerframework/index.html
以下offline翻译为离线，online翻译为联机。widgets翻译为小部件。
版本 2.0.3
The Qt Installer Framework提供了一套工具和实用程序用于创建桌面Qt安装程序。支持的平台有: Linux, Microsoft Windows, 和 OS X.
注意: 对于Qt Installer Framework中遇到的bug和错误可以通过Qt Bugtracker(Qt错误追踪)进行反馈。
1、Qt Installer Framework概述 Qt安装程序框架提供了一组工具和实用程序，只需创建安装程序一次，无需改动源码，即可将它们部署在所有支持桌面QT的平台。 安装程序将在运行它们的平台上具有原生外观和感觉，支持：Linux，Microsoft Windows和OS X.
Qt安装程序框架工具生成安装程序，其中包含一组在安装，更新或卸载过程中指导用户的页面。 您提供可安装的内容并指定有关它的信息，例如产品和安装程序的名称以及许可协议的文本。
您可以通过向预定义的页面添加窗口小部件或添加整个页面来为用户提供其他选项来自定义安装程序。 您可以创建脚本以向安装程序添加操作。
选择安装包类型 你可以为最终用户提供一个离线(offline)或联机(online)安装包，或者同时支持。具体取决于您的使用情况。

两个安装程序都安装了一个维护工具(maintenance tool)，以后可用于添加，更新和删除组件。 离线安装程序包含所有可安装的组件，并且在安装期间 不需要网络连接 。 联机安装程序仅安装维护工具，然后从Web服务器上的联机存储库下载和安装组件。 因此，在线安装程序二进制文件的大小较小，其下载时间比离线安装程序二进制文件的大。 如果最终用户没有安装所有可用的组件，则下载和运行联机安装程序所花费的总时间也可能短于下载和运行离线安装程序。
最终用户可以在初次安装后使用维护工具从 服务器安装其他组件 ，以及在服务器上发布更新后立即接收内容的自动更新。 但是，只有在离线安装程序配置中指定存储库地址或最终用户在维护工具设置中指定存储库地址时，这才适用于离线安装。
创建离线安装程序以便用户可以直接下载安装软件包在介质上，稍后在计算机上进行安装。 例如，您还可以将安装软件包分发到CD-ROM或USB盘。
创建联机安装程序以使用户始终安装最新版本的内容二进制文件。
促进更新 使在线存储库可用于向安装产品的最终用户推广更新。 提供更新的最简单方法是重新创建存储库并将其上传到Web服务器。 对于大型存储库，只能更新已更改的组件。
提供安装内容 您可以启用其他内容提供程序将组件作为附加组件添加到安装程序。 组件提供程序必须设置包含可安装组件的存储库，并将指向存储库的URL提供给最终用户。 最终用户必须在安装程序中配置URL。 该附加组件在包管理器中可见。
2、入门指南 Qt安装程序框架是作为Qt项目的一部分开发的。 框架本身使用Qt。 但是，它可以用于创建安装所有类型应用程序的安装程序，包括（但不限于）使用Qt构建的应用程序。</description>
    </item>
    
    <item>
      <title>linux下安装和卸载vmware产品</title>
      <link>http://sotex.github.io/post/2017-02-20-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BDvmware%E4%BA%A7%E5%93%81/</link>
      <pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-20-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BDvmware%E4%BA%A7%E5%93%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/20/6419899.html
1、安装 一般的发行版都不会带有vmware，所以通常是下载安装包来安装。 具体的可以见 http://www.cnblogs.com/oloroso/p/5845227.html
2、卸载 这里主要说的就是卸载，因为它不是通过包管理工具安装的，所以不能在包管理工具里面卸载。
2.1、先查看安装了vmware的哪些Product(产品)。 通过以下命令来查询
┌─(~)───────────────────────────────────----──────────(o@o-pc:pts/1)─┐ └─(15:38:48)──&amp;gt; vmware-installer -l 1 ↵ ──(一,2月20)─┘ Product Name Product Version ==================== ==================== vmware-player 12.5.2.4638234  我这里只安装了vmware-player，所以这里只有这一个。
2.2、卸载 查询到安装的产品之后，就可以卸载了。
sudo vmware-installer --uninstall-product vmware-player  因为我这里只安装了这一个产品，所以卸载之后vmware-installer工具也一起卸载了。</description>
    </item>
    
    <item>
      <title>VS2017自带VS2015编译器等在命令行下无法使用问题</title>
      <link>http://sotex.github.io/post/2017-02-16-vs2017%E8%87%AA%E5%B8%A6vs2015%E7%BC%96%E8%AF%91%E5%99%A8%E7%AD%89%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-16-vs2017%E8%87%AA%E5%B8%A6vs2015%E7%BC%96%E8%AF%91%E5%99%A8%E7%AD%89%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/16/6404475.html
1、起因 早前把VS2015卸了，安装了VS2017。因为VS2017安装的时候可以选择安装VS2015编译套件，也就安装了。使用上一直没有什么问题，所以也没有注意到这个细节。 后来使用cmake生成项目工程文件的时候，选择VS2015编译器，却提示找不到C编译器。
CMake Error at CMakeLists.txt:3 (project): No CMAKE_CXX_COMPILER could be found.  2、解决 原本以为是环境变量没有设置好，查看了一下VS140COMNTOOLS的路径是对的。 然后试着在VS2015本机工具命令提示符工具下试试cmake行不行。结果一打开VS2015本机工具命令提示符就提示让你安装Visual Studio or C++ Build SKU
C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC&amp;gt;vcvarsall.bat &amp;quot;x86&amp;quot; &amp;quot;8.1&amp;quot; Error in script usage. The correct usage is: vcvarsall.bat [option] or vcvarsall.bat [option] store or vcvarsall.bat [option] [version number] or vcvarsall.bat [option] store [version number] where [option] is: x86 | amd64 | arm | x86_amd64 | x86_arm | amd64_x86 | amd64_arm where [version number] is either the full Windows 10 SDK version number or &amp;quot;8.</description>
    </item>
    
    <item>
      <title>linux下挂载VHD等虚拟磁盘文件</title>
      <link>http://sotex.github.io/post/2017-02-10-linux%E4%B8%8B%E6%8C%82%E8%BD%BDvhd%E7%AD%89%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-10-linux%E4%B8%8B%E6%8C%82%E8%BD%BDvhd%E7%AD%89%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/10/6385398.html
1、RAW格式虚拟磁盘 linux下可以直接挂载raw格式的虚拟磁盘镜像文件。
例如，这里先用dd命令创建一个文件，然后将其格式化为ext4格式(只有一个分区)，然后挂载到/mnt目录。 下面的raw.img磁盘镜像文件就一个分区，所以没有使用offset=来指定偏移。如果有多个分区，则可以通过指定偏移来挂载。具体的可以查阅mount命令的相关参数信息。
&amp;gt; dd if=/dev/zero of=raw.img bs=1M count=512 记录了512+0 的读入 记录了512+0 的写出 536870912 bytes (537 MB, 512 MiB) copied, 0.207045 s, 2.6 GB/s /home/o [o@o-pc] [10:29] &amp;gt; mkfs.ext4 -q raw.img /home/o [o@o-pc] [10:30] &amp;gt; sudo mount -o loop raw.img /mnt /home/o [o@o-pc] [10:30] &amp;gt; df -h 文件系统 容量 已用 可用 已用% 挂载点 tmpfs 3.9G 79M 3.8G 2% /dev/shm /dev/sda4 30G 6.6G 24G 22% / tmpfs 3.</description>
    </item>
    
    <item>
      <title>Windows 8.1 SDK的使用</title>
      <link>http://sotex.github.io/post/2017-02-09-windows-8.1-sdk%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 09 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-09-windows-8.1-sdk%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/09/6382692.html Windows Server 2012 程序运行报错（VS2015编译、目标平台8.1、x64版本） 运行的主机CPU为至强处理器，Windows Server 2012系统。 首先，下载Windows 8.1 SDK并安装。 然后在VS2015中选择工程，右键点击项目&amp;ndash;&amp;gt;属性&amp;ndash;&amp;gt;常规&amp;ndash;&amp;gt;平台工具集中选择WindowsApplicationSDK8.1，然后编译</description>
    </item>
    
    <item>
      <title>linux下编译upx 3.93</title>
      <link>http://sotex.github.io/post/2017-02-08-linux%E4%B8%8B%E7%BC%96%E8%AF%91upx-3.93/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-02-08-linux%E4%B8%8B%E7%BC%96%E8%AF%91upx-3.93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/02/08/6377807.html 昨天，UPX发布了3.93版本。 UPX(the Ultimate Packer for eXecutables)是一个非常全面的可执行文件压缩软件,支持dos/exe、dos/com、dos/sys、djgpp2/coff、 watcom/le、win32/pe、rtm32/pe、tmt/adam、atari/tos、linux/i386等几乎所有平台上的可执行文件, 具有极佳的压缩比,还可以对未压缩的文件和压缩完后进行比较。
1、准备源码包 直接去github下载zip包或者直接克隆一下。
git clone https://github.com/upx/upx.git cd upx rmdir lzma-sdk git clone https://github.com/upx/upx-lzma-sdk.git lzma-sdk  lzma库无需编译。
然后去下载UCL库。 UCL是完全使用ANSI C编写的NRV（Not Really Vanished）算法的一个开源实现。 具体的介绍请查阅http://www.oberhumer.com/opensource/ucl/
wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz  国外的网站下载比较慢，可以直接点击此处下载我已经下好的。
2、编译 UCL编译 先生成Makefile文件
tar -xzvf ucl-1.03.tar.gz cd ucl-1.03 ./configure --prefix=/home/o/ucl CC=clang ```` 注意上面，指定了C编译器为`clang`。这里是因为gcc的一个bug，导致 **ACC一致性测试失败** ，所以使用clang。 gcc出现的错误情况在这里[FTBFS with GCC 6: compiler failed the ACC conformance test](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=811707)有详细描述。 ### 编译UPX 使用下面命令编译upx ```shell make all UPX_UCLDIR=/home/o/upx/ucl/ucl-1.03 UPX_LZMADIR=./src/lzma-sdk  注意，这里的UPX_UCLDIR变量的值必须是绝对路径。 编译出的结果是upx.</description>
    </item>
    
    <item>
      <title>Linux下RocksDB、LevelDB、ForestDB性能测试对比</title>
      <link>http://sotex.github.io/post/2017-01-20-linux%E4%B8%8Brocksdbleveldbforestdb%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Fri, 20 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-20-linux%E4%B8%8Brocksdbleveldbforestdb%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/20/6323400.html
简要说明 本次环境与http://www.cnblogs.com/oloroso/p/6306352.html中的一致。 依然是增删查改各测试10000次，每个测试重复5次取平均值。
1、不使用jemalloc和tbb测试 三个数据库除了rocksdb之外，默认都不使用jemalloc和tbb。 设置rocksdb的编译参数为make static_lib -e DISABLE_JEMALLOC=1 -j8，以便不启用jemalloc。
三个测试代码的编译命令如下:
g++ rocksdb_test.cpp -o rocksdb_test -I./include -L. -lrocksdb -lpthread -lrt -lsnappy -lgflags -lz -lbz2 -llz4 -O2 g++ leveldb_test.cpp -o leveldb_test -I../include -L. -lleveldb -O2 -Wl,-rpath=. g++ forestdb_test.cpp -o forestdb_test -I../include -L. -lforestdb -O2 -Wl,-rpath=.  测试结果对比直方图如下 2、使用jemalloc和tbb测试 因为leveldb内没有设置使用jemalloc的代码，所以只在链接的时候添加。 forestdb使用cmake生成Makefile的时候设置变量COUCHBASE_SERVER_BUILD和_JEMALLOC的值为1来使用jemalloc。
三个测试代码的编译命令如下:
g++ rocksdb_test.cpp -o rocksdb_test -I./include -L. -lrocksdb -lpthread -lrt -lsnappy -lgflags -lz -lbz2 -llz4 -ljemalloc -ltbb -O2 g++ leveldb_test.</description>
    </item>
    
    <item>
      <title>Windows下 VS2015编译RocksDB</title>
      <link>http://sotex.github.io/post/2017-01-20-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91rocksdb/</link>
      <pubDate>Fri, 20 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-20-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91rocksdb/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/20/6323124.html VS2015编译RocksDB
RocksDB 是一个来自 facebook 的可嵌入式的支持持久化的 key-value 存储系统，也可作为 C/S 模式下的存储数据库，但主要目的还是嵌入式。RocksDB 基于 LevelDB 构建。
1、下载rocksdb源码 git clone https://github.com/facebook/rocksdb.git  2、使用CMAKE生成VS工程 打开cmd窗口(最好使用VS2015开发人员命令提示)，进入源码目录，执行下面命令
mkdir msvc14	# 创建构建目录 cd msvc14	# 进入构建目录 # 生成VS项目(D:\Libs\rocksdb是编译后安装路径) cmake -DCMAKE_INSTALL_PREFIX=D:\Libs\rocksdb -G &amp;quot;Visual Studio 14 Win64&amp;quot; ..  实际上rocksdb源码目录中的CMakeList.txt文件中并没有写INSTALL段的内容，所以这里指定安装路径实际是无效的。
3、编译RocksDB 打开VS2015 x64 本机工具命令提示(或VS2015开发人员命令提示)工具，执行下面命令进行编译64位release版本的RocksDB库
msbuild ALL_BUILD.vcproject /p:configuration=release /maxcpucount:8  因为test项目也都编译了，文件较多，所以这里使用了/maxcpucount:8指定使用的CPU核心数。 如果只编译rocksdb(静态)库，可以使用msbuild rocksdblib.vcproject /p:configuration=release命令 编译动态库使用msbuild rocksdb.vcproject /p:configuration=release命令
编译完成后，通过的做法是使用下面命令进行安装
msbuild INSTALL.vcproject /p:configuration=release  但是这里没有生成INSTALL.vcproject，所以这里的安装需要手动进行。 直接拷贝msvc14/Release目录下的rocksdblib.lib文件和源码目录的include目录即可。
4、编译后续 因为编译出来的是动态库，但是实际上RocksDB的代码中比没有使用__declspec(dllexport)导出函数和类接口，所以在使用的时候会遇到类似如下的问题
rocksdb_test.obj : error LNK2019: 无法解析的外部符号 &amp;quot;public: __cdecl rocksdb::ColumnFamilyOptions::ColumnFamilyOptions(void)&amp;quot; (?</description>
    </item>
    
    <item>
      <title>LevelDB和ForestDB简单性能测试(含代码)</title>
      <link>http://sotex.github.io/post/2017-01-19-leveldb%E5%92%8Cforestdb%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%90%AB%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 19 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-19-leveldb%E5%92%8Cforestdb%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%90%AB%E4%BB%A3%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/19/6306352.html
测试环境简单说明 Windows下测试 硬件环境如下： 处理器：Intel&amp;reg; Core&amp;trade; i5-4460 CPU @ 3.20GHz 内 存：8GB 硬 盘：希捷 ST1000DM003 操作系统：Windows 10 企业版 编译说明： 两个都是使用VS2015编译的64位Release版本。运行时库采用动态多线程版本(MD)
Linux下测试 硬件环境如下： 处理器：Intel&amp;reg; Core&amp;trade; i7-4500U CPU @ 1.80GHz 内 存：8GB 硬 盘：金士顿64G SSD 操作系统：ArchLinux (Linux version 4.8.13-1-ARCH) 编译说明： 两个都是使用Gcc 6.2.1编译的x64版本，使用-O2参数优化。
测试结果 对LevelDB和ForestDB进行简单的性能测试。 两个都在单线程下进行10000次的增删查改测试，共测试5次。（这里测试的次数有点少，应该测试十万次以上的） 测试的时候可以发现（设置断点），Forest每次操作都将数据缓存在内存了，内存占用比较大。而LevelDB在添加的时候并没有缓存，但是在数据获取和修改的时候内存会变大。 总体上LevelDB占用内存小一点，但是linux下速度不及ForestDB(非常接近)。易用程度上，LevelB简单得多。磁盘占用的情况的话，Forest对磁盘使用比较少，这10000条数据占了13MB左右，而LevelDB则占了120MB左右。
Windows下测试结果 测试结果平均值对比直方图： LevelDB 测试结果截图 ForestDB 测试结果截图 Linux下测试结果 测试结果平均值对比直方图： LevelDB 测试结果截图 ForestDB 测试结果截图 测试代码 LevelDB测试代码 #include &amp;lt;cassert&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; #include &amp;quot;leveldb/db.</description>
    </item>
    
    <item>
      <title>Leveldb 使用说明文档</title>
      <link>http://sotex.github.io/post/2017-01-19-leveldb-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</link>
      <pubDate>Thu, 19 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-19-leveldb-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/19/6307206.html
Leveldb 使用说明文档 原作者：Jeff Dean, Sanjay Ghemawat 翻译：乌合之众solym@sohu.com
英文原文地址https://rawgit.com/google/leveldb/master/doc/index.html
leveldb库提供持久性键值存储。 键和值可以是任意字节数组。 根据用户指定的比较函数，在键值存储器内对键进行排序。
打开一个数据库 leveldb打开数据库需要指定一个文件系统目录。 数据库的所有内容都存储在此目录中。 以下示例显示如何打开数据库，如有必要，可创建该数据库：
#include &amp;lt;cassert&amp;gt; #include &amp;quot;leveldb/db.h&amp;quot; leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; leveldb::Status status = leveldb::DB::Open(options, &amp;quot;/tmp/testdb&amp;quot;, &amp;amp;db); assert(status.ok()); ...  如果要在数据库 已存在时返回错误 ，请在leveldb::DB::Open调用之前添加以下行：
options.error_if_exists = true;  状态 Status 你也许已经注意到了上面的leveldb::Status类型。leveldb中可能遇到错误的大多数函数都返回此类型的值。 您可以检查这样的结果是否正确，并打印相关的错误消息：
leveldb::Status s = ...; if (!s.ok()) cerr &amp;lt;&amp;lt; s.ToString() &amp;lt;&amp;lt; endl;  关闭数据库 使用完数据库后，只需删除数据库对象。 例：
 ... open the db as described above .</description>
    </item>
    
    <item>
      <title>Windows下 VS2015编译ForestDB</title>
      <link>http://sotex.github.io/post/2017-01-19-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91forestdb/</link>
      <pubDate>Thu, 19 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-19-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91forestdb/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/19/6305615.html
VS2015编译ForestDB ForestDB 是一个快速的 Key-Value 存储引擎，基于层次B +树单词查找树。由 Couchbase 缓存和存储团队开发。
1、下载forestdb源码 git clone https://github.com/couchbase/forestdb.git  2、使用CMAKE生成VS工程 打开cmd窗口(最好使用VS2015开发人员命令提示)，进入源码目录，执行下面命令
mkdir msvc14	# 创建构建目录 cd msvc14	# 进入构建目录 # 生成VS项目(D:\Libs\forsetdb是编译后安装路径) cmake -DCMAKE_INSTALL_PREFIX=D:\Libs\forsetdb -G &amp;quot;Visual Studio 14 Win64&amp;quot; ..  3、编译ForestDB 打开VS2015 x64 本机工具命令提示(或VS2015开发人员命令提示)工具，执行下面命令进行编译64位release版本的ForestDB库
msbuild ALL_BUILD.vcproject /p:configuration=release  编译完成后使用下面命令进行安装
msbuild INSTALL.vcproject /p:configuration=release  安装完成后可以到前面设置的安装路径(D:\Libs\forsetdb)去查看生成的库。
D:\Libs\forsetdb&amp;gt;tree /f Folder PATH listing for volume work Volume serial number is 00000001 000D:5E54 D:. ├───bin │ forestdb.dll │ forestdb_dump.</description>
    </item>
    
    <item>
      <title>Windows下 VS2015编译levelDB（nmake）</title>
      <link>http://sotex.github.io/post/2017-01-18-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91leveldbnmake/</link>
      <pubDate>Wed, 18 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-18-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91leveldbnmake/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/18/6297517.html
VS2015编译levelDB Leveldb是一个google实现的非常高效的kv数据库，非常适合嵌入到程序中。如果有简单的key-value数据库需求，而又想使用一个数据库服务的话，levelDB是非常合适的。(BerkeleyDB和forestdb也不错)。
本文不适用于VS2013及更低版本。
1、下载level源码 直接使用git克隆一个即可
git clone https://github.com/google/leveldb.git  2、切换到windows分支 进入leveldb目录，执行下面操作
git checkout origin/windows  现在的leveldb版本是1.19但是Windows版本为1.17。
3、源码修改 切换到windows分支后，还需要修改两处地方。
1、修改db/c.cc文件 打开db/c.cc文件，将第八行位置修改如下
#ifndef WIN32 #include &amp;lt;unistd.h&amp;gt; #endif  2、修改port/port.h文件 在如下代码(17、18行)
#elif defined(LEVELDB_PLATFORM_ANDROID) # include &amp;quot;port/port_android.h&amp;quot;  后面添加
#elif defined(LEVELDB_PLATFORM_WINDOWS) # include &amp;quot;port/port_win.h&amp;quot;  3、修改port/port_win.h文件 将第四行的宏定义给注释掉
#define snprintf _snprintf	// 注释掉此句  因为VS2015中已经实现了snprintf的定义，所以不需要这个了。 如果不去掉，编译的时候将出现以下错误。
cl -c -nologo -Zc:wchar_t -FS -Zc:strictStrings -Zc:throwingNew -Zi -MDd -GR -W3 -w34100 -w34189 -w44996 -w44456 -w44457 -w44458 -wd4577 -EHsc -DLEVELDB_PLATFORM_WINDOWS -DOS_WIN -DWIN32 -DWIN64 -DNDEBUG -D_CRT_SECURE_NO_WARNINGS -I.</description>
    </item>
    
    <item>
      <title>libvlc_new 调用产生段错误</title>
      <link>http://sotex.github.io/post/2017-01-17-libvlc_new-%E8%B0%83%E7%94%A8%E4%BA%A7%E7%94%9F%E6%AE%B5%E9%94%99%E8%AF%AF/</link>
      <pubDate>Tue, 17 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-17-libvlc_new-%E8%B0%83%E7%94%A8%E4%BA%A7%E7%94%9F%E6%AE%B5%E9%94%99%E8%AF%AF/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/18/6295205.html 在调试程序的时候，碰到一个奇怪的段错误问题。只要链接的时候使用-Wl,-rpath=./vlc/lib就会产生段错误，如果链接的时候使用的是-Wl,-rpath=../../tool/vlc/lib则不会出现。
机器是老旧的NeoKylin 4.0版本，没有安装gdb（实际上也不可能去安装）。无法调试，所以在程序里多添加了一些打印输出，终于定位到产生段错误的位置。
代码 输出 查了一些资料 http://www.videolan.org/developers/vlc/doc/doxygen/html/grouplibvlccore.html
这里说 在POSIX系统上，SIGCHLD信号不能被忽略，即信号处理程序必须设置为SIG_DFL（默认处理）或函数指针，而不能是SIG_IGN（忽略）。 还有 LibVLC可以创建线程。 因此，任何线程不安全的进程初始化必须在调用libvlc_new()之前执行。
但是这里没有说到重点，这些都不是产生段错误的原因。 真正的原因是因为vlc存在插件缓存，需要刷新插件缓存才行。 在vlc/lib/vlc/plugins下存在一个plugins.bat文件，cat这个文件可以发现其中大部分都是普通文本，少数是非文本内容。
通过网络搜索，找到这篇文章，真正的说明了问题 http://blog.jianchihu.net/libvlc_new-return-null.html
自己编译的vlc，vlc-cache-gen程序实际上在vlc/lib/vlc/vlc-cache-gen。执行下面命令即可
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./vlc/lib ./vlc/lib/vlc/vlc-cache-gen ./vlc/lib/vlc/plugins/  然后就没有问题了</description>
    </item>
    
    <item>
      <title>由一次 symbol lookup error 引发的思考</title>
      <link>http://sotex.github.io/post/2017-01-13-%E7%94%B1%E4%B8%80%E6%AC%A1-symbol-lookup-error-%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Fri, 13 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-13-%E7%94%B1%E4%B8%80%E6%AC%A1-symbol-lookup-error-%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/13/6283248.html 开发一个跨平台的项目的时候，大部分时候都是在VS下进行编码，所以也就使用了VS的解决方案来管理项目。 因为要跨平台，当时网上看scons这个工具不错，所以在linux下就使用了scons来作为编译脚本。
linux(gcc)下与windows(vs)下的对于链接这一步稍有不同。当目标文件是一个(共享)库的时候，VS会在链接的时候就去解析所有用到的符号，而gcc则不会，只有在生成最终可执行程序的时候才会去解析。 所以在VS下，一直都没有问题。linux下进行测试的时候也没有问题(因为不是所有的代码都被调用了)。
这几天在一次移植过程中出现了如下的问题
/a.out: symbol lookup error: ./uds_file_storage_module.so: undefined symbol: _ZN8unispace13us_ini_config9from_fileERKNS_10us_ustringEPS0_  错误很简单，就是us_ini_config::from_file这个函数没有找到，说明没有将其添加到动态导出符号表中。（uds_file_storage_module.so是运行时动态加载的，所以编译的时候没有提示错误）
VC中导出符号需要使用到dllexport，而gcc下则默认是不需要。所以这个问题很是疑惑。
考虑用的gcc版本比较高，是不是它将-fvisibility的参数默认设置为hidden呢？查看了gnu的wiki之后也没有发现这个。
https://gcc.gnu.org/wiki/Visibility
这里还是有收获的，看到一段好的跨平台代码。
#if defined _WIN32 || defined __CYGWIN__ #ifdef BUILDING_DLL #ifdef __GNUC__ #define DLL_PUBLIC __attribute__ ((dllexport)) #else #define DLL_PUBLIC __declspec(dllexport) // 注记:实际上gcc似乎也支持这种语法。 #endif #else #ifdef __GNUC__ #define DLL_PUBLIC __attribute__ ((dllimport)) #else #define DLL_PUBLIC __declspec(dllimport) // 注记:实际上gcc似乎也支持这种语法。 #endif #endif #define DLL_LOCAL #else #if __GNUC__ &amp;gt;= 4 #define DLL_PUBLIC __attribute__ ((visibility (&amp;quot;default&amp;quot;))) #define DLL_LOCAL __attribute__ ((visibility (&amp;quot;hidden&amp;quot;))) #else #define DLL_PUBLIC #define DLL_LOCAL #endif #endif extern &amp;quot;C&amp;quot; DLL_PUBLIC void function(int a); class DLL_PUBLIC SomeClass { int c; DLL_LOCAL void privateMethod(); // Only for use within this DSO public: Person(int _c) : c(_c) { } static void foo(int a); };  然后添加了__attribute__((visibility(&amp;quot;default&amp;quot;)))进行修饰，发现编译的结果没有改变(md5sun判断)。</description>
    </item>
    
    <item>
      <title>运行时加载动态库的一个小问题</title>
      <link>http://sotex.github.io/post/2017-01-11-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 11 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-11-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/11/6273295.html
简要说明 大致情况是这样的： 程序program引用动态库libA和libB。其中libA和libB都引用动态库libShared和静态库libStatic。在libShared和libStatic中都含有静态变量。现在就是看这个静态变量是否存在两份。
 program (可以隐式链接，也可以显示动态链接A和B) | | libStatic-&amp;gt; libA libB &amp;lt;- libStatic | |	(隐式链接Shared) libShared  因为libA和libB都链接了静态库libStatic，所以libStatic的内容会存在两份。在映射到program的进程空间的时候，这部分就会存在映射到不同地址的两份。在windows上的测试结果确实是如此，在linux上的测试结果中，如果是显示动态链接libA和libB也是，但是如果是隐式链接，那么结果却是只有一份。
因为libShared是动态库，在libA和libB中都不存在，所以在第一个映射到program的进程空间之后，第二次引用的时候就不会再去映射一次了。
这里的一个结论就是，如果一个静态库被多处引用，那么这个静态库在最终程序的进程空间可能会存在多份。如果这个静态库中含有静态变量或全局变量，那么这个变量也会存在多份。如果这个变量是一个类对象，那么变量初始化的时候，每一份都会调用构造函数。因为VS编译的时候默认是不导出符号的，而gcc默认是导出的，也可能是这个原因。但libA和libB都是动态库，这两者中应该都是含有引用的libStatic部分的全部内容的。
所以，在静态库中最好不要去存放全局变量，也不要在这里创建单例对象等。如果对程序文件大小有要求，最好使用动态库。
实验代码 实验代码包括六个部分，libA/libB/libShared/libStaic/test/test2。其中test测试的是显示动态链接，test2测试的是隐式链接。
源代码下载LoadLibraryTest.7z 可以使用QtCreator工具打开。
libStatic libStatic.hpp
#ifndef LIBSTATIC_HPP #define LIBSTATIC_HPP void func_Static(); #endif // LIBSTATIC_HPP  libStatic.cpp
#include &amp;quot;LibStatic.hpp&amp;quot; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; void func_Static() { static char buf[1024] = &amp;quot;这个是libStatic里的buffer。&amp;lt;----&amp;gt;&amp;quot;; printf(&amp;quot;func_Static 地址 %p|&amp;quot;,&amp;amp;func_Static); printf(&amp;quot;buf 地址 %p\n\t%s\t&amp;quot;,&amp;amp;buf,buf); static int x = 0; if(x == 0) x = rand(); sprintf(buf,&amp;quot;libStatic的buffer被修改 %d&amp;quot;,x); printf(&amp;quot;%s\n--------------------------\n&amp;quot;,buf); }  libShared libshared_global.</description>
    </item>
    
    <item>
      <title>Visual Studio 默认保存为UTF8编码</title>
      <link>http://sotex.github.io/post/2017-01-03-visual-studio-%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E4%B8%BAutf8%E7%BC%96%E7%A0%81/</link>
      <pubDate>Tue, 03 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2017-01-03-visual-studio-%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E4%B8%BAutf8%E7%BC%96%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/01/03/6245772.html Visual Studio (中文版)默认保存的文本文件是GB2312编码（代码页936）的，默认的行尾（End of line）是CRLF的。 如果仅仅是在windows下开发问题也不大，但是涉及到跨平台开发的时候，就不是很满意了。
VS本身的 文件 -&amp;gt; 高级保存选项 中是可以选择保存的编码和行尾的，但是不支持为默认的。 还有一个问题是cl编译的时候，对utf-8格式支持不好（需要添加/source-charset:utf-8选项，默认是当作本地字符集的），对于带BOM标记的文件则没有问题。
所以我们在项目中统一规定使用UTF-8 with BOM编码，行尾为LF(\n)。
这里介绍两个插件
ForceUTF8 (with BOM) 这个插件还有两个版本，一个是带BOM的，一个是不带的。 插件是开源的，代码很简单。就是在文档保存的时候，判断是否是文本文件。如果是的话，那就先转编码为UTF-8 with BOM，再写入文件。
下载地址 https://marketplace.visualstudio.com/items?itemName=jz5.ForceUTF8withBOM
其实可以直接在这个项目上改，在保存文件前把\r\n、\r、\n都替换为\n即可(要注意替换次序)。
Line Endings Unifier 这个插件用来统一行尾。 可以设置针对的文件和目标行尾。它也是开源的。
下载地址 https://marketplace.visualstudio.com/items?itemName=JakubBielawa.LineEndingsUnifier</description>
    </item>
    
    <item>
      <title>proj.4 线程安全</title>
      <link>http://sotex.github.io/post/2016-12-29-proj.4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
      <pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-29-proj.4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/29/6232710.html
proj.4 线程安全 本文翻译自proj.4开发者文档 原文链接 http://proj4.org/development/threads.html
线程安全关键问题 全局变量pj_error是在线程之间共享的，使得它基本上不可能安全的处理错误(译注:这个和C的errno不一样)。通过引进执行上下文projCtx来解决这个问题。
原点平移使用的网格文件，需要使用到全局共享的网格信息载入列表。proj 4.7.0版本中引入mutex(互斥锁)来保护这些存储结构(参见pj_mutex.c)，在4.7.0及后续版本中对此访问是线程安全的。
projCtx 为了避免将pr_errno作为全局变量，4.8.0版本中将thread context(线程上下文)结构引入到PROJ.4 API中。pj_init()和pj_init_plus()函数现在具有需要线程上下文变量的版本pj_init_ctx()和pj_init_plus_ctx()，采用投影上下文(projections context)。
可以使用pj_ctx_alloc()创建投影上下文(projections context)，当应用程序不提供投影上下文的时候，会使用全局默认上下文。有一系列pj_ctx_...的函数用于创建、操作、查询和销毁上下文。上下文现在还可用来处理设置调试模式，并保持用于文本错误和调试消息的错误报告功能。API如下所示：
projPJ pj_init_ctx( projCtx, int, char ** ); projPJ pj_init_plus_ctx( projCtx, const char * ); projCtx pj_get_default_ctx(void); projCtx pj_get_ctx( projPJ ); void pj_set_ctx( projPJ, projCtx ); projCtx pj_ctx_alloc(void); void pj_ctx_free( projCtx ); int pj_ctx_get_errno( projCtx ); void pj_ctx_set_errno( projCtx, int ); void pj_ctx_set_debug( projCtx, int ); void pj_ctx_set_logger( projCtx, void (*)(void *, int, const char *) ); void pj_ctx_set_app_data( projCtx, void * ); void *pj_ctx_get_app_data( projCtx );  在多线程程序中应当使用pj_ctx_alloc()为每个线程创建projCtx。如果需要，上下文错误处理程序也许可以修改应用数据，但至少每个上下文都有一个内部错误值，使用pj_ctx_get_errno()访问，而不是查看pj_errno。</description>
    </item>
    
    <item>
      <title>基于libvlc和wxWidgets的简单播放器代码阅读</title>
      <link>http://sotex.github.io/post/2016-12-28-%E5%9F%BA%E4%BA%8Elibvlc%E5%92%8Cwxwidgets%E7%9A%84%E7%AE%80%E5%8D%95%E6%92%AD%E6%94%BE%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Wed, 28 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-28-%E5%9F%BA%E4%BA%8Elibvlc%E5%92%8Cwxwidgets%E7%9A%84%E7%AE%80%E5%8D%95%E6%92%AD%E6%94%BE%E5%99%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/28/6229500.html 源代码来自 http://git.videolan.org/?p=vlc.git;a=blob_plain;f=doc/libvlc/wx_player.cpp
// g++ wx_player.cpp `wx-config --libs` `wx-config --cxxflags` `pkg-config --cflags gtk+-2.0 libvlc` `pkg-config --libs gtk+-2.0 libvlc` -o wx_player /* License WTFPL http://sam.zoy.org/wtfpl/ */ /* Written by Vincent Schüßler */ #include &amp;lt;wx/wx.h&amp;gt; #include &amp;lt;wx/filename.h&amp;gt; #include &amp;lt;vlc/vlc.h&amp;gt; #include &amp;lt;climits&amp;gt; #ifdef __WXGTK__ #include &amp;lt;gdk/gdkx.h&amp;gt; #include &amp;lt;gtk/gtk.h&amp;gt; #include &amp;lt;wx/gtk/win_gtk.h&amp;gt; #define GET_XID(window) GDK_WINDOW_XWINDOW(GTK_PIZZA(window-&amp;gt;m_wxwindow)-&amp;gt;bin_window) #endif #define myID_PLAYPAUSE wxID_HIGHEST+1 #define myID_STOP wxID_HIGHEST+2 #define myID_TIMELINE wxID_HIGHEST+3 #define myID_VOLUME wxID_HIGHEST+4 #define TIMELINE_MAX (INT_MAX-9) #define VOLUME_MAX 100 DECLARE_EVENT_TYPE(vlcEVT_END, -1) DECLARE_EVENT_TYPE(vlcEVT_POS, -1) DEFINE_EVENT_TYPE(vlcEVT_END) DEFINE_EVENT_TYPE(vlcEVT_POS) void OnPositionChanged_VLC(const libvlc_event_t *event, void *data); void OnEndReached_VLC(const libvlc_event_t *event, void *data); // 主窗口 class MainWindow : public wxFrame { public: MainWindow(const wxString&amp;amp; title); ~MainWindow(); private: // 初始化VLC void initVLC(); void OnOpen(wxCommandEvent&amp;amp; event); void OnPlayPause(wxCommandEvent&amp;amp; event); void OnStop(wxCommandEvent&amp;amp; event); void OnPositionChanged_USR(wxCommandEvent&amp;amp; event); void OnPositionChanged_VLC(wxCommandEvent&amp;amp; event); void OnEndReached_VLC(wxCommandEvent&amp;amp; event); void OnVolumeChanged(wxCommandEvent&amp;amp; event); void OnVolumeClicked(wxMouseEvent&amp;amp; event); void OnTimelineClicked(wxMouseEvent&amp;amp; event); void play(); void pause(); void stop(); void setTimeline(float value); void connectTimeline(); wxButton *playpause_button;	// 播放暂停按钮 wxButton *stop_button;	// 停止按钮 wxSlider *timeline;	// 进度控制滑块 wxSlider *volume_slider;	// 音量控制滑块 wxWindow *player_widget;	// 视频输出窗口 libvlc_media_player_t *media_player;	// vlc媒体播放对象 libvlc_instance_t *vlc_inst;	// vlc实例 libvlc_event_manager_t *vlc_evt_man;	// vlc事件管理 }; MainWindow *mainWindow; MainWindow::MainWindow(const wxString&amp;amp; title) : wxFrame(NULL, wxID_ANY, title, wxDefaultPosition) { // setup menubar wxMenuBar *menubar; wxMenu *file; menubar = new wxMenuBar; file = new wxMenu; file-&amp;gt;Append(wxID_OPEN, wxT(&amp;quot;&amp;amp;Open&amp;quot;)); menubar-&amp;gt;Append(file, wxT(&amp;quot;&amp;amp;File&amp;quot;)); SetMenuBar(menubar); Connect(wxID_OPEN, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(MainWindow::OnOpen)); // setup vbox wxBoxSizer *vbox = new wxBoxSizer(wxVERTICAL); this-&amp;gt;SetSizer(vbox); //setup player widget player_widget = new wxWindow(this, wxID_ANY); player_widget-&amp;gt;SetBackgroundColour(wxColour(wxT(&amp;quot;black&amp;quot;)));	// 设置播放窗口颜色 vbox-&amp;gt;Add(player_widget, 1, wxEXPAND | wxALIGN_TOP); //setup timeline slider timeline = new wxSlider(this, myID_TIMELINE, 0, 0, TIMELINE_MAX); timeline-&amp;gt;Enable(false); vbox-&amp;gt;Add(timeline, 0, wxEXPAND); connectTimeline(); // 设置进度滑块鼠标事件回调 timeline-&amp;gt;Connect(myID_TIMELINE, wxEVT_LEFT_UP, wxMouseEventHandler(MainWindow::OnTimelineClicked)); //setup control panel wxPanel *controlPanel = new wxPanel(this, wxID_ANY); //setup hbox wxBoxSizer *hbox = new wxBoxSizer(wxHORIZONTAL); controlPanel-&amp;gt;SetSizer(hbox); vbox-&amp;gt;Add(controlPanel, 0, wxEXPAND); //setup controls playpause_button = new wxButton(controlPanel, myID_PLAYPAUSE, wxT(&amp;quot;Play&amp;quot;)); stop_button = new wxButton(controlPanel, myID_STOP, wxT(&amp;quot;Stop&amp;quot;)); volume_slider = new wxSlider(controlPanel, myID_VOLUME, VOLUME_MAX, 0, VOLUME_MAX, wxDefaultPosition, wxSize(100, -1)); playpause_button-&amp;gt;Enable(false); stop_button-&amp;gt;Enable(false); hbox-&amp;gt;Add(playpause_button); hbox-&amp;gt;Add(stop_button); hbox-&amp;gt;AddStretchSpacer(); hbox-&amp;gt;Add(volume_slider); Connect(myID_PLAYPAUSE, wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(MainWindow::OnPlayPause)); Connect(myID_STOP, wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(MainWindow::OnStop)); Connect(myID_VOLUME, wxEVT_COMMAND_SLIDER_UPDATED, wxCommandEventHandler(MainWindow::OnVolumeChanged)); volume_slider-&amp;gt;Connect(myID_VOLUME, wxEVT_LEFT_UP, wxMouseEventHandler(MainWindow::OnVolumeClicked)); //setup vlc // 创建vlc实例 vlc_inst = libvlc_new(0, NULL); // 创建媒体播放对象 media_player = libvlc_media_player_new(vlc_inst); // 创建vlc事件管理对象 vlc_evt_man = libvlc_media_player_event_manager(media_player); // 设置VLC事件属性 // 媒体播放结束事件 libvlc_event_attach(vlc_evt_man, libvlc_MediaPlayerEndReached, ::OnEndReached_VLC, NULL); // 媒体播放进度改变事件 libvlc_event_attach(vlc_evt_man, libvlc_MediaPlayerPositionChanged, ::OnPositionChanged_VLC, NULL); // wx的事件处理 // 处理vlcEVT_END事件 Connect(wxID_ANY, vlcEVT_END, wxCommandEventHandler(MainWindow::OnEndReached_VLC)); // 处理vlcEVT_POS事件 Connect(wxID_ANY, vlcEVT_POS, wxCommandEventHandler(MainWindow::OnPositionChanged_VLC)); Show(true); initVLC(); } MainWindow::~MainWindow() { // 释放媒体播放对象 libvlc_media_player_release(media_player); libvlc_release(vlc_inst); } void MainWindow::initVLC() { #ifdef __WXGTK__ // 设置视频输出的窗口 libvlc_media_player_set_xwindow(media_player, GET_XID(this-&amp;gt;player_widget)); #else // 这是在windows下的 libvlc_media_player_set_hwnd(media_player, this-&amp;gt;player_widget-&amp;gt;GetHandle()); #endif } void MainWindow::OnOpen(wxCommandEvent&amp;amp; event) { wxFileDialog openFileDialog(this, wxT(&amp;quot;Choose File&amp;quot;)); if (openFileDialog.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;编译期间字节序判断</title>
      <link>http://sotex.github.io/post/2016-12-20-c&#43;&#43;%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%A4%E6%96%AD/</link>
      <pubDate>Tue, 20 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-20-c&#43;&#43;%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%A4%E6%96%AD/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/20/6203365.html 当前常用的字节序一般就两种，大端序和小端序。 下面列出四种字节序的表达方式。在对应平台下，内存布局为{0x,00,0x01,0x02,0x03}的四字节，表示为十六进制的值就如下面代码所示的。
ENDIAN_BIG	= 0x00010203,	/* 大端序 ABCD */ ENDIAN_LITTLE	= 0x03020100,	/* 小端序 DCBA */ ENDIAN_BIG_WORD	= 0x02030001, /* 中端序 CDAB, Honeywell 316 风格 */ ENDIAN_LITTLE_WORD	= 0x01000302	/* 中端序 BADC, PDP-11 风格 */  gcc或clang中可以使用 __BYTE_ORDER__宏来判断
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main() { // 这两个宏是gcc或者clang支持的 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ puts(&amp;quot;小端序&amp;quot;); #elif __BYTE_ORDER__== __ORDER_BIG_ENDIAN__ puts(&amp;quot;大端序&amp;quot;); #else puts(&amp;quot;未知字节序&amp;quot;); #endif // __BYTE_ORDER__ return 0; }  还有使用C++ 11的constexpr关键字特性来做编译时判断的方法。但是我没有编译通过。 相关的可以看下面这两个网页 - 在编译时检查字节序 http://codereview.</description>
    </item>
    
    <item>
      <title>CPUID指令简单调用</title>
      <link>http://sotex.github.io/post/2016-12-15-cpuid%E6%8C%87%E4%BB%A4%E7%AE%80%E5%8D%95%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 15 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-15-cpuid%E6%8C%87%E4%BB%A4%E7%AE%80%E5%8D%95%E8%B0%83%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/15/6182669.html 关于CPUID指令，可以看维基百科的相关介绍 https://en.wikipedia.org/wiki/CPUID
在windows下可以调用__cpuid和__cpuidex这两个函数，__cpuid函数在VS2005中就已经开始支持了。 https://msdn.microsoft.com/en-us/library/hskdteyh(v=vs.140).aspx
下面是简单的调用代码，在windows下VS不支持x64项目嵌入asm，所以只能编译32位版本。
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; // gcc cpuid.c -o cpuid // cl /DWIN32=1 cpuid.c static void cpuInfo(unsigned int cpuinfo[4], unsigned int fn_id) { unsigned int deax,debx,decx,dedx; #ifdef WIN32 __asm { mov eax,fn_id	; 将参数赋值给eax cpuid	; 执行cpuid指令 mov deax,eax	; 将寄存器值赋值给临时变量 mov debx,ebx mov decx,ecx mov dedx,edx } #elif defined(__GNUC__) __asm__ (&amp;quot;cpuid&amp;quot; :&amp;quot;=a&amp;quot;(deax), &amp;quot;=b&amp;quot;(debx), &amp;quot;=c&amp;quot;(decx), &amp;quot;=d&amp;quot;(dedx) :&amp;quot;a&amp;quot;(fn_id)); #endif cpuinfo[0]=deax; cpuinfo[1]=debx; cpuinfo[2]=dedx; cpuinfo[3]=decx; } int main(int argc,char** argv) { unsigned int fn_id = 0; if(argc == 2){ fn_id = atoi(argv[1]); } unsigned int cpu[4]; cpuInfo(cpu,fn_id); printf(&amp;quot;%08X-%08X-%08X-%08X\n&amp;quot;,cpu[0],cpu[1],cpu[2],cpu[3]); return 0; }  </description>
    </item>
    
    <item>
      <title>linux 下Qt WebEngine 程序打包简单记录</title>
      <link>http://sotex.github.io/post/2016-12-09-linux-%E4%B8%8Bqt-webengine-%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-09-linux-%E4%B8%8Bqt-webengine-%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/09/6149000.html 本次记录仅作参考。
程序说明： 程序是一个编解码器控制管理的工具，使用到的库有：Qt的WebEngine、OpenGL模块、poco库、libmicrohttpd、libcurl、libvlc。同时程序间接的依赖libssl/libxml2等库。
其中poco/libcurl/libmicrohttpd等都编译为了静态库，libvlc/Qt库都是动态库。这里主要解决动态库的问题。
Qt官方文档中关于Qt在X11下的依赖情况 http://doc.qt.io/qt-5/linux-requirements.html
打包过程： 首先在QtCreator中编译运行程序，没有问题。 重新手动使用`qmake`生成`Makefile`编译后，运行程序出错。  错误及解决： 错误1：  /home/x/program/qt-5.6.0/5.6/gcc_64/libexec/QtWebEngineProcess: error while loading shared libraries: libQt5WebEngineCore.so.5: cannot open shared object file: No such file or directory  这个错误是因为Qt库的原因，这里可以现看一下生成程序的最后一步链接的相关信息
g++ -Wl,-O1 -Wl,-z,origin -Wl,-rpath,\$ORIGIN -Wl,-rpath,/home/x/program/qt-5.6.0/5.6/gcc_64/lib -Wl,-rpath-link,/home/x/program/qt-5.6.0/5.6/gcc_64/lib -o WebCS main.o widget.o ActiveTasks.o Business.o CommonUtil.o JsonConfig.o NMUDPServer.o SocketUtil.o TCPLongConnection.o TCPServer.o UDPLongConnection.o UDPServer.o CharsetConvert.o CharsetConvertMFC.o CharsetConvertSTD.o FileAnywhereManager.o FileAnywhereObserver.o FileAnywhereTaskParameter.o InterfaceProcessTask.o InterfaceProtocolSpecific.o InterfaceServer.o UUID.o CBusinessEvent.o MircoHttpdInit.o VlcPlayer.o moc_widget.o moc_VlcPlayer.</description>
    </item>
    
    <item>
      <title>Windows下C编程获取软件安装列表信息</title>
      <link>http://sotex.github.io/post/2016-12-06-windows%E4%B8%8Bc%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Tue, 06 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-12-06-windows%E4%B8%8Bc%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/12/06/6136428.html 代码如下：
#include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; #ifndef MSVCR #define _T #define _tcscpy strcpy #define _stprintf sprintf #define _tcscmp strcmp #endif typedef struct SetupSoftInfo { string displayName; //软件名称 string publisher; //发行商 string displayVersion; //版本 string installDate; //安装日期 string uninstallString; //卸载命令及参数 void show() { cout&amp;lt;&amp;lt;&amp;quot;\n=======================================================\n软件名称:&amp;quot; &amp;lt;&amp;lt;displayName&amp;lt;&amp;lt;&amp;quot;\n发行商:&amp;quot;&amp;lt;&amp;lt;publisher&amp;lt;&amp;lt;&amp;quot;\n版本:&amp;quot;&amp;lt;&amp;lt;displayVersion &amp;lt;&amp;lt;&amp;quot;\n安装日期:&amp;quot;&amp;lt;&amp;lt;installDate&amp;lt;&amp;lt;&amp;quot;\n卸载命令:&amp;quot;&amp;lt;&amp;lt;uninstallString&amp;lt;&amp;lt;endl; } }*PSetupSoftInfo; BOOL GetSetupSofts(vector&amp;lt;SetupSoftInfo&amp;gt;&amp;amp;stupInfo) { const int MAX_LEG = 256 * sizeof(TCHAR); HKEY hKey; DWORD dwRegNum = MAX_LEG; TCHAR regBufferName[MAX_LEG] = {0}; if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(&amp;quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&amp;quot;), NULL, KEY_READ, &amp;amp;hKey) == ERROR_SUCCESS ) { if( RegQueryInfoKey(hKey, NULL, NULL, NULL, &amp;amp;dwRegNum, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS ){ for( int i = 0; i &amp;lt; (int)dwRegNum; i++ ) { DWORD dwRegSize = MAX_LEG; RegEnumKeyEx(hKey, i, regBufferName, &amp;amp;dwRegSize, NULL, NULL, NULL, NULL); DWORD dwType; HKEY hSubKey; if( RegOpenKeyEx(hKey, regBufferName, NULL, KEY_READ, &amp;amp;hSubKey) == ERROR_SUCCESS) { SetupSoftInfo info; TCHAR regBufferValue[MAX_LEG] = {0}; dwRegSize = MAX_LEG; RegQueryValueEx(hSubKey, _T(&amp;quot;DisplayName&amp;quot;), 0, &amp;amp;dwType, (LPBYTE)regBufferValue, &amp;amp;dwRegSize); info.</description>
    </item>
    
    <item>
      <title>Qt拖拽界面 (*.ui) 缩放问题及解决办法</title>
      <link>http://sotex.github.io/post/2016-11-23-qt%E6%8B%96%E6%8B%BD%E7%95%8C%E9%9D%A2-.ui-%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Wed, 23 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-11-23-qt%E6%8B%96%E6%8B%BD%E7%95%8C%E9%9D%A2-.ui-%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/11/23/6092870.html ##问题
使用Qt Designer 设计的界面，在缩放的时候不能随着主窗口一起缩放。
##解决办法
之前遇到这个问题的时候，都是直接重写resizeEvent接口来实现的，在自动生成的Ui_Widget或Ui_MainWindow等类中会有一个widget或者centerWidget的成员，所有的拖拽出的控件都是在这之上的。只需要把resizeEvent传递给它即可。
这种方式虽然解决了问题，但是总是不太理想，还需要去改代码。
##好的解决办法 其实中问题不需要去改代码，既然所有的拖拽出的控件都在一个widget上，而这个widget是不会随着调用ui-&amp;gt;setupUi(this);的窗口一起缩放的，因为它们只有父子对象关系，而没有使用到布局空间。 这里只需要在Qt Designer中选择设计界面的顶级对象，然后右键单击，在布局选项中选择一个你想要的布局即可。这样之后，moc生成的Ui_XXXX类中会有一个xxxxlayout对象，所有控件都会加载到这个Layout上(替代了原本的widget)。这里生成的xxxxxlayout与选择的布局有关系。</description>
    </item>
    
    <item>
      <title>Libvlc  API 简单说明 [转]</title>
      <link>http://sotex.github.io/post/2016-11-11-libvlc-api-%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E-%E8%BD%AC/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-11-11-libvlc-api-%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E-%E8%BD%AC/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/11/11/6055095.html
Libvlc API 简单说明 原文来自http://www.xuebuyuan.com/1519616.html ####
libvlc_instance_t* libvlc_new(int argc, const char* const* argv)  创建并初始化一个LIBVLC实例
这个函数接受一个命令行参数列表，这个参数列表影响LIBVLC INSTANCE的缺省配置.
Version:
参数意味着被从命令行传递到LIBVLC,就像VLC媒体播放器做的那样。有效的参数列表依赖于LIBVLC的版本、操作系统、平台以及LIBVLC的插件集。无效或不支持的参数将会导致该API的失败（return NULL）。此外，某些参数可能会改变LIBVLC的行为或以其它方式干扰LIBVLC的其它功能。
param: argc : 命令行参数个数
argv : 命令行类型参数
return:
成功返回LIBVLC实例，失败返回NULL。
#### VLC_PUBLIC_API void libvlc_release( libvlc_instance_t *p_instance );  减少LIBVLC INSTANCE的引用计数，并且如果计数为零的话就摧毁它。
（Decrement the reference count of a libvlc instance, and destroy it if it reaches zero）
param：
要摧毁的LIBVLC INSTANCE
####
VLC_PUBLIC_API libvlc_media_player_t * libvlc_media_player_new( libvlc_instance_t *p_libvlc_instance );  创建一个空的媒体播放器对象</description>
    </item>
    
    <item>
      <title>Windows下 VS2015编译boost1.62</title>
      <link>http://sotex.github.io/post/2016-11-10-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91boost1.62/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-11-10-windows%E4%B8%8B-vs2015%E7%BC%96%E8%AF%91boost1.62/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/11/10/6050596.html
VS2015编译boost1.62 Boost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一。 Boost库由C++标准委员会库工作组成员发起，其中有些内容有望成为下一代C++标准库内容。在C++社区中影响甚大，是不折不扣的“准”标准库。Boost由于其对跨平台的强调，对标准C++的强调，与编写平台无关。大部分boost库功能的使用只需包括相应头文件即可，少数（如正则表达式库，文件系统库等）需要链接库。但Boost中也有很多是实验性质的东西，在实际的开发中实用需要谨慎。
在VS下，boost的头文件中会包含#pragma comment(lib,xxx)的语句，所以可以不用在项目中添加相关的库指定。 boost中大部分库是仅有头文件，不用编译成库的。
编译好的库可以到这里下载 链接：http://share.weiyun.com/712e3d95bb73d7378a8c34d3518d12f3 （密码：2LNF）
1、源码 源码的下载可以直接去http://www.boost.org/网站下载。 我下载的地址是http://jaist.dl.sourceforge.net/project/boost/boost/1.62.0/boost_1_62_0.7z
2、生成编译工具 boost库自带了bootstrap脚本来生成一个构建工具b2。打开命令行直接执行即可。
D:\development_library\boost\boost_1_62_0&amp;gt;bootstrap.bat --help Building Boost.Build engine Failed to build Boost.Build engine. Please consult bootstrap.log for further diagnostics. You can try to obtain a prebuilt binary from http://sf.net/project/showfiles.php?group_id=7586&amp;amp;package_id=72941 Also, you can file an issue at http://svn.boost.org Please attach bootstrap.log in that case.  这里出现了Failed to build Boost.Build engine.错误，解决办法很简单，使用VS 2015 命令行提示符来执行即可。 3、进行编译 b2工具的使用如下
b2 [options] [properties] [install|stage] #options	选项 #properties	特性 #install|stage	安装还是编译到指定位置  编译命令如下</description>
    </item>
    
    <item>
      <title>qt添加cef库嵌入web [转]</title>
      <link>http://sotex.github.io/post/2016-11-10-qt%E6%B7%BB%E5%8A%A0cef%E5%BA%93%E5%B5%8C%E5%85%A5web-%E8%BD%AC/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-11-10-qt%E6%B7%BB%E5%8A%A0cef%E5%BA%93%E5%B5%8C%E5%85%A5web-%E8%BD%AC/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/11/10/6051631.html
qt cef嵌入web 原文http://blog.sina.com.cn/s/blog_9e59cf590102vnfc.html
最近项目需要，研究了下libcef库。
Cef(Chromium Embedded Framework)简述 嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。
它的设计思想政治就是易用且兼顾性能。CEF基本的框架包含C/C++程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和Chromium&amp;amp;Webkit的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，javascript对象以及javascript扩展，宿主程序可以随意地控件资源下载，导航和打印等，并且可以跟Google Chrome浏览器一起，支持高性能和Html5 技术。
Cef使用 首先下载cef库的源码，源码有2个大的版本，cef1和cef3，我使用的是cef3，因此cef1我就不过多解释，其实我也不太了解。刚开始使用的时候一定不能怕，可能有些人看了源码之后会发现源码异常的复杂，这个时候我建议网上多差点儿资料，因为我学的时候也是在网上找到了不少好的文章。
下边是我在编译cef库的时候遇到的一些问题：  因为我的项目是基于qt的来做的，而qt的运行时库是MDd类型的，因此cef3编译的时候也应该遵循这个运行时库的编译方式
 我在网上也看到了不少介绍创建cef项目的办法，不过个人觉得好多都是只讲过程，不讲原理，其实使用这个库很简单，我直- 说debug模式，release照搬。首先拷贝exe执行所需资源文件和运行时库(Resources目录下的除include文件夹、Debug目录下所有动态库)，然后拷贝连接器的静态库(out/Debug/lib目录下的静态库、Debug目录下的所有静态库)
 根据个人使用工具的不同自行包含头文化和静态库，我使用的是vs2013，工程属性-&amp;gt;配置属性-&amp;gt;VC++目录，添加包含目录和库目录，在工程属性-&amp;gt;配置属性-&amp;gt;连接器-&amp;gt;输入，页面附加依赖项添加依赖动态库
  以上这3项基本就满足了创建包含cef项目的所有注意事项，如果自己想定制更好使用的控件，则需要相应的代码级别操作，接下来，我就讲讲代码级别基本的操作，复杂的操作我现在也了解不多。
 注释：关于libCef库中每个类的作用，我就不多说了，自己网上随便一搜索一大堆，在这里我直说几个重要的，在我的项目里使用到的：
 CefDownloadHandler：下载回调类，当web页面上有文件下载的时候，会调用该类中的相应接口。注意一点，cef库默认是禁止了文件下载，如果想要响应这一事件，需要在OnBeforeDownload重写接口中加入代码：callback-&amp;gt;Continue(suggested_name, true);
 CefClient：获取注册回调类
 CefDisplayHandler：地址、标题等改变调用接口，重写此类可以处理导航相关事件
 CefRenderProcessHandler：渲染进程，当浏览器创建的时候，该类中的接口会被调用，因此可是在该类的接口中注册方法或者对象到web。包含webkit初始化、导航、上下文创建等回调接口
 CefBrowserProcessHandler：浏览器进程，上下文初始化、渲染进程创建等回调接口
  cef库嵌入已有工程步骤： 1、首先需要自己集成QWidget，重写一个web窗口，如图1所示；
2、main.cpp函数添加如图2所示方法，main方法中初始化Cef库，代码如下，退出时调用CefQuit();
int result = CefInit(argc, argv); if (result &amp;gt;= 0) { return result; } CefLoadPlugins(IsWow64());  3、QCefWebView，重写ClientApp::RenderDelegate的方法OnContextCreated，完成对象和方法的注册，代码如图3，图中CefMapV8handler是js在调用该接口时的回调类，该类继承自CefV8Handler，我们只需要重写该类中的Execute接口，然后根据参数name来获取js调用的是qt的哪个接口，如图4所示。
4、最后也是最终的部分，我贴上cef库初始化和我自己封装的类文件源代码，当然了，有很大一部分代码也是从网上找的
相关代码如下 cefclient.h如下：
// Initialize CEF.</description>
    </item>
    
    <item>
      <title>AliSQL的编译使用</title>
      <link>http://sotex.github.io/post/2016-10-27-alisql%E7%9A%84%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 27 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-10-27-alisql%E7%9A%84%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/10/27/6004220.html
1、下载源码 git clone https://github.com/alibaba/AliSQL.git  #Linux下编译
2、编译 编译前需要安装好gcc cmake bison等。(如果缺少其他依赖,debian系的可以使用sudo apt-get build-dep mysql-server快速安装)
cd AliSQL # 创建并进入构建目录 make build_linux &amp;amp;&amp;amp; cd build_linux # 生成 makefile cmake -DCMAKE_INSTALL_PREFIX=/home/x/alisql ..	#指定安装路径/home/x/alisql # 编译 make -j4  3、安装使用 make install	# 安装  安装完成后可以进入安装目录下的bin目录
/home/x/alisql/bin [o@o-s] [11:42] &amp;gt; ./mysql_config Usage: ./mysql_config [OPTIONS] Options: --cflags [-I/home/x/alisql/include -g -fabi-version=2 -fno-omit-frame-pointer -fno-strict-aliasing] --cxxflags [-I/home/x/alisql/include -g -fabi-version=2 -fno-omit-frame-pointer -fno-strict-aliasing] --include [-I/home/x/alisql/include] --libs [-L/home/x/alisql/lib -lmysqlclient -lpthread -lm -ldl] --libs_r [-L/home/x/alisql/lib -lmysqlclient -lpthread -lm -ldl] --plugindir [/home/x/alisql/lib/plugin] --socket [/tmp/mysql.</description>
    </item>
    
    <item>
      <title>linux下编译gcc6.2.0</title>
      <link>http://sotex.github.io/post/2016-10-21-linux%E4%B8%8B%E7%BC%96%E8%AF%91gcc6.2.0/</link>
      <pubDate>Fri, 21 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-10-21-linux%E4%B8%8B%E7%BC%96%E8%AF%91gcc6.2.0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/10/21/5984985.html #linux下编译gcc6.2.0 在archlinx的下gcc已经更新到6.2.1了，win10的WSL下还是gcc4.8。官方源没有比较新的版本，于是自己编译使用。
GCC6的几个新特性 GCC 6 现在的默认值是 C++ 14. GCC 6 现在包括 C++ Concepts. C++运行时库现在支持特殊的数学函数 (ISO/IEC 29124:2010) 支持 C++17 的实验功能
##准备 可以去gnu官网下载gcc6.2.0的源码，但国内访问速度比较慢。可以进中科大的镜像站去下载。
下载并解压
wget http://mirrors.ustc.edu.cn/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.bz2 tar -xjvf gcc-6.2.0.tar.bz2  解压之后进入源码目录，运行下面命令下载依赖包
./contrib/download_prerequisites	#必须在源码根目录下运行此命令  编译gcc前需安装build-essential,bison,flex,texinfo。
##生成Makefile 在源码目录下建立一个build目录(也可以在别的目录下)，然后进入build目录运行configure脚本生成Makefile文件。
mkdir build &amp;amp;&amp;amp; cd build ../configure --prefix=/usr/local/gcc6 --enable-checking=release --enable-languages=c,c++ --enable-threads=posix --disable-multilib # --prefix=/usr/local/gcc6	指定安装路径 # --enable-languages=c,c++	支持的编程语言 # --enable-threads=posix	使用POSIX/Unix98作为线程支持库 # --disable-multilib 取消多目标库编译(取消32位库编译)  下面是archlinux自带gcc的编译配置命令（gcc -v查看）。
--prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++ --enable-shared --enable-threads=posix --enable-libmpx --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking=release  如果配置的时候出现cannot find crt1.</description>
    </item>
    
    <item>
      <title>TransmitFile函数的简单使用</title>
      <link>http://sotex.github.io/post/2016-10-14-transmitfile%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 14 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-10-14-transmitfile%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/10/14/5961500.html
简述 TransmitFile是一个扩展的 API，它允许在套接字连接上发送一个打开的文件。这使得应用程序可以避免亲自打开文件，重复地在文件执行读入操作，再将读入的那块数据写入套接字。相反，已打开的文件的句柄和套接字连接一起给出的，在套接字上，文件数据的读入和发送都在模式下进行。这就避免了多次的用户/内核模式切换。与linux的sendfile函数类似。 TransmitFile通过已经连接的SOCKET句柄传输文件，使用操作系统的缓冲管理器来接收数据并提供高质量的文件传输。
https://msdn.microsoft.com/en-us/library/windows/desktop/ms740565(v=vs.85).aspx
参数  hSocket 一个连接的套接字句柄。函数将文件数据写向这个套接字。其必须是面向连接(TCP)的SOCKET。如果hFile为NULL，lpTransmitBuffers将被传输 hFile 已打开的文件句柄。由系统内核读取文件数据，可以通过FILE_FLAG_SEQUENTIAL_SCAN提高处理缓存性能。 nNumberOfBytesToWrite 要传送的字节数。0值表示传送整个文件。发生错误时，以已发送数据为准。 nNumberOfBytesPerSend 每次传送的数据块的大小。0值表示使用SOCKET LAYER的默认值。 lpOverlapped 指向OVERLAPPED结构的指针。如果hSocket以打开重叠(默认)，可指定这个参数，以实现一个重叠IO操作(异步)。NULL值表示不开启overlapped(重叠) I/O模式。 lpTransmitBuffers 指向TRANSMIT_FILE_BUFFERS结构指针。NULL值表示仅仅传输文件。 dwFlags 用于修改TransmitFile函数调用行为的标识。可以包含下表中的定义(在mswscok.h文件中)     标识 含义     TF_DISCONNECT 在所有文件数据已排队等待传输之后，启动传输层断开连接   TF_REUSE_SOCKET 准备要重复使用的socket句柄。 此标志仅在指定了TF_DISCONNECT时有效。
当TransmitFile请求完成时，套接字句柄可以传递到以前用于建立连接的函数调用，例如AcceptEx或ConnectEx。 这种重用是互斥的; 例如，如果为套接字调用了AcceptEx函数，则仅允许重复使用对AcceptEx函数的后续调用，并且不允许对ConnectEx的后续调用。
注意套接字级文件传输受底层传输的行为的影响。 例如，TCP套接字可能受到TCP TIME_WAIT状态的影响，导致TransmitFile调用被延迟。   TF_USE_DEFAULT_WORKER 指示要使用系统的默认线程来处理长 TransmitFile 请求的 Windows 套接字服务提供程序。可以使用以下注册表参数作为 REG_DWORD 调整系统默认线程︰
HKEY_LOCAL_MACHINE\CurrentControlSet\Services\AFD\Parameters\TransmitWorker   TF_USE_SYSTEM_THREAD 指示Windows Sockets服务提供程序使用系统线程来处理长的TransmitFile请求。   TF_USE_KERNEL_APC 指示驱动程序使用内核异步过程调用（APC）而不是工作线程来处理长的TransmitFile请求。 Long TransmitFile请求定义为需要从文件或缓存中进行多次读取的请求; 因此请求取决于文件的大小和发送数据包的指定长度。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11的简单线程池代码阅读</title>
      <link>http://sotex.github.io/post/2016-09-18-c&#43;&#43;11%E7%9A%84%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-18-c&#43;&#43;11%E7%9A%84%E7%AE%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/09/18/5881863.html 这是一个简单的C++11实现的线程池，代码很简单。 原理就是管理一个任务队列和一个工作线程队列。 工作线程不断的从任务队列取任务，然后执行。如果没有任务就等待新任务的到来。添加新任务的时候先添加到任务队列，然后通知任意(条件变量notify_one)一个线程有新的任务来了。
源代码来自https://github.com/progschj/ThreadPool
#ifndef THREAD_POOL_H #define THREAD_POOL_H #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;mutex&amp;gt; #include &amp;lt;condition_variable&amp;gt; #include &amp;lt;future&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;stdexcept&amp;gt; // 线程池类 class ThreadPool { public: // 构造函数，传入线程数 ThreadPool(size_t threads); // 入队任务(传入函数和函数的参数) template&amp;lt;class F, class... Args&amp;gt; auto enqueue(F&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args) -&amp;gt; std::future&amp;lt;typename std::result_of&amp;lt;F(Args...)&amp;gt;::type&amp;gt;; // 一个最简单的函数包装模板可以这样写(C++11)适用于任何函数(变参、成员都可以) // template&amp;lt;class F, class... Args&amp;gt; // auto enqueue(F&amp;amp;&amp;amp; f, Args&amp;amp;&amp;amp;... args) -&amp;gt; decltype(declval&amp;lt;F&amp;gt;()(declval&amp;lt;Args&amp;gt;()...)) // { return f(args.</description>
    </item>
    
    <item>
      <title>TJpgDec使用说明</title>
      <link>http://sotex.github.io/post/2016-09-08-tjpgdec%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-08-tjpgdec%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>#TJpgDec模块应用说明
[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2016/09/08/5852235.html
##怎么使用
首先，你应该构建和运行如下所示示例程序。这是一个典型的使用TJpgDec模块，它有助于调试和缩小问题。
解码会话分为两个阶段。第一阶段是分析JPEG图像，第二阶段是解码。
 初始化输入流。(例如:打开一个文件) 分配JPEG解码对象和工作区域。 调用jd_prepare取分析和准备压缩的JPEG图像。 使用解码对象中的图像信息初始化输出设备。 调用jd_decomp解码JPEG图像。  ##系统结构
##示例
/*------------------------------------------------*/ /* TJpgDec Quick Evaluation Program for PCs */ /*------------------------------------------------*/ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;quot;tjpgd.h&amp;quot; /* 用户定义设备标识 */ typedef struct { FILE *fp; /* 用于输入函数的文件指针 */ BYTE *fbuf; /* 用于输出函数的帧缓冲区的指针 */ UINT wfbuf; /* 帧缓冲区的图像宽度[像素] */ } IODEV; /*------------------------------*/ /* 用户定义input funciton */ /*------------------------------*/ UINT in_func (JDEC* jd, BYTE* buff, UINT nbyte) { IODEV *dev = (IODEV*)jd-&amp;gt;device; /* Device identifier for the session (5th argument of jd_prepare function) */ if (buff) { /* 从输入流读取一字节 */ return (UINT)fread(buff, 1, nbyte, dev-&amp;gt;fp); } else { /* 从输入流移除一字节 */ return fseek(dev-&amp;gt;fp, nbyte, SEEK_CUR) ?</description>
    </item>
    
    <item>
      <title>TJpgDec—轻量级JPEG解码器</title>
      <link>http://sotex.github.io/post/2016-09-07-tjpgdec%E8%BD%BB%E9%87%8F%E7%BA%A7jpeg%E8%A7%A3%E7%A0%81%E5%99%A8/</link>
      <pubDate>Wed, 07 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-07-tjpgdec%E8%BD%BB%E9%87%8F%E7%BA%A7jpeg%E8%A7%A3%E7%A0%81%E5%99%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/09/07/5851505.html #TJpgDec—轻量级JPEG解码器
本文由乌合之众lym瞎编，欢迎转载blog.cnblogs.net/oloroso 下文中解码一词皆由decompression/decompress翻译而来。
TJpgDec是一个为小型嵌入式系统高度优化的创建JPEG图像的解码模块。它工作时占用的内存非常低，以便它可以集成到微控芯片,如AVR, 8051, PIC, Z80, Cortex-M0等。
##特性 - 平台独立。使用ANSI-C编写 - 易于使用的主操作模式 - 完全可重入的体系结构 &amp;gt;Very small memory footprint: - 非常小的内存占用 &amp;gt;独立于图像尺寸的3K工作内存。 &amp;gt;3.5-8.5KB的文本和常数ROM. - 输出格式: &amp;gt;缩放比例:1/1、1/2、1/4或1/8可选。 &amp;gt;像素格式:RGB888或RGB565预配置。
##API接口
有两个函数用于分析和解码JPEG图像。
###jd_prepare
jd_prepare - 准备解码JPEG图像
jd_prepare分析JPEG数据并创建一个解码对象(decompression object)用于随后的解码过程。
JRESULT jd_prepare ( JDEC* jdec, /* Pointer to blank decompression object */ UINT(*infunc)(JDEC*,BYTE*,UINT), /* Pointer to input function */ void* work, /* Pointer to work area */ UINT sz_work, /* Size of the work area */ void* device /* Device identifier for the session */ );  参数</description>
    </item>
    
    <item>
      <title>PPM图片格式及其C读写代码</title>
      <link>http://sotex.github.io/post/2016-09-06-ppm%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6c%E8%AF%BB%E5%86%99%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-06-ppm%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6c%E8%AF%BB%E5%86%99%E4%BB%A3%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/09/06/5846623.html ##PPM图像格式介绍
PPM图像格式是由Jef Poskanzer 大叔，在我出生那一年，也就是1991年所创造的，碰巧的是PPM也是天蝎座。 PPM（Portable Pixmap Format）还有两位兄长，大哥名叫「PBM」，二哥人称「PGM」，他们三兄弟各有所长，下面为你们一一介绍：
 PBM 是位图（bitmap），仅有黑与白，没有灰 PGM 是灰度图（grayscale） PPM 是通过RGB三种颜色显现的图像（pixmaps）  每个图像文件的开头都通过2个字节「magic number」来表明文件格式的类型（PBM, PGM, PPM），以及编码方式（ASCII 或 Binary），magic number分别为P1、P2、P3、P4、P5、P6。
   Magic Number Type Encoding     P1 Bitmap ASCII   P2 Graymap ASCII   P3 Pixmap ASCII   P4 Bitmap Binary   P5 Graymap Binary   P6 Pixmap Binary    ##编码方式 ASCII格式适合人类阅读理解，可以用文本编辑器打开，读取对应图像的数据（比如PPM格式的RGB值）。 Binary格式适合机器阅读，按照二进制形式，顺序存储图像信息，不用空格分隔，所以图像处理起来更有效率，占用空间容量更少（由于缺少空格）。</description>
    </item>
    
    <item>
      <title>linux下vmware的安装、物理分区使用及卸载</title>
      <link>http://sotex.github.io/post/2016-09-06-linux%E4%B8%8Bvmware%E7%9A%84%E5%AE%89%E8%A3%85%E7%89%A9%E7%90%86%E5%88%86%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8D%B8%E8%BD%BD/</link>
      <pubDate>Tue, 06 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-06-linux%E4%B8%8Bvmware%E7%9A%84%E5%AE%89%E8%A3%85%E7%89%A9%E7%90%86%E5%88%86%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8D%B8%E8%BD%BD/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/09/06/5845227.html #1、安装 先下载安装文件VMware-Workstation-Full-12 在命令行下执行下载的文件安装即可(需要root权限)
wget https://download3.vmware.com/software/wkst/file/VMware-Workstation-Full-12.1.1-3770994.x86_64.bundle sudo ./VMware-Workstation-Full-12.1.1-3770994.x86_64.bundle  安装后可尝试使用5F29M-48312-8ZDF9-A8A5K-2AM0Z进行注册。注册的时候可能会提示你输入密码(root密码)。
#2、物理分区的使用 使用物理分区作为虚拟磁盘，需要root权限启动vmware
sudo /usr/bin/vmware  然后新建一个虚拟机，一路下一步，直到选择虚拟磁盘的位置。 在这一步，选择使用物理磁盘，使用这个选择，虚拟机将直接访问本地磁盘。 然后进入下一步，选择你要使用的物理磁盘或者分区。这里右两个选项，要慎重选择。 上面图中的路径，可以使用下面的命令来看都有哪些可选项。
ls /dev/disk/by-id ata-HL-DT-ST_DVD+_-RW_GHB0N_KEJFBBA4742 ata-ST1000DM003-1ER162_W4Y6RQQ7-part2 ata-ST1000DM003-1ER162_W4Y6RQQ7-part6 wwn-0x5000c5008fffdd0f-part2 wwn-0x5000c5008fffdd0f-part6 ata-ST1000DM003-1ER162_W4Y6RQQ7 ata-ST1000DM003-1ER162_W4Y6RQQ7-part3 wwn-0x5000c5008fffdd0f wwn-0x5000c5008fffdd0f-part3 wwn-0x5001480000000000 ata-ST1000DM003-1ER162_W4Y6RQQ7-part1 ata-ST1000DM003-1ER162_W4Y6RQQ7-part5 wwn-0x5000c5008fffdd0f-part1 wwn-0x5000c5008fffdd0f-part5  #3、卸载 卸载比较简单，使用下面命令即可
sudo vmware-installer -u vmware-workstation  卸载需要root权限，默认保留用户配置文件。在卸载界面选择no可以不保留。</description>
    </item>
    
    <item>
      <title>visual stuido 跨解决方案调试</title>
      <link>http://sotex.github.io/post/2016-09-01-visual-stuido-%E8%B7%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%B0%83%E8%AF%95/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-09-01-visual-stuido-%E8%B7%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%B0%83%E8%AF%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/09/01/5829034.html #visual stuido 跨解决方案调试
一个解决方案是一个第三方库，另一个是单独的程序。调试的时候要同时跟踪源码。因为第三方库并没有直接使用它的源码，而是使用生成的dll，直接进行调试比较麻烦，会提示找不到源码。
解决办法如下： 1. 将第三方库和应用程序的生成目录设置为同一个目录(这只是避免每次都要做拷贝工作) 2. 设置应用程序调试的工作目录为生成目录(其实只要第三方库的dll在应用程序的调试工作目录即可) 3. 在应用程序所在的VS中设置断点，在调试的时候，调用到第三方库的接口时候，可以按F11进入，这时候会打开并进入到第三方库的源码中，可以在第三方库的源码上设断点了。</description>
    </item>
    
    <item>
      <title>Proj.4坐标系统创建参数</title>
      <link>http://sotex.github.io/post/2016-08-31-proj.4%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0/</link>
      <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-31-proj.4%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2016/08/31/5826829.html
#Proj.4坐标系统创建参数
本文由乌合之众lym瞎编，欢迎转载blog.cnblogs.net/oloroso
本文原文地址 (https://github.com/OSGeo/proj.4/wiki/GenParms)[https://github.com/OSGeo/proj.4/wiki/GenParms]
grid shift翻译为网格转换
翻译有诸多不妥和错误，请见谅。
这个文档目的是描述所有PROJ.4的参数，可以应用于所有或大多数坐标系统定义。本文档并不试图描述特定于投影类型的特定参数。其中一些可以在GeoTIFF 投影变换列表找到。大多数参数的详细文档是可从 PROJ.4 主页访问
参数列表 通用参数:
(这里包括PROJ.4配置cs2cs和基准面支持)
+a 椭球体长半轴长度 +alpha ? 用于斜墨卡托和其它几个可能的投影 +axis 轴方向 (new in 4.8.0) +b 椭球体短半轴长度 +datum 基准面名(见`proj -ld`) +ellps 椭球体名(见`proj -le`) +k 比例因子(old name) +k_0 比例因子(new name) +lat_0 维度起点 +lat_1 标准平行纬线第一条 +lat_2 标准平行纬线第二条 +lat_ts 有效纬度范围Latitude of true scale +lon_0 中央经线 +lonc ? 经度用于斜墨卡托和其它几个可能的投影 +lon_wrap Center longitude to use for wrapping (见下文) +nadgrids NTv2网格文件的文件名，用于基准面转换(见下文) +no_defs 不要使用/usr/share/proj/proj_def.dat缺省文件 +over 允许经度超出-180到180范围,禁止wrapping (见下文) +pm 备用本初子午线(通常是一个城市的名字，见下文) +proj 投影名(见`proj -l`) +south 表示南半球UTM区域 +to_meter 乘数，转换地图单位为1.</description>
    </item>
    
    <item>
      <title>GCC 编译优化指南(转)</title>
      <link>http://sotex.github.io/post/2016-08-30-gcc-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%E8%BD%AC/</link>
      <pubDate>Tue, 30 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-30-gcc-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%E8%BD%AC/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/30/5822982.html #GCC 编译优化指南(转)
http://www.jinbuguo.com/linux/optimize_guide.html 作者：金步国 版权声明
本文作者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。
无担保：本文作者不保证作品内容准确无误，亦不承担任何由于使用此文档所导致的损失。 自由使用：任何人都可以自由的阅读/链接/打印此文档，无需任何附加条件。 名誉权：任何人都可以自由的转载/引用/再创作此文档，但必须保留作者署名并注明出处。  其他作品
本文作者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：
金步国作品集 [ http://www.jinbuguo.com/ ]  联系方式
由于作者水平有限，因此不能保证作品内容准确无误。如果你发现了作品中的错误(哪怕是错别字也好)，请来信指出，任何提高作品质量的建议我都将虚心接纳。
Email(QQ)：70171448在QQ邮箱  ##前言
网上关于编译优化的文章很多，但大多零零散散，不成体系，本文试图给出一个完整和清晰的优化思路，同时提供在实践中如何进行优化的详尽参考。但是，在介绍所有优化知识之前首先引用LFS-Book中的一句忠告：“使用编译器优化得到的小幅度性能提升，与它带来的风险相比微不足道”。你还要进行优化吗？
%@&amp;amp;#=^%~*# &amp;hellip; OK, crazy guy! Let&amp;rsquo;s Go!!
在继续之前，作者还是奉劝各位：如果追求极致的优化，那么它将是一件既耗时又麻烦的事情，你会陷入无止尽的测试、测试、再测试……另外 Gentoo wiki 上有这么一句话：&amp;rdquo;GCC has well over a hundred individual optimization flags and it would be insane to try and describe them all.&amp;ldquo;所以本文不会涉及全部GCC优化选项。最后作者还是再罗唆一句：优化应当适可而止为好，将精力留出来做一些其它事情会更有意义！
##先决条件
本文的主要读者是 LFS/Gentoo 的玩家，基本上比较 crazy 的玩家都接触过，如果你之前从未使用过 LFS/Gentoo ，请先按照《Linux From Scratch 6.2 中文版》做一遍 LFS ，然后再来阅读此文将会更有意义。另外，本文是建立在《深入理解软件包的配置、编译与安装》一文基础之上的，在开始阅读本文之前，请先阅读它。</description>
    </item>
    
    <item>
      <title>Proj.4 API 中文参考</title>
      <link>http://sotex.github.io/post/2016-08-26-proj.4-api-%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83/</link>
      <pubDate>Fri, 26 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-26-proj.4-api-%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/26/5809884.html #ProjAPI https://github.com/OSGeo/proj.4/wiki/ProjAPI
Tom Kralidis在2015年5月27日编辑此页·修订4
##简介
执行pj_init()选择并初始化一个由它的参数决定参数的制图投影坐标系。argc是argv数组中的元素个数，argv数组每个元素是单个投影的关键字参数(+proj arguments)。该列表中必须包含proj=投影、地球半径或椭圆参数。如果初始化的投影是有效的，返回一个projPJ结构体的地址，失败返回NULL。
pj_init_plus()函数的工作方式与pj_init()类似，但将投影参数定义在单个字符串内，且每个参数带有一个+前缀。例如:+proj=utm +zone=11 +ellps=WGS84。
pj_init()的返回值用作投影正算(forward)或者投影逆算(inverse)中的proj参数。投影计算中的参数结构体projUV中的U代表经度或者x，V代表维度或者y，经度和维度都是以弧度单位的。如果操作失败，projUV中的两个值都设置为HUGE_VAL(在math.h中定义http://blog.csdn.net/poechant/article/details/7235594)。
注意：所有投影都有正算(forward)模式，但却不是都有逆算(inverse)模式。如果投影没有逆算模式，那么projPJ中成员inv将设置为NULL。
pj_transform函数用于转换两个坐标系统之间的点。除了投影坐标与地理坐标之间的转换，也可以进行基准面(datum)之间的转换。不同于pj_fwd()和pj_inv()，这里也允许坐标系定义参数projPJ*是地理坐标(使用+proj=latlong定义)。x、y、z数组用于传入计算值，传出计算结果。该函数成功返回0，失败返回错误号(查看inpj_errno)。
由projection(projPJ)关联的内存，可能需要使用pj_free()释放。
##示例
The following program reads latitude and longitude values in decimal degress, performs Mercator projection with a Clarke 1866 ellipsoid and a 33° latitude of true scale and prints the projected cartesian values in meters:
下面程序读取十进制的经度和维度值，进行克拉克1866椭球正确范围33°维度的墨卡托投影计算，并打印米单位的笛卡尔坐标值。 北美大地基准维基百科
##示例
The following program reads latitude and longitude values in decimal degress, performs Mercator projection with a Clarke 1866 ellipsoid and a 33° latitude of true scale and prints the projected cartesian values in meters:</description>
    </item>
    
    <item>
      <title>proj.4投影变换图示</title>
      <link>http://sotex.github.io/post/2016-08-24-proj.4%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E5%9B%BE%E7%A4%BA/</link>
      <pubDate>Wed, 24 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-24-proj.4%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E5%9B%BE%E7%A4%BA/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/24/5803757.html 赫尔默特变换</description>
    </item>
    
    <item>
      <title>MongoDB_C_Driver使用教程(2)高级连接</title>
      <link>http://sotex.github.io/post/2016-08-20-mongodb_c_driver%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B2%E9%AB%98%E7%BA%A7%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-20-mongodb_c_driver%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B2%E9%AB%98%E7%BA%A7%E8%BF%9E%E6%8E%A5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/20/5790491.html
高级连接(Advanced Connection) 以下指南包含MongoDB配置的特定类型的信息。 简单的连接到独立服务器的示例，请参考MongoDB_C_Dirver使用教程。 要连接到启用身份验证选项的服务器，请参考身份验证页 Authentication page。 原文地址
1、连接到一个副本集(Replica Set) 连接到一个副本集与连接到独立的MongoDB服务器类似。只需要使用?replicaSet=副本集名指定URI的副本集名字选项。
#include &amp;lt;bson.h&amp;gt; #include &amp;lt;mongoc.h&amp;gt; int main (int argc, char *argv[]) { mongoc_client_t *client; /* 初始化libmongoc&#39;s */ mongoc_init (); /* 创建 MongoDB Client连接到副本集 */ client = mongoc_client_new (&amp;quot;mongodb://host01:27017,host02:27017,host03:27017/?replicaSet=myreplset&amp;quot;); /* Do some work */ /* TODO */ /* 清理 */ mongoc_client_destroy (client); mongoc_cleanup (); return 0; }   MongoDB连接字符串URI中可以指定多个主机名(hostname)，使用,分割种子列表(seed list)中的指定的主机。
 更多信息 Advanced Connections
2、连接到分片集群(Sharded Cluster) 连接到分片集群，需要指定client要连接的mongos节点。mongodb c dirver中会自动检查已连接到的mongo分片服务器。 如果指定多个主机名，则种子列表(seed list)的创建将会在mongos实例之间尝试故障转移。 &amp;gt; 连接到分片服务器时，指定replicaSet参数是无效的。</description>
    </item>
    
    <item>
      <title>FreeImage编译及遇到问题解决</title>
      <link>http://sotex.github.io/post/2016-08-16-freeimage%E7%BC%96%E8%AF%91%E5%8F%8A%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-16-freeimage%E7%BC%96%E8%AF%91%E5%8F%8A%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/16/5777959.html #FreeImage编译及遇到问题解决
1、下载freeImage源码包 wget http://downloads.sourceforge.net/freeimage/FreeImage3170.zip #解压 unzip FreeImage3170.zip -d freeImage  2、Linux下编译 编译环境及工具说明 - 操作系统：Ubuntu 16.04 64位，内核版本4.4.0-31 - 编译工具: gcc 5.4 工具链 - 硬件环境:Intel&amp;reg; Core&amp;trade; i5-4460处理器 + 8GB内存
进入freeImage源码目录下，执行make命令。
2.1、类型转换错误 这个问题出现在dcraw_common.cpp这个文件中的4522到4543行之间。 报错信息如下
Source/LibRawLite/./internal/dcraw_common.cpp: 在成员函数‘void LibRaw::vng_interpolate()’中: Source/LibRawLite/./internal/dcraw_common.cpp:4546:3: 错误：在 {} 内将‘128’从‘int’转换为较窄的类型‘signed char’ [-Wnarrowing] }; ^ Source/LibRawLite/./internal/dcraw_common.cpp:4546:3: 错误：在 {} 内将‘136’从‘int’转换为较窄的类型‘signed char’ [-Wnarrowing] Source/LibRawLite/./internal/dcraw_common.cpp:4546:3: 错误：在 {} 内将‘128’从‘int’转换为较窄的类型‘signed char’ [-Wnarrowing] Source/LibRawLite/./internal/dcraw_common.cpp:4546:3: 错误：在 {} 内将‘136’从‘int’转换为较窄的类型‘signed char’ [-Wnarrowing] Source/LibRawLite/./internal/dcraw_common.cpp:4546:3: 错误：在 {} 内将‘128’从‘int’转换为较窄的类型‘signed char’ [-Wnarrowing] Source/LibRawLite/.</description>
    </item>
    
    <item>
      <title>Qt StyleSheet皮肤css源码</title>
      <link>http://sotex.github.io/post/2016-08-16-qt-stylesheet%E7%9A%AE%E8%82%A4css%E6%BA%90%E7%A0%81/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-16-qt-stylesheet%E7%9A%AE%E8%82%A4css%E6%BA%90%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/16/5776787.html 使用方式如下
//设置皮肤样式 static void SetStyle(const QString &amp;amp;styleName) { QFile file(QString(&amp;quot;:/image/%1.css&amp;quot;).arg(styleName)); file.open(QFile::ReadOnly); QString qss = QLatin1String(file.readAll()); qApp-&amp;gt;setStyleSheet(qss); qApp-&amp;gt;setPalette(QPalette(QColor(&amp;quot;#F0F0F0&amp;quot;))); }  参考http://blog.163.com/qimo601@126/blog/static/158220932016311521278/ TestGUI下载
黑色皮肤效果如图 黑色皮肤 QWidget#frmLogin,QWidget#frmPopup,QWidget#frmHostInfo,QWidget#frmLogout,QWidget#frmConfig,QWidget#frmData,QWidget#frmDefence,QWidget#frmHost,QWidget#frmMain,QWidget#frmPwd,QWidget#frmSelect,QWidget#frmMessageBox{ border:1px solid #4D4D4D; border-radius:0px;	} .QFrame{ border:1px solid #636363; border-radius:5px; } QWidget#widget_title{ background: qlineargradient(spread:pad, x1:0, y1:0, x2:0, y2:1, stop:0 #4D4D4D, stop:1 #292929); } QLabel#lab_Ico,QLabel#lab_Title{ border-radius:0px; color: #F0F0F0; background-color:rgba(0,0,0,0); border-style:none; } QLineEdit { border: 1px solid #636363; border-radius: 5px; padding: 2px; background: none; selection-background-color: #4D4D4D; } QLineEdit[echoMode=&amp;quot;2&amp;quot;] { lineedit-password-character: 9679; } .</description>
    </item>
    
    <item>
      <title>linux下编译安装vim7.4并安装clang_complete插件</title>
      <link>http://sotex.github.io/post/2016-08-16-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85vim7.4%E5%B9%B6%E5%AE%89%E8%A3%85clang_complete%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-16-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85vim7.4%E5%B9%B6%E5%AE%89%E8%A3%85clang_complete%E6%8F%92%E4%BB%B6/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/16/5775421.html #linux下编译安装vim7.4并安装clang_complete插件 因为debian里软件仓库中下载安装的vim是不支持python写的插件的(可以打开vim,在命令模式先输入:py测试一下)，导致clang complete插件无法使用，所以需要自己进行编译一个支持python插件的版本。
##1、准备工作 先下载vim7.4源码
#直接使用git克隆 git clone git clone https://github.com/vim/vim.git #下载源码包 wget ftp://ftp.vim.org/pub/vim/unix/vim-7.4.tar.bz2 tar -xjvf vim-7.4.tar.bz2  因为编译起还需要python-dev包的支持，所以先安装一下。
sudo apt install python-dev python3-dev  ##2、生成Makefile并编译 执行configure程序，生成Makefile文件
./configure --prefix=/home/xxx/programs/vim74 --enable-pythoninterp --enable-python3interp --enable-gui=no --enable-cscope --enable-multibyte --enable-fontset  生成Makefile成功后，执行make命令进行编译。编译完成之后，执行make install进行安装。 安装完成后可以进入/home/xxx/programs/vim74查看(安装目录是前面&amp;ndash;prefix参数指定的)。
如果你之前已经使用apt安装了vim，可以将/usr/bin/vim这个软链接删除，然后再创建一个新的过去。
# 查看一下vim这个命令 $ ls -l /usr/bin/vim lrwxrwxrwx 1 root root 21 8月 12 22:14 /usr/bin/vim -&amp;gt; /etc/alternatives/vim # 修改这个软链接 sudo rm -f /usr/bin/vim sudo ln -s home/xxx/programs/vim74/bin/vim /usr/bin/vim # 如果你习惯用vi，也可以一并修改了 sudo rm -f /usr/bin/vi sudo ln -s home/xxx/programs/vim74/bin/vim /usr/bin/vi  可以使用下面命令，简单的全修改掉</description>
    </item>
    
    <item>
      <title>Qt5.7中使用MySQL Driver</title>
      <link>http://sotex.github.io/post/2016-08-12-qt5.7%E4%B8%AD%E4%BD%BF%E7%94%A8mysql-driver/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-12-qt5.7%E4%B8%AD%E4%BD%BF%E7%94%A8mysql-driver/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/12/5766068.html #Qt5.7中使用MySQL Driver
##1、使用环境 Qt5.7的安装安装就已经带了MySQL Driver，只需要在安装的时候选择一下即可。 如果没有安装，可以采取自己编译的方式。 在Qt的源码包的qtbase\src\sql\drivers\mysql路径下，就是相关的源码文件。 这里就不说编译方式了。只是要记得在编译的时候，需要libmysql的支持。
##2、基本使用
QSqlError err; // 数据库对象创建 QSqlDatabase db = QSqlDatabase::addDatabase(&amp;quot;MYSQL&amp;quot;,&amp;quot;连接名&amp;quot;); // 设置相关参数 db.setDatabaseName(&amp;quot;数据库名&amp;quot;); // 需要与数据库中的一致 db.setHostName(&amp;quot;127.0.0.1&amp;quot;); // 主机名(地址) db.setPort(3366); // 端口 // 打开数据库 if (!db.open(&amp;quot;用户名&amp;quot;, &amp;quot;密码&amp;quot;)) { err = db.lastError(); db = QSqlDatabase(); QSqlDatabase::removeDatabase(&amp;quot;连接名&amp;quot;); } // Query对象创建 QSqlQuery q(&amp;quot;&amp;quot;, db); // 创建一个表 q.exec(&amp;quot;create table Names (id integer primary key, Firstname varchar, Lastname varchar, City varchar)&amp;quot;); // 插入三条数据 q.exec(&amp;quot;insert into Names values (1, &#39;Christopher&#39;, &#39;Walker&#39;, &#39;Morristown&#39;)&amp;quot;); q.</description>
    </item>
    
    <item>
      <title>PROJ4初探(转并整理格式)</title>
      <link>http://sotex.github.io/post/2016-08-08-proj4%E5%88%9D%E6%8E%A2%E8%BD%AC%E5%B9%B6%E6%95%B4%E7%90%86%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-08-proj4%E5%88%9D%E6%8E%A2%E8%BD%AC%E5%B9%B6%E6%95%B4%E7%90%86%E6%A0%BC%E5%BC%8F/</guid>
      <description>#PROJ4初探(转并整理格式)
Proj4是一个免费的GIS工具，软件还称不上。 它专注于地图投影的表达，以及转换。采用一种非常简单明了的投影表达－－PROJ4，比其它的投影定义简单，但很明显。很容易就能看到各种地理坐标系和地 图投影的参数，同时它强大的投影转换功能，也是非常吸引人的。许多的 GIS软件中也将其集成在内。Proj可以在 window的命令下有可运行的 EXE文件，其实它更主要的是一个库！可以用来编一些批处理。在 Linux下除了可以直接运行外，还可以作为库来进行更高功能的开发。
[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2016/08/08/5749057.html
#1 安装 Window下安装: 从Proj4的网站下载安装文件，解压缩，把路径加到环境变量里即可。具体操作步骤在解压后的README有详细说明。 Ubuntu Linux下安装: 可以在终端输入：
sudo apt -get install proj  Fedora Linux 下安装: 可以在终端输入：
su -c &#39;yum install proj&#39;  #2 快速开始 在终端或 DOSshell下可以输入（带$的为向终端里输入的命令）：
$proj Rel. 4.6.0, 21 Dec 2007 usage: proj [-beEfiIlormsStTvVwW [args]] [+opts[=arg]] [files]  会显示出 proj的用法。包括参数设置，可选项，和输入文件。
##2.1 显示参数 对于作地图和 GIS工作者来说投影可谓是一切的基础，投影的正确与否将关第到最终结果正确与否。在 proj里边集成了，许多的制作地图用的投影参数。我们可以使用下边的命令来显示在 proj里的内置的有关地图投影的参数。显示投影类型：
$proj -l aea: Albers Equal Area aeqd: Azimuthal Equidistant ... ... .</description>
    </item>
    
    <item>
      <title>Qt应用程序图标设置</title>
      <link>http://sotex.github.io/post/2016-08-05-qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-05-qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/05/5740417.html #Qt应用程序图标设置
本文仅仅适用于windows下，linux等不适用。 下面说的图标，指的是程序文件的图标，而不是托盘图标或者说运行时任务栏的图标（任务栏和程序窗口的图标在windows/linux下皆有效）。
##1、添加图标文件 - 要给程序设置图标，首先得有一个图标文件。这里假设使用app.ico。 - 将app.ico放入工程目录下，这里假设存放位置为image/app.ico。
 然后新建一个文本文件(这里假设文件名为appico.rc)，填入以下内容
IDI_ICON1	ICON	DISCARDABLE	&amp;quot;image/app.ico&amp;quot;   ##2、修改Qt工程文件 这里需要修改一下.pro文件。 打开.pro文件，然后在最后添加以下内容
unix:{ DISTFILES	+= appico.rc	# 就是前面说的文本文件 } win32:{ RC_FILE	+= appico.rc }  ##3、重新生成程序 完成上面两部之后，重新执行一下qmake，然后编译生成就可以看到新生成的程序是带有图标的。</description>
    </item>
    
    <item>
      <title>mongo-c-driver使用VS2013编译</title>
      <link>http://sotex.github.io/post/2016-08-05-mongo-c-driver%E4%BD%BF%E7%94%A8vs2013%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-05-mongo-c-driver%E4%BD%BF%E7%94%A8vs2013%E7%BC%96%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/08/05/5740431.html #1、下载mongo-c-driver源码文件
使用github来下载。
git clone https://github.com/mongodb/mongo-c-driver.git  下载完之后，进入src/libbson目录下，下载`libbson的源码。
git clone https://github.com/mongodb/libbson.git .  编译后的文件可以在这里下载 mongo-c-driver-win32-bin.7z mongo-c-driver-win64-bin.7z
#2、编译libbson 这里先需要使用cmake工具来生成VS2013的项目文件。如果没有安装cmake，请先安装。 进入mongo-c-driver/src/libbson目录，打开命令行窗口，执行以下命令：
mkdir msvc12 # 建立VS2013项目文件输出路径 cd msvc12 # 进入该路径 cmake -DCMAKE_INSTALL_PREFIX=D:\work_code\mongo-c-driver\usr -G &amp;quot;Visual Studio 12 Win64&amp;quot; ..  上面最后一条命令中的D:\work_code\mongo-c-driver\usr表示的是生成的VS项目中INSTALL.vcxproj这个项目的生成输出路径，也就是libbson编译后的库文件和头文件的输出路径。 Win64指定项目编译输出的将是64位的库。可以不加此参数，则为32位的库。
执行完上面的命令后，可以使用如下命令来编译和安装：
msbuild ALL_BUILD.vcxproj # 编译 msbuild INSTALL.vcxproj # 安装  上面两个命令需要在VS2013 开发人员命令提示下运行。（默认生成的是Debug版本） 如果觉得这样麻烦，你也可以直接使用VS2013打开msvc12目录下的libbson.sln文件，然后依次生成ALL_BUILD和INSTALL项目。 如果需要生成32位版本的，也可以在这里直接新建解决方案平台。 编译后输出的结果如下图
#3、编译mongo-c-driver 这里的过程和上面差不多。 先回到mongo-c-driver目录下，执行下面命令：
mkdir msvc12 &amp;amp;&amp;amp; cd msvc12 cmake -DCMAKE_INSTALL_PREFIX=D:\work_code\mongo-c-driver\usr -DBSON_ROOT_DIR=D:\work_code\mongo-c-driver\usr -G &amp;quot;Visual Studio 12 Win64&amp;quot; .</description>
    </item>
    
    <item>
      <title>MongoDB C Driver使用教程</title>
      <link>http://sotex.github.io/post/2016-08-03-mongodb-c-driver%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-08-03-mongodb-c-driver%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
      <description>#MongoDB C Driver使用教程
转载请注明出处http://www.cnblogs.com/oloroso/
本指南提供简介 MongoDB C 驱动程序。 在 C API 的详细信息，请参阅API 文档. 原文来自http://api.mongodb.com/c/current/tutorial.html
[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2016/08/03/5733083.html
##0.安装
有关特定的平台上安装MongoDB C驱动程序的详细说明，请参阅安装指南.
MongoDB C 驱动程序的安装 编译 http://www.cnblogs.com/oloroso/p/5740431.html
##1.启动MongoDB
要运行本教程中的例子，MongoDB 必须安装运行在本地主机(localhost)，且使用默认端口27017。要检查MongoDB是否启动并运行，使用MongoDB Shell连接就知道了。
$ mongo --host localhost --port 27017 MongoDB shell version: 3.0.6 connecting to: localhost:27017/test &amp;gt;  ##2.进行连接
MongoDB C Driver程序通过mongoc_client_t提供了一种简便的访问MongoDB的方法（ 与集群配置无关的）。 它满足透明地连接到独立的服务器，副本集和分片集群上的需求。一旦建立了连接，数据库和集合的句柄可以通过结构mongoc_database_t和mongoc_collection_t分别得到。然后可以通过这些句柄执行MongoDB操作。
在应用程序的启动后，先调用mongoc_init()，libmongoc 的任何其他功能才能正确使用，并需要在退出之前调用mongoc_cleanup()。当创建client、database和server的句柄后，需要在使用完后调用适当的销毁函数。
下面的示例建立一个独立的服务器上的本地主机的连接，并执行一个简单的命令。有关数据库操作的详细信息可以查看CRUD 操作和执行命令部分。连接到副本集和分片集群的例子可以在高级连接页面查看。
connect.c
#include &amp;lt;bson.h&amp;gt; #include &amp;lt;bcon.h&amp;gt; #include &amp;lt;mongoc.h&amp;gt; int main (int argc, char *argv[]) { mongoc_client_t *client; mongoc_database_t *database; mongoc_collection_t *collection; bson_t *command, reply, *insert; bson_error_t error; char *str; bool retval; /* * 初始化libmongoc&#39;s */ mongoc_init (); /* * 创建一个新的client实例 */ client = mongoc_client_new (&amp;quot;mongodb://localhost:27017&amp;quot;); /* * 获取数据库&amp;quot;db_name&amp;quot;和集合&amp;quot;coll_name&amp;quot;的句柄 */ database = mongoc_client_get_database (client, &amp;quot;db_name&amp;quot;); collection = mongoc_client_get_collection (client, &amp;quot;db_name&amp;quot;, &amp;quot;coll_name&amp;quot;); /* * 执行操作。此处以执行ping数据库，以json格式打印结果。并执行一个插入操作。 */ // 执行命令操作(ping) command = BCON_NEW (&amp;quot;ping&amp;quot;, BCON_INT32 (1)); retval = mongoc_client_command_simple (client, &amp;quot;admin&amp;quot;, command, NULL, &amp;amp;reply, &amp;amp;error); if (!</description>
    </item>
    
    <item>
      <title>OpenCV 2.4.13 编译使用(VS2015下)</title>
      <link>http://sotex.github.io/post/2016-07-20-opencv-2.4.13-%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8vs2015%E4%B8%8B/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-07-20-opencv-2.4.13-%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8vs2015%E4%B8%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/07/20/5689987.html #OpenCV2.4.13编译(VS2015)
这里给出已经编译好的的下载路径。包括Win64的debug和release版本。 OpenCV for MSVC14 Win64
##1、下载OpenCV源码 这里不啰嗦了，直接给出下载链接。
OpenCV for windows
这个是windows版的下载链接，下载之后进行解压。
进入sources目录，这就是OpenCV的源码目录。
##2、使用CMake生成VS工程 在源码目录里面新建一个目录build_msvc14，然后进入这个目录。 打开命令行窗口，使用下面的命令来生成工程。
cmake -DCMAKE_CONFIGURATION_TYPES=Release -DCMAKE_VERBOSE=Yes -DWITH_QT=Yes -DCMAKE_INSTALL_PREFIX=D:\OpenCV -G &amp;quot;Visual Studio 14 Win64&amp;quot; ..  -DCMAKE_CONFIGURATION_TYPES=Release 编译Release版本 -DCMAKE_VERBOSE=Yes -DWITH_QT=Yes QtGUI支持 -DCMAKE_INSTALL_PREFIX=D:\OpenCV 安装路径  这里实际编译的是Debug版本。 使用VS2015开发人员命令提示环境进入build_msvc14目录，执行以下命令进行编译安装。
msbuild ALL_BUILD.vcxproj #编译Debug版本(可以添加/property:Configuration=&amp;quot;Release&amp;quot;参数编译Release版本) msbuild INSTALL.vcxproj #安装(若编译release版本，这里安装的时候也要添加上面的参数)  安装完成后，进入之前指定的D:\OpenCV目录即可看到编译后的输出文件。
##测试一下
打开VS2015新建一个空项目，添加一个新文件main.cpp。输入以下代码
#include &amp;lt;iostream&amp;gt; #include &amp;quot;opencv2/opencv.hpp&amp;quot; using namespace std; int main() { // 加载图片 cv::Mat img = cv::imread(&amp;quot;D:\\OpenCV\\doc\\opencv-logo2.png&amp;quot;); if (img.empty()) { cerr &amp;lt;&amp;lt; &amp;quot;open image failed!</description>
    </item>
    
    <item>
      <title>Proj.4库的编译及使用</title>
      <link>http://sotex.github.io/post/2016-07-15-proj.4%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-07-15-proj.4%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/07/15/5672837.html #Proj.4库的编译及使用
Proj.4是开源GIS最著名的地图投影库，GRASS GIS, MapServer, PostGIS, Thuban, OGDI, Mapnik, TopoCad, GDAL/OGR等软件的投影都直接或间接的使用Proj.4。 Proj.4的功能主要有经纬度坐标与地理坐标的转换，坐标系的转换，包括基准变换等，下面以命令行方式和编程方式来说明经纬度坐标与地理坐标转换功能的使用。
##Proj.4的下载和编译
使用git进行下载。
git clone https://github.com/OSGeo/proj.4.git  ###Linux下的编译和安装
下载之后，使用cmake生成Makefile进行编译。
mkdir -p build &amp;amp;&amp;amp;cd build	#进入proj.4工程目录后，创建一个构建目录，并进入 # 使用cmake生成Makefile,指定安装路径和生成库类型为静态库 cmake -DCMAKE_INSTALL_PREFIX=./install -DBUILD_LIBPROJ_SHARED=OFF .. # 编译 make # 安装，安装的目录是之前指定的目录，就是当前目录下的install目录 make install  安装完成之后进入install目录，可以看到对应的头文件和库文件。
&amp;gt; tree . ├── bin │ ├── cs2cs │ ├── geod │ ├── nad2bin │ └── proj ├── include │ ├── geodesic.h │ ├── proj_api.h │ └── projects.</description>
    </item>
    
    <item>
      <title>VS2013编译Qt5.6.0静态库</title>
      <link>http://sotex.github.io/post/2016-06-12-vs2013%E7%BC%96%E8%AF%91qt5.6.0%E9%9D%99%E6%80%81%E5%BA%93/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-06-12-vs2013%E7%BC%96%E8%AF%91qt5.6.0%E9%9D%99%E6%80%81%E5%BA%93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/06/12/5577888.html ##获取qt5.6.0源码包
直接去www.qt.io下载就好了，这里就不详细说了。
这里是我已经编译好的** 链接:http://pan.baidu.com/s/1pLb6wVT 密码: ak7y **
##configure配置
1、进入源码目录下的qtbase\mkspecs\win32-msvc2013目录，打开文件qmake.conf文件。添加
QMAKE_CFLAGS_RELEASE = -O2 -MT -Zc:strictStrings QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -O2 -MT -Zi -Zc:strictStrings QMAKE_CFLAGS_DEBUG = -Zi -MTd  上面其实不做也可以，我就没有做。
2、进入解压后的源码目录，打开命令行界面，执行
configure -prefix 安装目录 -platform win32-msvc2013 -opensource -release -static -qt-sql-sqlite -qt-sql-mysql -qt-zlib -qt-libjpeg -qt-libpng -skip qtquickcontrols -skip qtquickcontrols2 -skip qtsensors -skip qtdoc -confirm-license -c++std c++11  详细的配置选项可以看这里http://www.cnblogs.com/oloroso/p/5407779.html
2016年11月24日 11:42:31 做个备注，这个地址http://www.npcglib.org/~stathis/blog/precompiled-qt4-qt5/有更多下载。
##编译与安装 执行configure成功后，会提示运行nmake。 打开VS2013安装目录下的\Common7\Tools\Shortcuts目录，双击执行VS2013 x64 本机工具命令提示。 切换工作目录到Qt5.6.0的源码目录，执行nmake。
##问题与解决办法
下面问题出现的时候，由于我没有记录下报错信息，所以只能靠自己的记忆来描述了。
问题1：找不到编译生成的.obj 这是在编译qtimageformats模块的时候出现的问题。由于编译时指定的生成路径太长，文件无法写入导致的。打开qt5.6.0源码目录下的qtimageformats\src\imageformats\Makefile.release文件，将生成路径中的.obj\release\qt...省略很多级目录...改为一个比较短的路径。
问题2：编译adueditor时，链接出现的重定义问题 打开文件qtserialbus\examples\serialbus\modbus\adueditor\mainwindow.</description>
    </item>
    
    <item>
      <title>6个变态的C语言Hello World程序</title>
      <link>http://sotex.github.io/post/2016-06-01-6%E4%B8%AA%E5%8F%98%E6%80%81%E7%9A%84c%E8%AF%AD%E8%A8%80hello-world%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 01 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-06-01-6%E4%B8%AA%E5%8F%98%E6%80%81%E7%9A%84c%E8%AF%AD%E8%A8%80hello-world%E7%A8%8B%E5%BA%8F/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/06/01/5549400.html 6个变态的C语言Hello World程序 &amp;nbsp; 下面的六个程序片段主要完成这些事情：
输出Hello, World 混乱C语言的源代码  下面的所有程序都可以在GCC下编译通过，只有最后一个需要动用C++的编译器g++才能编程通过。
hello1.c
1 2 3 4 5 6 7 8 9 10 11  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define _________ } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define ________ putchar &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define _______ main &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define _(a) ________(a); &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define ______ _______(){ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define __ ______ (0x48)(0x65)(0x6C)(0x6C) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define ___ (0x6F)(0x2C)(0x20)(0x77)_(0x6F) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define ____ (0x72)(0x6C)(0x64)(0x21) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#define _____ __ ___ ____ ______ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#include&amp;lt;stdio.h&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;__        &amp;nbsp;
hello2.c&amp;nbsp;
1 2 3 4 5 6 7 8 9  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#include&amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>C语言中史上最愚蠢的Bug</title>
      <link>http://sotex.github.io/post/2016-06-01-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%84%9A%E8%A0%A2%E7%9A%84bug/</link>
      <pubDate>Wed, 01 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-06-01-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%84%9A%E8%A0%A2%E7%9A%84bug/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/06/01/5549393.html C语言中史上最愚蠢的Bug &amp;nbsp; 本文来自&amp;ldquo;The most stupid C bug ever&amp;rdquo;，很有意思，分享给大家。我相信这样的bug，就算你是高手你也会犯的。你来看看作者犯的这个Bug吧。。
首先，作者想用一段程序来创建一个文件，如果有文件名的话，就创建真正的文件，如果没有的话，就调用?tmpfile()?创建临时文件。他这段程序就是HTTP下载的C程序。code==200就是HTTP的返回码。
1 2 3 4  else if (code == 200) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Downloading whole file &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/* Write new file (plus allow reading once we finish) / &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g = fname ? fopen(fname, &amp;ldquo;w+&amp;rdquo;) : tmpfile(); }        但是这个程序，只能在Unix/Linux下工作，因为 Microsoft 的?tmpfile()的实现?居然选择了 C:\ 作为临时文件的存放目录，这对于那些没有管理员权限的人来说就出大问题了，在Windows 7下，就算你有管理员权限也会有问题。所以，上面的程序在Windows平台下需要用不同的方式来处理，不能直接使用Windows的tmpfile()函数。
于是作者就先把这个问题记下来，在注释中写下了FIXME：
1 2 3 4 5 6 7  else if (code == 200) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; // Downloading whole file &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/ Write new file (plus allow reading once we finish) / &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// FIXME Win32 native version fails here because &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp; Microsoft&amp;rsquo;s version of tmpfile() creates the file in C:&amp;lt;/code&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;g = fname ?</description>
    </item>
    
    <item>
      <title>SQLite返回码</title>
      <link>http://sotex.github.io/post/2016-05-19-sqlite%E8%BF%94%E5%9B%9E%E7%A0%81/</link>
      <pubDate>Thu, 19 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-05-19-sqlite%E8%BF%94%E5%9B%9E%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/05/19/5508221.html #SQLite返回码
##返回码含义
   宏 值 含义     SQLITE_OK 0 返回成功   SQLITE_ERROR 1 SQL错误或数据库不存在   SQLITE_INTERNAL 2 SQLite内部逻辑错误   SQLITE_PERM 3 拒绝访问   SQLITE_ABORT 4 回调函数请求中止   SQLITE_BUSY 5 数据库文件被锁   SQLITE_LOCKED 6 数据库中的一个表被锁   SQLITE_NOMEM 7 malloc()分配内存失败   SQLITE_READONLY 8 试图对只读数据库进行写操作   SQLITE_INTERRUPT 9 操作被sqlie3_interrupt()中止   SQLITE_IOERR 10 磁盘I/O发生错误   SQLITE_CORRUPT 11 数据库磁盘映像格式不正确   SQLITE_NOTFOUND 12 (Internal Only)表或记录不存在</description>
    </item>
    
    <item>
      <title>VS2013 预定义的宏</title>
      <link>http://sotex.github.io/post/2016-05-18-vs2013-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F/</link>
      <pubDate>Wed, 18 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-05-18-vs2013-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/05/18/5506097.html Visual Studio 2013&amp;nbsp;预定义的宏 https://msdn.microsoft.com/zh-cn/library/b0084kay(v=vs.120).aspx  列出预定义的 ANSI/ISO C99 和 Microsoft C++ 实现预处理宏。
 编译器识别预定义的 ANSI/ISO C99 C 预处理宏，Microsoft C++ 实现将提供更多宏。&amp;nbsp;这些预处理器宏不带参数，并且不能重新定义。&amp;nbsp;本文中所列的一些预定义宏用多个值进行定义。
ANSI 兼容的预定义宏    宏
 说明
  DATE
 当前源文件的编译日期。&amp;nbsp;该日期是&amp;nbsp;Mmm dd yyyy&amp;nbsp;形式的字符串文本。&amp;nbsp;月份名称&amp;nbsp;Mmm&amp;nbsp;与 TIME.H 中声明的&amp;nbsp;asctime&amp;nbsp;库函数生成的日期相同。
   FILE
 当前源文件的名称。&amp;nbsp;FILE&amp;nbsp;扩展到字符串文本。&amp;nbsp;若要确保显示文件的完整路径，请使用&amp;nbsp;/FC（所诊断源代码文件的完整路径）。
   func
 以 char 数组形式返回封闭函数的未限定和未修饰名称。
&amp;nbsp; &amp;nbsp;  void Foo(){ printf(&amp;ldquo;%s\n&amp;rdquo;, func); } // prints &amp;ldquo;Foo&amp;rdquo;         LINE</description>
    </item>
    
    <item>
      <title>微型Http服务器Tiny Http Server</title>
      <link>http://sotex.github.io/post/2016-05-05-%E5%BE%AE%E5%9E%8Bhttp%E6%9C%8D%E5%8A%A1%E5%99%A8tiny-http-server/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-05-05-%E5%BE%AE%E5%9E%8Bhttp%E6%9C%8D%E5%8A%A1%E5%99%A8tiny-http-server/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/05/05/5462878.html #Tiny Http Server 一个简单的跨平台Http服务器．服务器部分使用了Mongoose的代码，界面是使用ＱＴ开发的． 开发为了在临时需要使用一个http服务器来做发布代码文档的时候，不用去安装apache等大块头．又因为网上的一些迷你型的webserver又多是只支持windowns的．所以干脆自己做一个．
本来向自己写一个http Server的，看了tinyhttp的代码，决定功能太弱了．又发现了Mongoose这个东西，看起来还不错，也简单好用，就拿过来先用了．
在实现的时候没有考虑多进程实例的情况，这个毕竟只是一个小玩具．
下载地址：https://git.oschina.net/oloroso/TinyHttpServer.git
运行如图 </description>
    </item>
    
    <item>
      <title>tinyhttp源码阅读(注释)</title>
      <link>http://sotex.github.io/post/2016-05-04-tinyhttp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Wed, 04 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-05-04-tinyhttp%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%B3%A8%E9%87%8A/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/05/04/5459196.html 这里就不细述了,代码很简单. 其实现的功能比较若,可以做一个参考. 因为其通过文件的权限位来判断是否是一个CGI脚本,所以在权限位不对的情况下会判断不正确.例如我将这个目录放置在NTFS分区,所有的文件都有可执行权限,会导致将index.html文件当做CGI脚本.
注释后的文件在这里下载http://files.cnblogs.com/files/oloroso/tinyhttpd-0.1.0.tar.7z
/* J. David&#39;s webserver */ /* This is a simple webserver. * Created November 1999 by J. David Blackstone. * CSE 4344 (Network concepts), Prof. Zeigler * University of Texas at Arlington */ /* This program compiles for Sparc Solaris 2.6. * To compile for Linux: * 1) Comment out the #include &amp;lt;pthread.h&amp;gt; line. * 2) Comment out the line that defines the variable newthread.</description>
    </item>
    
    <item>
      <title>BSON 1.0版本规范(翻译)</title>
      <link>http://sotex.github.io/post/2016-04-25-bson-1.0%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-04-25-bson-1.0%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/04/25/5431684.html #BSON 1.0版本规范
本文翻译自 http://bsonspec.org/spec.html
BSON是用于存储零个或多个键/值对为一个单一的实体的一个二进制格式。我们称这个实体为文档(Document)。 以下语法用于指定BSON标准的1.0版本。我们使用伪BNF语法来(编写)描述。有效数据BSON数据是由非终端显示的文档表示的。
##基本类型 以下基本类型用作终端中其余的语法。每种类型必须序列化为小端字节序。
   类型 内存宽度 描述     byte 1 byte (8-bits)   int32 4 bytes (32-bit 有符号整数，补码表示)   int64 8 bytes (64-bit 有符号整数，补码表示)   double 8 bytes (64-bit IEEE 754-2008 二进制浮点数)    ##非终端
下面指定BSON的其他语法。注意，终端引用字符的表示，应该用C语言的语义来理解(例如：&amp;quot;\x01&amp;quot;代表的一个字节，二进制表示为0000 0001)。 同时，我们使用操作法*来速记重复的部分(例如：(&amp;quot;\x01&amp;quot;*2)表示的是&amp;quot;\x01\x01&amp;quot;)。当作为一元运算符，*表示重复出现0次或以上。
document ::=	int32 e_list &amp;quot;\x00&amp;quot;	BSON 文档. int32表示的是组成这个文档的总字节数. e_list ::=	element e_list	|	&amp;quot;&amp;quot;	element ::= &amp;quot;\x01&amp;quot; e_name double 64-bit二进制浮点数 |	&amp;quot;\x02&amp;quot; e_name string UTF-8 字符串 |	&amp;quot;\x03&amp;quot; e_name document 内嵌文档 |	&amp;quot;\x04&amp;quot; e_name document 数组 |	&amp;quot;\x05&amp;quot; e_name binary 二进制数据 |	&amp;quot;\x06&amp;quot; e_name 未定义(value) — 不推荐使用 |	&amp;quot;\x07&amp;quot; e_name (byte*12)	对象Id |	&amp;quot;\x08&amp;quot; e_name &amp;quot;\x00&amp;quot;	布尔值 &amp;quot;false&amp;quot; |	&amp;quot;\x08&amp;quot; e_name &amp;quot;\x01&amp;quot;	布尔值 &amp;quot;true&amp;quot; |	&amp;quot;\x09&amp;quot; e_name int64 UTC 时间数据 |	&amp;quot;\x0A&amp;quot; e_name Null value(空值) |	&amp;quot;\x0B&amp;quot; e_name cstring cstring	正则表达式 - 第一个 cstring 是正则表达式模式, 第二个是正则表达式选项字符串.</description>
    </item>
    
    <item>
      <title>linux下编译qt5.6.0静态库——configure配置</title>
      <link>http://sotex.github.io/post/2016-04-19-linux%E4%B8%8B%E7%BC%96%E8%AF%91qt5.6.0%E9%9D%99%E6%80%81%E5%BA%93configure%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-04-19-linux%E4%B8%8B%E7%BC%96%E8%AF%91qt5.6.0%E9%9D%99%E6%80%81%E5%BA%93configure%E9%85%8D%E7%BD%AE/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/04/19/5407779.html linux下编译qt5.6.0静态库  linux下编译qt5.6.0静态库  configure生成makefile  安装选项 Configure选项 第三方库: 附加选项: QNX/Blackberry 选项: Android 选项: 生成makefile  遇到链接检查失败的情况 生成makefile后进行编译     编译时的错误  多重定义&amp;rsquo;QT_MODBUS()&amp;rsquo;和&amp;rsquo;QT_MODBUS_LOW()&amp;rsquo; qt_static_plugin_AssimpParserPlugin未定义   在Qt Creator中使用编译出的QT库  具体过程如图       编译QT是一件比较麻烦的事情。所以如果没有必要，就不要编译了。如果你只需要使用QT的一些基本功能，那么就只编译源码目录下的qtbase目录下的东西即可。
下面所介绍的都只是在linux下适用的(windows下使用MinGW也可以，QT提供的MinGW安装包是32位的，需要64位的可以参考)。
在编译前，最好先安装完成相关的依赖包，主要是xcb/opengl等。编译器使用gcc5及以上版本速度会比较快。i5-4460 CPU @ 3.20GHz+8G内存下编译时间大概是2.5个小时。
编译的时候对磁盘空间要求非常非常的大75G ./qt-src/qt-opensource-src-5.6.0(这是还没有完全编译完时候的情况)，如果无法接受，就别编译debug版本和examples了。
提供一个我已经编译好的了
linux下64位gcc编译
http://pan.baidu.com/s/1eRMnf26&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 提取密码&amp;nbsp;&amp;nbsp;&amp;nbsp; iz39
windows下64位mingw编译
http://pan.baidu.com/s/1qYh7yGG &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 提取密码&amp;nbsp;&amp;nbsp;&amp;nbsp; 6bur
&amp;nbsp;
因为编译的时候，安装路径已经硬编码到了qmake中(使用strings qmake|grep qt_来查看)。
所以如果改变了安装的目录，需要到安装目录下的bin目录下创建文件qt.conf，其内容如下：
[Paths] Prefix = 安装路径  首先下载源码包qt-everywhere-opensource-src-5.6.0.7z</description>
    </item>
    
    <item>
      <title>linux mount命令参数及用法详解</title>
      <link>http://sotex.github.io/post/2016-04-18-linux-mount%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-04-18-linux-mount%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/04/18/5405099.html linux mount命令参数及用法详解 非原创，主要来自
http://www.360doc.com/content/13/0608/14/12600778_291501907.shtml。
http://yan0063.iteye.com/blog/1610194
使用说明 功能：加载指定的文件系统。
语法：mount [-afFhnrvVw] [-L&amp;lt;标签&amp;gt;] [-o&amp;lt;选项&amp;gt;] [-t&amp;lt;文件系统类型&amp;gt;] [设备名] [加载点]
用法说明：mount可将指定设备中指定的文件系统加载到Linux目录下（也就是装载点）。可将经常使用的设备写入文件/etc/fastab,以使系统在每次启动时自动加载。mount加载设备的信息记录在/etc/mtab文件中。使用umount命令卸载设备时，记录将被清除。
常用参数和选项：
参数说明   参数说明 
   -a 加载文件/etc/fstab中设置的所有设备。
  -f 不实际加载设备。可与-v等参数同时使用以查看mount的执行过程。
  -F 需与-a参数同时使用。所有在/etc/fstab中设置的设备会被同时加载，可加快执行速度。
  -h 显示在线帮助信息。
  -L &amp;lt;标签&amp;gt; 加载文件系统标签为&amp;lt;标签&amp;gt;的设备。
  -n 不将加载信息记录在/etc/mtab文件中。
  -o &amp;lt;选项&amp;gt; 指定加载文件系统时的选项。有些选项也可在/etc/fstab中使用。这些选项包括：
  -o　async 以非同步的方式执行文件系统的输入输出动作。
  -o　atime 每次存取都更新inode的存取时间，默认设置，取消选项为noatime。
  -o　auto 必须在/etc/fstab文件中指定此选项。执行-a参数时，会加载设置为auto的设备，取消选取为noauto。</description>
    </item>
    
    <item>
      <title>linux下的/dev/shm目录</title>
      <link>http://sotex.github.io/post/2016-04-18-linux%E4%B8%8B%E7%9A%84.dev.shm%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-04-18-linux%E4%B8%8B%E7%9A%84.dev.shm%E7%9B%AE%E5%BD%95/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/04/18/5405113.html linux下的/dev/shm目录 linux中/dev目录下一般都是一些设备文件，例如磁盘、内存、摄像头等。
/dev/shm这个目录是linux下一个利用内存虚拟出来的一个目录，这个目录中的文件都是保存在内存中，而不是磁盘上。其大小是非固定的，即不是预先分配好的内存来存储的。(shm == shared memory)
简要说明 /dev/shm的容量默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节。
通过下面的命令，我们可以看到/dev/shm的文件系统为tmpfs，即为临时文件系统。其他的几个tmpfs的挂载目录，其实质上于/dev/shm是一致的。
/home/o [o@o-s] [16:22] &amp;gt; df -h 文件系统 容量 已用 可用 已用% 挂载点 dev 3.9G 0 3.9G 0% /dev run 3.9G 656K 3.9G 1% /run /dev/sda2 58G 12G 43G 22% / tmpfs 3.9G 1.0G 2.9G 26% /dev/shm tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup tmpfs 3.9G 0 3.9G 0% /tmp /dev/sdb1 58G 24G 32G 44% /mnt/data /dev/sda1 488M 26M 463M 6% /boot tmpfs 791M 0 791M 0% /run/user/1000  文件测试 执行下面命令</description>
    </item>
    
    <item>
      <title>linux下一步一步安装禅道项目管理工具</title>
      <link>http://sotex.github.io/post/2016-04-08-linux%E4%B8%8B%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85%E7%A6%85%E9%81%93%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 08 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-04-08-linux%E4%B8%8B%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85%E7%A6%85%E9%81%93%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/04/08/5367408.html linux下一步一步安装禅道项目管理工具 因为禅道官网的安装教程实在是太简陋了，所以记录在此。
1、安装apache服务 archlinux下直接
sudo pacman -S apache  ubuntu下
sudo apt-get install apache2  安装apache的时候，会添加http用户和http组。可以修改/etc/httpd/conf/httpd.conf文件中的两行
User http Group http  来指定httpd运行时使用的用户和组。
2、安装php运行环境 archlinux下直接
sudo pacman -S php php-apache phpmyadmin php-sqlite php-composer php-mcrypt  目前archlinux源的php版本是7，而ubuntu是5。上面安装中有一些不是必须的，不必全部安装。
ubuntu下
sudo apt-get install php5 php5-json php5-mysql  3、配置httpd.conf 编辑/etc/httpd/conf/httpd.conf文件
在其中加上两行，内容如下
# 加载 php模块 LoadModule php7_module modules/libphp7.so
包含 php配置信息 Include conf/extra/php7_module.conf  因为上面是在archlinux下安装的原因，所以php的版本比较高。
具体的文件名，可以参考/etc/httpd/conf/extra/目录下是php7_module.conf还是别的文件名。
加载的libphp7.so文件应该在/etc/httpd/modules/目录下(modules是一个符号连接)，具体的文件名可以查看该目录。
然后注意下面三行
#LoadModule mpm_event_module modules/mod_mpm_event.so LoadModule mpm_prefork_module modules/mod_mpm_prefork.</description>
    </item>
    
    <item>
      <title>tfw格式图解</title>
      <link>http://sotex.github.io/post/2016-03-23-tfw%E6%A0%BC%E5%BC%8F%E5%9B%BE%E8%A7%A3/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-03-23-tfw%E6%A0%BC%E5%BC%8F%E5%9B%BE%E8%A7%A3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/03/23/5312300.html TFW格式，是关于TIFF影像坐标信息的文本文件。其它影像格式的坐标信息描述文件与其格式是一样的，后缀名可能不同。（bmp-bpw/png-pgw/jpg-jpw）
话不多说，直接看图。
上图中的UV坐标，实际上只的是图像的 横向坐标 和 纵向坐标&amp;nbsp;。即图像的行和列坐标。
&amp;nbsp;对于图上任意一个像素点(col,row)这个坐标，换算其地理坐标就十分简单。
GeoX = 1000.000 + col * U方向分辨率 + &amp;nbsp;row * X方向旋转系数;
GeoY = 200.000 &amp;nbsp;+ row * V方向分辨率 + &amp;nbsp;col * Y方向选择系数;
&amp;nbsp;
X和Y方向的旋转系数并不是一个角度，而是说像素坐标在col或row(非同时)轴移动一个像素时，对应的在地理坐标上X和Y的变化值。</description>
    </item>
    
    <item>
      <title>yaourt: a pacman frontend(pacman前端，翻译)</title>
      <link>http://sotex.github.io/post/2016-02-02-yaourt-a-pacman-frontendpacman%E5%89%8D%E7%AB%AF%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-02-02-yaourt-a-pacman-frontendpacman%E5%89%8D%E7%AB%AF%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/02/02/5178425.html yaourt: 一个pacman前端 本文翻译自：https://archlinux.fr/yaourt-en
1 juin 2007 - admin
关于 简介 获取 示例 截图 链接   关于 Yaourt是一个命令行接口程序，用于在Archlinux上，协同pacman完成软件安装。
Written by Julien Mischkowitz &amp;lt;wain at archlinux.fr&amp;gt; and Tuxce &amp;lt;tuxce.net at gmail.com&amp;gt;.
简介  AUR 支持 (搜索：search, 安装：install, 检查冲突和依赖关系：check conflict and dependency) 交互式搜索和安装 直接从ABS源码包构建 处理备份文件: .pac* 保存，恢复alpm数据库。直接从备份文件中查询。Save, restore alpm database. Query directly from a backup file. 搜索orphans和测试本地数据库。Search orphans and test local database 支持分包(splitted packages)  获取 建议在阅读AUR相关信息后，再去使用它安装需要的软件包。
你可以使用AUR安装:
git clone https://aur.</description>
    </item>
    
    <item>
      <title>OpenGL官方教程——着色器语言概述</title>
      <link>http://sotex.github.io/post/2016-01-26-opengl%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 26 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-01-26-opengl%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/01/26/5159378.html OpenGL官方教程&amp;mdash;&amp;mdash;着色器语言概述  OpenGL官方教程&amp;mdash;&amp;mdash;着色器语言概述  可编程图形硬件管线(流水线) 可编程顶点处理器 可编程几何处理器 可编程片元处理器 语言     可编程图形硬件管线(流水线) 将 Pertransformed Vertices (每一个待转换顶点) 传人 Programmable Vertex Processor (可编程的顶点处理器) 得到 Transformed Vertices (转换的顶点) 将 Transformed Vertices (转换的顶点) 传入 Programmable Geometry Processor (可编程的几何处理器) 得到 Assenbled Polygons,Lines,or Points (组装 多边形、线或点) 进行 Clipping,Rasterization and Interpolation (裁剪，光栅化和插值) 得到 Rasterized Pertransformed Fragments (光栅化待转换的片元[片段]) 传入 Programmable Fragment Processor (可编程的片元处理器) 得到 Transformed Ftagment (转换的片元) 进行 Raster Operations (光栅运算) 进行 Pixel Update (像素更新) 传入 Frame Buffer (帧缓冲区)  可编程顶点处理器 顶点处理器是一个可编程的单元，该单元对传入的顶点属性，如位置、颜色、纹理坐标等进行操作。顶点处理器的目的是执行传统的图形操作，如顶点变换，法线变换/归一化，纹理坐标的生成，和纹理坐标变换。</description>
    </item>
    
    <item>
      <title>[翻译]opengl扩展教程1</title>
      <link>http://sotex.github.io/post/2016-01-15-%E7%BF%BB%E8%AF%91opengl%E6%89%A9%E5%B1%95%E6%95%99%E7%A8%8B1/</link>
      <pubDate>Fri, 15 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-01-15-%E7%BF%BB%E8%AF%91opengl%E6%89%A9%E5%B1%95%E6%95%99%E7%A8%8B1/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/01/15/5133972.html [翻译]opengl扩展教程1 原文地址https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/extensions.php
 [翻译]opengl扩展教程1  简介 检测扩展 使用扩展 GLEW入门  入门简介 初始化GLEW 检测OpenGL版本 检测扩展 平台特定扩展 练习       简介 OpenGL扩展是为了使用3D图形硬件的新功能。硬件厂商定义新的函数到OpenGL来支持新的或增强已有的特性。
由单个厂商创建的扩展是&amp;ldquo;vendor-specific&amp;rdquo;(厂商特定)，有多个厂商共同窗口的扩展是&amp;ldquo;multivendor&amp;rdquo;(多厂商)。
如果&amp;ldquo;vendor-specific&amp;rdquo;或&amp;ldquo;multivendor&amp;rdquo;扩展证明是一个好的增强功能，那么OpenGL Architecture Review Board (ARB是OpenGL管理机构的简称)也许会推进它成为一个&amp;ldquo;ARB approved&amp;rdquo;(ABR认可)扩展。
如果这个扩展是非常好的，那么ABR也许会将其整合到OpenGL的&amp;ldquo;core feature&amp;rdquo;(核心特征)。一个非常好的例子就是&amp;ldquo;OpenGL Shading Language&amp;rdquo;(OpenGL着色器语言)现在已经是OpenGL2.0或更高版本的&amp;rdquo;core feature&amp;rdquo;的一部分。
这个理念使得OpenGL变得非常强大，因为源代码保持向后兼容，10年前编写的OpenGL程序，现在还可以工作。
检测扩展 在一个有效的OpenGL上下文环境中，你可以使用glGetString(GL_EXTENSIONS)来获取一个包含所有可用扩展的列表，它返回一个以空格分隔的长字符串。
所有的扩展形式：GL_VENDOR_extension_name，VENDOR(厂商)来自但不限于下表。
  VENDOR描述 
   ARB ABR认可的扩展
  EXT 多厂商扩展
  APPLE 苹果计算机公司的扩展
  ATI ATI(AMD)科技公司的扩展
  HP 惠普公司的扩展
  NV NVIDIA的扩展</description>
    </item>
    
    <item>
      <title>[翻译]opengl扩展教程2</title>
      <link>http://sotex.github.io/post/2016-01-15-%E7%BF%BB%E8%AF%91opengl%E6%89%A9%E5%B1%95%E6%95%99%E7%A8%8B2/</link>
      <pubDate>Fri, 15 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-01-15-%E7%BF%BB%E8%AF%91opengl%E6%89%A9%E5%B1%95%E6%95%99%E7%A8%8B2/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/01/15/5133975.html [翻译]opengl扩展教程2 原文地址https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/extensions_part2.php
 [翻译]opengl扩展教程2  OpenGL着色器语言扩展  检测存在的GLSL版本       OpenGL着色器语言扩展 实际上现在我们知道足够多的扩展，对于我们GLSL程序使用。
检测存在的GLSL版本 若要检查OpenGL着色语言当前是否支持，扩展&amp;ldquo;GL_ARB_shading_language_100&amp;rdquo;必须可用。如果存在此扩展，则实际版本的OpenGL着色语言可以用glGetString(GL_SHADING_LANGUAGE_VERSION_ARB)进行查询。返回字符串的格式是:
&amp;ldquo;major.minor.release vendor_info_string&amp;rdquo;。(其中&amp;ldquo;release&amp;rdquo;和&amp;ldquo;vendor_info_string&amp;rdquo;是可选)。版本号可以是1位或多位数。
不幸的是，这是不可能用 OpenGL 着色语言的初始版本。如果查询返回一个&amp;ldquo;GL_INVALID_ENUM&amp;rdquo;的错误，那么你可以假设它是版本1.051(major=1, minor=0, revision=51)(主版本号=1, 次版本号=0, 修订版本号=51)。
if (glewIsSupported(&amp;ldquo;GL_ARB_shading_language_100&amp;rdquo;)) {
int major, minor, revision; const GLubyte* sVersion = glGetString(GL_SHADING_LANGUAGE_VERSION_ARB); if (glGetError() == GL_INVALID_ENUM) { major = 1; minor = 0; revision=51; } else { // parse string sVersion to get major, minor, revision } }  如果&amp;ldquo;GL_ARB_shading_language_100&amp;rdquo;是当前支持的，那么着色器语言相关其他的扩展也一定存在：&amp;ldquo;GL_ARB_shader_objects&amp;rdquo;, &amp;ldquo;GL_ARB_fragment_shader&amp;rdquo;, 和&amp;ldquo;GL_ARB_vertex_shader&amp;rdquo;。</description>
    </item>
    
    <item>
      <title>Git-it字典翻译</title>
      <link>http://sotex.github.io/post/2016-01-12-git-it%E5%AD%97%E5%85%B8%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-01-12-git-it%E5%AD%97%E5%85%B8%E7%BF%BB%E8%AF%91/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2016/01/12/5123788.html #Git-it字典翻译 下面的内容翻译自git-it/dictionary 水平有限，翻译欠佳。
##Git准备工作
创建一个新的文件夹(目录)
$ mkdir &amp;lt;目录名称&amp;gt;  切换到这个目录 (cd到目录)
$ cd &amp;lt;目录名称&amp;gt;  列出这个目录的信息
$ ls  ##配置configuration
查看 Git 版本
git --version  设置你的名字(全局的)
git config --global user.name &amp;quot;Your Name&amp;quot;  设置你的电子邮箱地址
git config --global user.email youremail@example.com  设置你的Github 账户(这一步不一定是github的，你用别的站点的服务，就设置为相关站点的就是)
git config --global user.username &amp;quot;USERNAME&amp;quot;  ##Git 基本操作
在文件夹创建git仓库
$ git init  检查一个仓库的更改状态
$ git status  查看更改的文件
$ git diff  添加一个文件的更改</description>
    </item>
    
    <item>
      <title>解决 QtCreator 3.5(4.0)无法输入中文的问题</title>
      <link>http://sotex.github.io/post/2016-01-08-%E8%A7%A3%E5%86%B3-qtcreator-3.54.0%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 08 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2016-01-08-%E8%A7%A3%E5%86%B3-qtcreator-3.54.0%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>#解决 QtCreator 3.5.1无法输入中文的问题 [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2016/01/08/5114041.html
环境是ubuntu 15.10 ubuntu软件源中下载安装的fctix-libs-qt5现在没有用，版本太旧了。 自己下载fctix-qt5的源码来编译即可。
##1、获取fctix-qt5源码 我没有找到fcitx-qt5的git仓库地址，只找到了源码包的下载地址。
先下载源码包，并解压。
wget https://download.fcitx-im.org/fcitx-qt5/fcitx-qt5-1.0.5.tar.xz tar -xJf fcitx-qt5-1.0.5.tar.xz  找到了git仓库地址
git clone http://github.com/fcitx/fcitx-qt5.git  ##2、生成Makefile文件 这一步很简单，进入源码目录，然后新建一个build的目录并进入，然后使用cmake来生成Makefile
cd fcitx-qt5 mkdir build &amp;amp;&amp;amp; cd build cmake ..  这一个步骤产生了几个错误，这和系统环境有关。如果你的没有产生错误，后面就不用看了 ###2.1、没有找到&amp;rdquo;ECM&amp;rdquo;包配置文件报错 错误信息
cmake .. -- The C compiler identification is GNU 5.2.1 -- The CXX compiler identification is Clang 3.7.0 ... ... -- Detecting CXX compile features - done CMake Error at CMakeLists.txt:8 (find_package): Could not find a package configuration file provided by &amp;quot;ECM&amp;quot; (requested version 1.</description>
    </item>
    
    <item>
      <title>Valgrind 3.11.0编译安装</title>
      <link>http://sotex.github.io/post/2015-12-29-valgrind-3.11.0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-12-29-valgrind-3.11.0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/12/29/5085202.html Valgrind 3.11.0编译安装 Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。
Valgrind遵守GNU通用公共许可证条款，是一款自由软件。
到3.3.0版本为止，Valgrind支持x86、x86-64以及PowerPC上的Linux。除此之外，还有一些其它非正式支持的类Unix平台（如FreeBSD、NetBSD以及Mac OS X）。
1、下载Valgrind 3.11.0 直接下载源码包
wget http://valgrind.org/downloads/valgrind-3.11.0.tar.bz2 tar -xjvf valgrind-3.11.0.tar.bz2 cd valgrind-3.11.0/  使用svn克隆一个
svn co svn://svn.valgrind.org/valgrind/trunk valgrind  2、生成Makefile并使用它进行编译 生成Makefile的步骤在README这个文件中有写。
  运行./autogen.sh来设置环境（你需要标准的autoconf工具）
这个脚本其实是调用的aclocal autoheader automake autoconf，所以必须先安装好它，如果没有安装，在运行这个脚本的时候会提示你的。
   运行./configure来生成Makefile文件
这里你可以使用./configure &amp;ndash;help来查看可以使用哪些参数设置。
一般设置好安装路径即可./configure &amp;ndash;prefix=/usr/local/valgrind
   运行make进行编译，运行make install进行安装。
 
 下面是我编译时候的步骤
#运行 autogen.sho@o-pc:~/software/valgrind-3.11.0$ ./autogen.shrunning: aclocal running: autoheader running: automake -a running: autoconf
#运行configure o@o-pc:~/software/valgrind-3.11.0$ ./configure &amp;ndash;prefix=/usr/local/valgrind checking for a BSD-compatible install&amp;hellip; /usr/bin/install -c &amp;hellip;.</description>
    </item>
    
    <item>
      <title>ubuntu linux 下wine的使用</title>
      <link>http://sotex.github.io/post/2015-12-23-ubuntu-linux-%E4%B8%8Bwine%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-12-23-ubuntu-linux-%E4%B8%8Bwine%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/12/23/5070174.html ubuntu linux 下wine的使用 之前写了一篇 ubuntu15.10下编译安装wine1.8rc4
这一篇是来写它的使用的。
1、安装Wine支持包 现在，需要安装非开源(但免费)的支持包。这包括微软Core Fonts、Visual C++运行时环境等软件包。
安装Cabextract：需要该软件包来解压缩微软.cab文件。
sudo apt-get install cabextract  2、下载winetricks脚本： 现在需要下载一个很棒的脚本，名为winetricks，它会自动下载和安装必要的支持包。
wget http://winetricks.org/winetricks  现在输入下列命令，安装必要的支持包：
sh winetricks corefonts Tahoma  如果你发现提示你权限问题，请将~/.cache/winetricks这个文件夹的所有者改为普通用户。
提示：可以不用任何命令行参数来运行winetricks，那样就能从漂亮的GUI界面选择需要安装的软件包。
&amp;nbsp; &amp;nbsp;&amp;nbsp; 3、使用wine运行exe文件 这里就不说在图形界面的文件管理器中右键使用wine加载的方式了。
运行exe文件来安装windows下的软件也是一个道理。
假如我们要安装迅雷精简版软件，那么先下载它的安装包，然后使用wine ThunderMini_1.5.3.exe来执行安装。其中ThunderMini_1.5.3.exe是迅雷安装包文件。
&amp;nbsp; 迅雷的默认安装路径是~/.wine/drive_c/Program Files/Thunder Network/MiniThunder
我们可以在桌面建一个脚本来启动它。
把以下的内容保存为一个脚本即可
#! /bin/sh cd ~/.wine/drive_c/Program\ Files/Thunder\ Network/MiniThunder nohup wine ./Bin/ThunderMini.exe &amp;amp;  在这之前，最好先做一件事情，那就是使用winetricks安装一些windows的常用运行库（VC++ runtime library）</description>
    </item>
    
    <item>
      <title>ubuntu15.10下编译安装wine1.8 rc4</title>
      <link>http://sotex.github.io/post/2015-12-23-ubuntu15.10%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85wine1.8-rc4/</link>
      <pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-12-23-ubuntu15.10%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85wine1.8-rc4/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/12/23/5070065.html ubuntu15.10下编译安装wine1.8rc4 Wine （&amp;ldquo;Wine Is Not an Emulator&amp;rdquo; 的递归缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，Mac OSX 及 BSD 等）上运行 Windows 应用的兼容层。另外英语单词wine是葡萄酒的意思。
Wine1.8在2015年12月19日已经正式发布了。相关的信息参考https://www.winehq.org/
1、下载wine1.8 rc4源码 源码直接到官网下载即可。
wget https://dl.winehq.org/wine/source/1.8/wine-1.8.tar.bz2  下载之后解压，这就不说了。（tar -xjf &amp;hellip;）
2、安装编译环境 编译环境是需要安装好，不然 ./configure 的时候就通不过。这里说的编译环境主要是指gcc编译工具链。
sudo apt-get install gcc g++  然后安装32位开发环境（gcc的32位开发库）
sudo apt-get install lib32gcc-5-dev lib32stdc++6 lib32gfortran-5-dev-s390x-cross lib32stdc++6-s390x-cross lib32readline6-dev  如果没有安装，那么 ./configure 的时候报的错如下
?   1 2  checking&amp;nbsp;whether&amp;nbsp;gcc&amp;nbsp;-m32&amp;nbsp;works&amp;hellip;&amp;nbsp;no configure:&amp;nbsp;error:&amp;nbsp;Cannot&amp;nbsp;build&amp;nbsp;a&amp;nbsp;32-bit&amp;nbsp;program,&amp;nbsp;you&amp;nbsp;need&amp;nbsp;to&amp;nbsp;install&amp;nbsp;32-bit&amp;nbsp;development&amp;nbsp;libraries.       3、安装依赖库 安装依赖库的时候，具体要安装哪些可以看 ./configure 的报错信息，我这里安装的如下</description>
    </item>
    
    <item>
      <title>验证码系统</title>
      <link>http://sotex.github.io/post/2015-12-14-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-12-14-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B3%BB%E7%BB%9F/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/12/14/5046401.html 验证码系统
验证过程
1、服务器传过来几张手写文字的图片
2、用户在手写框用鼠标写出这些看到的文字，将鼠标轨迹传回服务器
3、服务器分析鼠标轨迹，判断用户写的与其看到的是否是一致的。如果是一致的，认证通过，并把用户写的轨迹生产图片文件保存到手写文字数据库。
最开始的时候，需要先在数据库中添加所有的常用文字的手写图片。然后随机传给用户进行手写识别。
对于用户手写的图片，如果给别人认证的时候，认证有效通过率低于某一个百分比，则将其从数据库中移除。一段时间后，数据库中将有大量的手写文字图片来做验证码，而且是不断更新的。那么就能够有效降低通过下载验证码图片进行比对的方式来进行验证码破解。</description>
    </item>
    
    <item>
      <title>osc的git服务器简单使用。</title>
      <link>http://sotex.github.io/post/2015-12-10-osc%E7%9A%84git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 10 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-12-10-osc%E7%9A%84git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/12/10/5037102.html 1、创建本地仓库  mkdir dircd dirgit init 初始化仓库  &amp;nbsp;
2、创建远程仓库 进入远程仓库去创建  3、关联本地仓库与远程仓库 git remote add osc git::&amp;hellip; osc是远程服务器别名,git::&amp;hellip;指远程仓库git地址  &amp;nbsp;
4、基本使用 1、添加修改文件等 2、使用git add &amp;hellip; 添加文件到索引(git rm/mv 移除/移动) 3、使用 git commit -m &amp;ldquo;注释&amp;rdquo; file 来提交 4、使用 git push osc 来提交到远程仓库 这里只是简单介绍下，详细的使用参考 http://git.oschina.net/oschina/git-osc/wikis/Home</description>
    </item>
    
    <item>
      <title>net-snmp源码VS2013编译添加加密支持(OpenSSL)</title>
      <link>http://sotex.github.io/post/2015-11-27-net-snmp%E6%BA%90%E7%A0%81vs2013%E7%BC%96%E8%AF%91%E6%B7%BB%E5%8A%A0%E5%8A%A0%E5%AF%86%E6%94%AF%E6%8C%81openssl/</link>
      <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-11-27-net-snmp%E6%BA%90%E7%A0%81vs2013%E7%BC%96%E8%AF%91%E6%B7%BB%E5%8A%A0%E5%8A%A0%E5%AF%86%E6%94%AF%E6%8C%81openssl/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/11/27/5001672.html net-snmp源码VS2013编译添加加密支持(OpenSSL) snmp v3 协议使用了基于用户的安全模型，具有认证和加密两个模块。
认证使用的算法是一般的消息摘要算法，例如MD5/SHA等。这一部分在net-snmp的源码中已经有相关的实现，无需再使用外部库来支持它。
加密使用的算法一般可以是DES/AES等。这一部分在net-snmp的源码中没有想关的实现，需要使用外部加密算法库(OpenSSL)来支持。
1、安装或编译OpenSSL 要使得编译出来的net-snmp支持加密，首先我们需要OpenSSL库的相关文件(头文件的库文件)。这可以采用OpenSSL的源码来编译的方式，也可以直接下载已经编译好文件来使用即可。
如果是自己编译，网上有很多相关的文章了，参考着来做就是。这不是本文的重点，这里就不写了。
最快速的方式就是网上下载一个现成的来用就是了。这里我下载的是这个 http://dl.pconline.com.cn/download/355862.html
下载之后直接双击安装即可。
下图是我这里安装后的位置，红框中的是将要用到的两个文件夹。
&amp;nbsp;
&amp;nbsp;
2、在net-snmp工程中设置相关属性 2.1、设置包含目录和库目录 在libsnmp和snmpd项目中添加包含目录和库目录。（你也可以把所有项目的都加上，我这里只用到这两个项目）其中libsnmp这个项目必须加上，否则不支持加密。
2.2、设置预处理器定义 这里要添加一个宏定义NETSNMP_USE_OPENSSL。可以修改&amp;lt;net-snmp/net-snmp-config.h&amp;gt;文件，但是这种做法会导致要所有的项目都必须设置头文件和库文件的目录，所以不是很好。这里我们只需要libsnmp和snmpd这两个项目支持即可，所以只需要设置这两个项目的属性。
3、编译。编写配置文件 编译这里就不说了，以后写一篇文章来专门讲讲使用VS2013编译net-snmp 5.7。
使用的时候必须使用制订了SNMPv3验证方式相关参数的配置文件才可。
具体的可以见这篇文章
http://www.cnblogs.com/oloroso/p/4844907.html</description>
    </item>
    
    <item>
      <title>windows下C语言编程获取磁盘(分区)使用情况</title>
      <link>http://sotex.github.io/post/2015-10-15-windows%E4%B8%8Bc%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 15 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-10-15-windows%E4%B8%8Bc%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/10/15/4881394.html windows下编程获取磁盘(分区)使用情况  windows下编程获取磁盘(分区)使用情况  GetLogicalDriveStrings函数  使用示例  获取需要的缓冲区长度示例 获取所有驱动器号示例     GetDriveType函数  使用示例   GetDiskFreeSpaceEx 函数  使用示例       linux下可以使用命令df -h来获取各个(已加载)分区的使用情况。Windows下也有很多好的工具来获取，但是我没有发现windows下的df命令。
在linux下使用df -h命令的输出如下
o@Neo-kylin:~/snmp$ df -h Filesystem Size Used Avail Use% Mounted on /dev/sda2 197G 14G 174G 8% / tmpfs 922M 76K 922M 1% /dev/shm /dev/sda5 61G 7.8G 50G 14% /media/sda5 /dev/sda6 134G 29G 99G 23% /media/sda6  在windows下获取这些信息可以通过几个API函数来操作。</description>
    </item>
    
    <item>
      <title>Linux中的动态库和静态库(.a/.la/.so/.o)</title>
      <link>http://sotex.github.io/post/2015-10-13-linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.a..la..so..o/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-10-13-linux%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93.a..la..so..o/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/10/13/4874801.html Linux中的动态库和静态库(.a/.la/.so/.o)  Linux中的动态库和静态库(.a/.la/.so/.o)  C/C++程序编译的过程 .o文件（目标文件）  创建atoi.o 使用atoi.o   .a文件（静态库文件）  创建atoi.a 使用atoi.a   .so文件（共享库文件）  创建atoi.so 使用atoi.so   .la文件(libtool archive)  libtool的使用  1. 创建 Libtool 对象文件 2. 创建 Libtool 库 3. 安装 Libtool 库 4. 使用 Libtool 库 5. 卸载 Libtool 库         本文由乌合之众 lym瞎编，欢迎转载 http://my.oschina.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
在windows下，一般可以通过文件的后缀名来识别文件的类型。在Linux下大致上也是可以的。但是要明确的一点是，在linux下，文件的后缀与文件的类型是没有必然的联系的。这只是约定俗称的习惯罢了。
在linux 下进行C/C++开发，一般都是使用的gcc编译器，所以本文的讲解以gcc为主。
 .</description>
    </item>
    
    <item>
      <title>U盘安装中标麒麟服务器操作系统 一 (NeoKylin 6.5)</title>
      <link>http://sotex.github.io/post/2015-10-08-u%E7%9B%98%E5%AE%89%E8%A3%85%E4%B8%AD%E6%A0%87%E9%BA%92%E9%BA%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80-neokylin-6.5/</link>
      <pubDate>Thu, 08 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-10-08-u%E7%9B%98%E5%AE%89%E8%A3%85%E4%B8%AD%E6%A0%87%E9%BA%92%E9%BA%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80-neokylin-6.5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/10/08/4861806.html U盘安装中标麒麟服务器操作系统(NeoKylin 6.5) 首先需要下载中标麒麟服务器操作系统的iso镜像。我这里的是NeoKylin Linux A 6.5.iso
因为超过了4GB，百度网盘不支持上传，所以就不分享了。有兴趣的可以中标麒麟的官网上申请光盘。
文件信息如下图所示

&amp;nbsp;
&amp;nbsp;
1、制作启动安装U盘 制作启动安装U盘使用的是UltraISO软件。插上U盘后使用这个软件打开NeoKylin Linux A 6.5.iso文件，点击菜单栏上启动&amp;ndash;》写入硬盘映像&amp;hellip;&amp;ndash;》选择你的U盘，然后点击写入即可。
曾经使用LinuxLive USB Creator软件来制作启动盘，但是使用的时候会出现卡死在initalizing gfx code的错误
&amp;nbsp;
2、使用U盘引导启动 这个没什么好说的，开机选择从U盘启动就是了。
3、开始安装 选择定制安装
选择语言，我选中文
选择键盘类型，一般我们用的都是选US标准的。
选择安装镜像的载体 这里就有要说的了。这里可不能选第一个本地CD/DVD，这个直接是选择第二个选项Hard drive硬盘驱动器。为什么呢？因为我们是使用的U盘安装，而不是光盘安装。
选择安装镜像所在的分区。这里选择的是第一个选项/dev/sda4，这实际是目前用来启动安装的U盘的分区。后面的几个/dev/sdb#是这台机器的硬盘的分区。
这里一定不能选错了。
直接点右边的圆形箭头按钮进入下一步
选择语言
选择存储设备
设置主机名和网络配置
设置root用户密码
设置分区布局方式 这里因为我之前准备了一个分区用来安装它，所以我选择了自定义的方式。这里可以按照自己的需要来选择
这里把整个系统安装到/dev/sdb2分区
点击进入下一步（不是创建分区哦）
格式化后进入下一步
将修改写入磁盘
设置引导安装位置 这一步很重要。这里要将引导程序安装到本地硬盘上，千万别让它安装到列U盘上去了（正常它也不会安装上去）
点击更换设备，然后在弹出来的窗口中选择你希望的结果
&amp;nbsp;
定制安装类型 &amp;nbsp;</description>
    </item>
    
    <item>
      <title>U盘安装中标麒麟服务器操作系统 二 (NeoKylin 6.5)</title>
      <link>http://sotex.github.io/post/2015-10-08-u%E7%9B%98%E5%AE%89%E8%A3%85%E4%B8%AD%E6%A0%87%E9%BA%92%E9%BA%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C-neokylin-6.5/</link>
      <pubDate>Thu, 08 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-10-08-u%E7%9B%98%E5%AE%89%E8%A3%85%E4%B8%AD%E6%A0%87%E9%BA%92%E9%BA%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C-neokylin-6.5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/10/08/4861811.html 因为博客园随笔长度的限制，这一篇是接http://www.cnblogs.com/oloroso/p/4861806.html之后的
选择要安装的软件包 启动安装过程
开始安装了
安装快结束了
安装引导装载程序了 安装完成，重启 4、安装完成后的初始化配置 重启之后第一次进入需要进行一次初始化配置，这个按照向导程序一步一步进行即可。
同意许可
创建一个普通用户名和密码
设置时间同步
Kdump设置
&amp;nbsp;
服务定制
设置完成，重启
重启后进行桌面，效果如下图
5、题外话 将普通用户添加到sudoesr文件中 假设普通用户的用户名是 o&amp;nbsp;
那么在添加o ALL=(ALL) ALL到/etc/sudoers文件中即可。
修改yum仓库源 这里不说太多了，网上相关的教程很多。原本的中标麒麟的源在我这里用不了，不知道为什么。
将原本/etc/yum.repos.d/ns6-adv-x86_64.repo文件中的内容清除，然后写入下面的内容就是。
然后使用sudo yum -y update来更新一下
[base] name=CentOS-$releasever -Base baseurl=http://centos.ustc.edu.cn/centos/6/os/$basearch/ gpgcheck=1gpgkey=http://centos.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6 #released updates [updates] name=CentOS-$releasever -Updates baseurl=http://centos.ustc.edu.cn/centos/6/updates/$basearch/ gpgcheck=1gpgkey=http://centos.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6 #packages used/produced inthe build but not released #[addons] #name=CentOS-$releasever -Addons #baseurl=http://centos.ustc.edu.cn/centos/$releasever/addons/$basearch/ #gpgcheck=1#gpgkey=http://centos.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6 #additional packages that may be useful [extras] name=CentOS-$releasever -Extras baseurl=http://centos.ustc.edu.cn/centos/6/extras/$basearch/ gpgcheck=1gpgkey=http://centos.ustc.edu.cn/centos/RPM-GPG-KEY-CentOS-6 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever -Plus baseurl=http://centos.</description>
    </item>
    
    <item>
      <title>windows下的getopt/getoptlong函数</title>
      <link>http://sotex.github.io/post/2015-10-06-windows%E4%B8%8B%E7%9A%84getopt.getoptlong%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-10-06-windows%E4%B8%8B%E7%9A%84getopt.getoptlong%E5%87%BD%E6%95%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/10/06/4856104.html windows下的getopt/getoptlong函数 getopt/getopt_long函数是GNU C中的函数，在linux编程中很常用到。这里就不介绍了。
windows下没有找到类似的函数，自己写一个又浪费时间，于是乎从glibc中找出来。
这里放出两个版本的下载地址
http://files.cnblogs.com/files/oloroso/getopt--from-glibc-2.15.tar.gz
http://files.cnblogs.com/files/oloroso/getopt-win-from-glibc-2.2.5.tar.gz
下载GLibC源码 首先需要下载glibC的源代码文件，这个文件比较大，但是我们只需要其中的几个文件而已。
如果是后面给出的链接下载的glibc源码包，只需要两个文件。如果是比较新版本的glibc，可能需要四个文件(getopt.h/getopt_int.h/getopt.c/getopt_init.c)
这个只需要图中所示的两个文件即可。下载之后找到这两个文件解压出来即可。
下载地址 &amp;nbsp;http://down1.chinaunix.net/distfiles/glibc-2.2.5.tar.bz2
这是glibc-2.2.5的压缩包中间提取的文件
下面是glibc-2.15中需要提取的文件
修改getopt.c gettext.h头文件不存在问题（glibc-2.15） 首先需要修改的是没有&amp;ldquo;gettext.h&amp;rdquo;这个头文件的问题。这里直接将其注释掉，然后修改后面的宏定义。
这个修改仅是glibc-2.15版本中，如果是glibc-2.2.5版本的，是没有这个问题的。
将下面的代码（大概在70行）
1 #ifdef _LIBC 2 # include &amp;lt;libintl.h&amp;gt; 3 #else 4 # include &amp;ldquo;gettext.h&amp;ldquo; 5 # define _(msgid) gettext (msgid) 6 #endif  修改为
1 #ifdef _LIBC 2 # include &amp;lt;libintl.h&amp;gt; 3 #else 4 //# include &amp;ldquo;gettext.h&amp;rdquo; 5 # define _(msgid) (msgid) 6 #endif  修改后
&amp;nbsp;
alloca的问题(无法解析的外部符号 _alloca)(glibc-2.</description>
    </item>
    
    <item>
      <title>net-snmp配置文件详解</title>
      <link>http://sotex.github.io/post/2015-09-28-net-snmp%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 28 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-09-28-net-snmp%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/09/28/4844907.html net-snmp配置文件详解 net-snmp的配置文件是有一定的层次结构的，配置起来也很方便。网上找了很多资料，大概把这个配置文件的各个信息搞懂了一点。其实在net-snmp的EXAMPLE.conf文件中对齐有详细的描述，不过是英文的。
开启子代理模式 开发net-snmp子代理后，如果想要使用它，必须开启子代理功能。如果不开启，子代理运行的时候将会报错&amp;nbsp;Warning: Failed to connect to the agentx master agent ([NIL])&amp;nbsp;
设置snmpd监听的地址端口 snmpd默认是监听本地所有的IP地址的&amp;nbsp;UDP 161端口 等待snmp请求。如果不希望使用默认的监听设置，可以使用自定义的选项
# Listen forconnections from the local system only
只监听本地的连接 agentAddress udp:127.0.0.1:161Listen for connections on all interfaces (both IPv4 andIPv6) 监听所有接口的连接 #agentAddress udp:161,udp6:[::1]:161  &amp;nbsp; 定义安全体名和共同体名称 共同体这个是SNMPv2中的，如果只是使用SNMPv3协议，可以不需要。
rocommunity 共同体名 rwcommunity 共同体名  使用&amp;nbsp;rocommunity 来定义一个只读权限的共同体，使用&amp;nbsp;rwcommunity 来定义一个读写权限的共同体。
&amp;nbsp;
定义完共同体之后就要定义一个安全体，并把共同体映射到一个安全体中去。安全体用于控制外部访问的来源的。
使用com2sec关键字来定义安全体。
# sec.name souce community com2sec read default public com2sec writedefault public com2sec test default public  # 1.</description>
    </item>
    
    <item>
      <title>net-snmp5.7.3移植到arm-linux平台</title>
      <link>http://sotex.github.io/post/2015-09-16-net-snmp5.7.3%E7%A7%BB%E6%A4%8D%E5%88%B0arm-linux%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Wed, 16 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-09-16-net-snmp5.7.3%E7%A7%BB%E6%A4%8D%E5%88%B0arm-linux%E5%B9%B3%E5%8F%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/09/16/4814467.html net-snmp5.7.3移植到arm-linux平台 本次交叉编译在ubuntu 15.04 64位系统下进行。
准备工作 在编译移植前有几项准备工作需要完成。
 1下载net-snmp 5.7.3源码包 2安装交叉编译环境(arm-linux-gnueabi-gcc)
使用命令sudo apt-get install gcc-arm-linux-gnueabi安装即可。
 编译配置 解压net-snmp源码包，然后进入源码包目录
unzip net-snmp-5.7.3.zip cd net-snmp-5.7.3/  可以使用./configure &amp;ndash;help查看一下配置选项有那些。这里不贴了，直接给出。
  选项说明    &amp;ndash;host=arm-linux 运行平台   &amp;ndash;target=arm-linux 目标平台   &amp;ndash;build=i686-linux 编译平台   &amp;ndash;with-cc=arm-linux-gcc 交叉编译工具   &amp;ndash;with-ar=arm-linux-ar 使用的打包工具   &amp;ndash;prefix=/usr/local/net-snmp 安装目录   &amp;ndash;disable-shared 不编译共享库   &amp;ndash;disable-scripts 不要安装mib2c等脚本   &amp;ndash;with-endianness=little 指定小端模式   -enable-mini-agent 最小化构建agent   &amp;ndash;disable-deprecated 不编译弃用的功能   &amp;ndash;without-logfile 指定snmpd不输出日志文件(可以使用&amp;ndash;with-logfile指定默认日志文件位置)   &amp;ndash;disable-minimalist 删除所有非基本的代码功能   &amp;ndash;enable-debugging 打开调试信息   &amp;ndash;disable-testing-code 不使用测试代码(某些代码不被使用)   &amp;ndash;with-openssl=/opt/hardhat openssl库路径(用于支持加密等)   &amp;ndash;disable-ipv6 不使用IPv6   &amp;ndash;disable-manuals 不安装manpage说明页   &amp;ndash;disable-ucd-snmp-compatibility 不需要兼容ucd-snmp   &amp;ndash;disable-snmptrapd-subagent 不用支持snmptrapd的子代理   &amp;ndash;disable-embedded-perl 在SNMP代理和snmptrapd禁用嵌入式Perl。默认启用   &amp;ndash;disable-applications 是否关闭snmpget等功能，根据自己的需要选择   &amp;ndash;with-default-snmp-version=&amp;ldquo;3&amp;rdquo; 指定默认协议版本   &amp;ndash;enable-as-needed  仅链接需要库，不链接不必要的库（如果只使用其他方法行不通,链接libperl针对应用而非Net-SNMP库。）    下面是我使用的配置</description>
    </item>
    
    <item>
      <title>NET-SNMP开发——日志输出</title>
      <link>http://sotex.github.io/post/2015-09-07-net-snmp%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-09-07-net-snmp%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/09/07/4789201.html NET-SNMP开发&amp;mdash;&amp;mdash;日志输出 net-snmp的日志输出功能是很强大的，与日志输出相关函数声明在net-snmp-5.7.3\include\net-snmp\library\snmp_logging.h文件中，定义在net-snmp-5.7.3\snmplib\snmp_logging.c文件中。
具体实现就不说了，可以自己看源码。
net-snmp的日志功能默认将日志写入到/var/log/snmpd.log文件中(linux/unix下，windows下没有)
snmp log 类型 net-snmp中将日志分为8个类型(一个警告warning，三个信息information，四个错误error)，具体的宏定义如下
/* error types / #define LOG_EMERG 0 / system is unusable / #define LOG_ALERT 1 / action must be taken immediately / #define LOG_CRIT 2 / critical conditions 临界条件/ #define LOG_ERR 3 / error conditions 错误条件/ / warning type / #define LOG_WARNING 4 / warning conditions 预警条件/ / information types / #define LOG_NOTICE 5 / normal but significant condition 正常但意义重大/ #define LOG_INFO 6 / informational 信息/ #define LOG_DEBUG 7 / debug-level messages 调试级别的消息*/  注意：这些严重等级的分类是与标准的 UNIX/LINUX 中的 syslog 一致的。</description>
    </item>
    
    <item>
      <title>SNMP常用数据操作</title>
      <link>http://sotex.github.io/post/2015-08-26-snmp%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-26-snmp%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/26/4759874.html SNMP常用数据操作 &amp;nbsp;snmp编程中常见的数据类型基本上就是integer32/oct_str(字节数组)/counter64/timeticks/dateAndTime这些。很多其它的比如TruthValue这样的数据在编程的时候一般都比较少用，而且一般都有对应的替代。
Counter32类型 Counter32其实对应C语言中的32位无符号整型(0~2^32-1)。在snmpv1中它的解释是：&amp;ldquo;计数器是一个非负的整数，它递增至最大值，而后归零&amp;rdquo;。
对counter32的操作，在32位机器上，其一般使用unsigned int来表示。是比较简单的数据类型，所以无需使用特别的操作。
Counter64类型 Counter64对应64位的计数器，它表示的范围(0~2^64-1)就比counter32大多了，在net-snmp中提供了对它操作的相关函数。
Net-snmp中并没有直接使用C语言中的64位无符号整型，而是使用了一个结构体来表示
  structcounter64 { u_long high; u_long low; };  &amp;nbsp;
 为什么这么做呢？这个不好说，可能是为了操作方便吧。在snmp++中定义了一个类Counter64来提供对这个数据类型的操作，它也是如同此处将其分为高位部分(hipart)和低位(lopart)部分。
同时还定义了一些用于操作counter64数据类型的函数。
 typedef structcounter64 U64;
#define I64CHARSZ 21
&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; divBy10(U64, U64 *, unsigned &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; multBy10(U64, U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; incrByU16(U64 *, unsigned &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; incrByU32(U64 *, unsigned &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); NETSNMP_IMPORT &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; zeroU64(U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; isZeroU64(&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); NETSNMP_IMPORT &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; printU64(&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;char&amp;lt;/span&amp;gt; *, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); NETSNMP_IMPORT &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; printI64(&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;char&amp;lt;/span&amp;gt; *, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; read64(U64 *, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;char&amp;lt;/span&amp;gt; *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;); NETSNMP_IMPORT &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; u64Subtract(&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 * pu64one, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64two, U64 &amp;lt;/span&amp;gt;*&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64out); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; u64Incr(U64 * pu64out, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64one); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; u64UpdateCounter(U64 * pu64out, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64one, &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64two); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt; u64Copy(U64 * pu64one, &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;const&amp;lt;/span&amp;gt; U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; pu64two); &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; netsnmp_c64_check_for_32bit_wrap(U64 *old_val, U64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;new_val, &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt; adjust); NETSNMP_IMPORT &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; netsnmp_c64_check32_and_update(&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; counter64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;prev_val, &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; counter64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;new_val, &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; counter64 *&amp;lt;span style=&amp;quot;color: #000000;&amp;quot;&amp;gt;old_prev_val, &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;int&amp;lt;/span&amp;gt; *need_wrap_check);&amp;lt;/pre&amp;gt;   &amp;nbsp;</description>
    </item>
    
    <item>
      <title>38 网络相关函数(六)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-17-38-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%85%ADlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 17 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-17-38-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%85%ADlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/17/4736793.html 38 网络相关函数(六)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  38 网络相关函数(六)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 12)makeSocketNonBlocking和makeSocketBlocking套接口阻塞属性设置 13)setupStreamSocket设置流式套接口     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
12)makeSocketNonBlocking和makeSocketBlocking套接口阻塞属性设置 makeSocketNonBlocking函数用于为参数sock代表的套接口添加O_NONBLOCK非阻塞属性。
// 设置sock为非阻塞模式 Boolean makeSocketNonBlocking(int sock) { #if defined(WIN32) || defined(_WIN32) unsigned long arg = 1; return ioctlsocket(sock, FIONBIO, &amp;amp;arg) == 0; #elif defined(VXWORKS) int arg = 1; return ioctl(sock, FIONBIO, (int)&amp;amp;arg) == 0; #else int curFlags = fcntl(sock, F_GETFL, 0); return fcntl(sock, F_SETFL, curFlags|O_NONBLOCK) &amp;gt;= 0; #endif }  makeSocketBlocking函数用于为参数sock代表的套接口去除O_NONBLOCK非阻塞属性。</description>
    </item>
    
    <item>
      <title>39 网络相关函数(七)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-17-39-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%83live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 17 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-17-39-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%83live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/17/4736913.html 39 网络相关函数(七)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  39 网络相关函数(七)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 14)readSocket从套接口读取数据 recv/recvfrom 函数  函数原型： 参数说明： 返回说明：       本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
14)readSocket从套接口读取数据 readSocket函数从套接口socket读取数据到buffer，并捕获数据发送源的地址到fromAddress。
函数返回读取到的字节数，出错时返回0并调用socketErr(env, &amp;ldquo;recvfrom() error: &amp;ldquo;)来设置套接口错误消息。
// 从套接口读数据 int readSocket(UsageEnvironment&amp;amp; env, int socket, unsigned char* buffer, unsigned bufferSize, struct sockaddr_in&amp;amp; fromAddress) { SOCKLEN_T addressSize = sizeof fromAddress; // ssize_t recvfrom(int sockfd,void *buf,int len,unsigned int flags, struct sockaddr *from,socket_t fromlen); // 读取主机经指定的socket传来的数据,并把数据传到由参数buf指向的内存空间,参数len为可接收数据的最大长度。flag一般设置为0。from是来源地址，fromlen传出来源长度 // 如果正确接收返回接收到的字节数，失败返回-1.</description>
    </item>
    
    <item>
      <title>40 网络相关函数(八)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-17-40-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%85%ABlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 17 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-17-40-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%85%ABlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/17/4736919.html 40 网络相关函数(八)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  40 网络相关函数(八)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 15)writeSocket向套接口写数据 TTL的概念 函数sendto  函数原型 函数说明 参数说明： 返回值  错误代码         本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
15)writeSocket向套接口写数据 writeSocket函数用于将buffer中的数据经socket套接口写入到目标主机(address + port)。参数ttlArg为0时被忽略，不为0时设置此处发送数据包的最大路由跳转次数。
// 往套接口写数据 Boolean writeSocket(UsageEnvironment&amp;amp; env, int socket, struct in_addr address, Port port, u_int8_t ttlArg, unsigned char* buffer, unsigned bufferSize) { do { if (ttlArg != 0) { // TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。 // TTL的最大值是255，TTL的一个推荐值是64。 // Before sending, set the socket&amp;rsquo;s TTL:发送前设置socket TTL #if defined(WIN32) || defined(_WIN32) #define TTL_TYPE int #else #define TTL_TYPE u_int8_t #endif TTL_TYPE ttl = (TTL_TYPE)ttlArg; // 设置多播TTL值 if (setsockopt(socket, IPPROTO_IP, IP_MULTICAST_TTL, (const char*)&amp;amp;ttl, sizeof ttl) &amp;lt; 0) { socketErr(env, &amp;ldquo;setsockopt(IP_MULTICAST_TTL) error: &amp;ldquo;); break; } }</description>
    </item>
    
    <item>
      <title>33 网络相关函数(一)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-12-33-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-12-33-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/12/4724021.html 33 网络相关函数(一)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  33 网络相关函数(一)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 1)IsMulticastAddress多播(组播)地址判断函数  多播简要说明 多播编程简述  1.流程 2.多播程序设计使用setsockopt()函数和getsockopt()函数来实现，组播的选项是IP层的。 3.setsockopt()的选项 实例：         本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
1)IsMulticastAddress多播(组播)地址判断函数 IsMulticastAddress用于判断一个地址是否为多播(组播)地址，如果是的话返回true，否则返回false。
声明在文件live555sourcecontrol\groupsock\include\NetAddress.hh中
有些应用会有这样的要求：一些分布在各处的进程需要以组的方式协同工作，组中的进程通常要给其他所有的成员发送消息。即有这样的一种方法能够给一些明确定义的组发送消息，这些组的成员数量虽然很多，但是与整个网络规模相比却很小。给这样一个组发送消息称为多点点播送，简称多播。
/ 判断参数释放是一个多播地址 Boolean IsMulticastAddress(netAddressBits address) { // Note: We return False for addresses in the range 224.0.0.0 // through 224.0.0.255, because these are non-routable // 注意：我们在224.0.0.0到224.0.0.255范围地址返回false，因为这些是不可路由的 // Note: IPv4-specific ##### // 注：支持IPv4特定##### netAddressBits addressInNetworkOrder = htonl(address); return addressInNetworkOrder &amp;gt; 0xE00000FF &amp;amp;&amp;amp; addressInNetworkOrder &amp;lt;= 0xEFFFFFFF; }  多播简要说明 IP多播（也称多址广播或组播）技术，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。在网络音频/视频广播的应用中，当需要将一个节点的信号传送到多个节点时，无论是采用重复点对点通信方式，还是采用广播方式，都会严重浪费网络带宽，只有多播才是最好的选择。多播能使一个或多个多播源只把数据包发送给特定的多播组，而只有加入该多播组的主机才能接收到数据包。目前，IP多播技术被广泛应用在网络音频/视频广播、AOD/VOD、网络视频会议、多媒体远程教育、&amp;ldquo;push&amp;rdquo;技术（如股票行情等）和虚拟现实游戏等方面。</description>
    </item>
    
    <item>
      <title>34 网络相关函数(二)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-12-34-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-12-34-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/12/4724030.html 34 网络相关函数(二)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  34 网络相关函数(二)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  2)socketErr 套接口错误 3)groupsockPriv函数 4)reclaimGroupsockPriv函数     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
2)socketErr 套接口错误 socketErr是个静态方法，定义在live555sourcecontrol\groupsock\GroupsockHelper.cpp文件中。
实现很简单，把errorMsg中的内容设置到env中取。
static void socketErr(UsageEnvironment&amp;amp; env, char const* errorMsg) { env.setResultErrMsg(errorMsg); }  3)groupsockPriv函数 这个函数为其参数env成员groupsockPriv创建一个对象。
在看这个函数的时候先看一个结构体定义
struct _groupsockPriv { // There should be only one of these allocated HashTable* socketTable; // socket哈希表 int reuseFlag; //重新使用标识 };  我们回忆一下，在UsageEnvironment中有两个数据成员， void类型的指针liveMediaPriv和groupsockPriv没有使用到，而且它们是public权限的。
那么在这里，groupsockPriv成员将会进行赋值操作
groupsockPriv函数的作用就是给参数env的groupsockPriv申请一个_groupsockPriv对象。当然，是在其为NULL的情况下。
这里设置了env.groupsockPriv指向对象的两个成员的默认值，socketTable=NULL、reuseFlag=1。
_groupsockPriv groupsockPriv(UsageEnvironment&amp;amp; env) { if (env.</description>
    </item>
    
    <item>
      <title>35 网络相关函数(三)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-12-35-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%89live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-12-35-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%B8%89live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>NoReuse::NoReuse(UsageEnvironment&amp;amp;env) fEnv(env) { groupsockPriv(fEnv)-&amp;gt;reuseFlag = 0; }  &amp;nbsp;
只要env.groupsockPriv-&amp;gt;socketTable==NULL成立，就释放env.groupsockPriv指向对象。
//若groupsockPriv对象的socketTable==NULL //析构的时候为env.groupsockPriv释放对象 NoReuse::~NoReuse() { groupsockPriv(fEnv)-&amp;gt;reuseFlag = 1; reclaimGroupsockPriv(fEnv); }  &amp;nbsp;
6)initializeWinsockIfNecessary 根据需要初始化winSock 这个函数只用于windows系列操作系统。
windows网络编程是一件麻烦事，其必须要先进行一系列初始化的操作。
如果不是windows平台，这个函数会被宏替换为1，就是说必然成功。
1 #if defined(WIN32) || defined(_WIN32) 2 #ifndef IMN_PIM 3 #define WS_VERSION_CHOICE1 0x202/MAKEWORD(2,2)/ 4 #define WS_VERSION_CHOICE2 0x101/MAKEWORD(1,1)/ 5 int initializeWinsockIfNecessary(void) { 6 /*We need to call an initialization routine before 7 * we can do anything with winsock. (How fucking lame!): 8 我们需要调用初始化例程 9 之后我们可以用Winsock做任何事。（怎么他妈的没用的！）： 10 / 11 static int _haveInitializedWinsock = 0; 12 WSADATA wsadata; 13 14 if (!</description>
    </item>
    
    <item>
      <title>36 网络相关函数(四)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-12-36-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%9B%9Blive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-12-36-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%9B%9Blive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/12/4724040.html 36 网络相关函数(四)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  36 网络相关函数(四)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 7)createSocket创建socket方法 8)closeSocket 关闭套接口 9)setsockopt 设置socket套接口选项  函数原型： 参数说明： 返回说明： 注意：       本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
7)createSocket创建socket方法 createSocket使用参数type创建一个相关类型的socket套接口。如果有相关定义，将为这个套接口添加&amp;rdquo;close on exec&amp;rdquo;执行时关闭属性。
注意，这个函数是static类型的，只在本文件(live555sourcecontrol\groupsock\GroupsockHelper.cpp)内使用。
// type socket类型，有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等 static int createSocket(int type) { // Call &amp;ldquo;socket()&amp;rdquo; to create a (IPv4) socket of the specified type. // 调用&amp;ldquo;socket()创建一个（IPv4）指定类型的套接字。 // But also set it to have the &amp;lsquo;close on exec&amp;rsquo; property (if we can) // 还设置它具有&amp;ldquo;执行exec时关闭&amp;rdquo;属性（如果可以） int sock;</description>
    </item>
    
    <item>
      <title>37 网络相关函数(五)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-08-12-37-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BA%94live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-12-37-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BA%94live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/12/4724375.html 37 网络相关函数(五)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  37 网络相关函数(五)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 10)MAKE_SOCKADDR_IN构建sockaddr_in结构体宏 11)setupDatagramSocket设置数据报套接口     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络相关函数是一系列用于操作网络数据的函数。在多个文件中都有相关的函数的定义。还有一些函数是系统socket API相关函数，就不提了。
这一系列的函数大多有一个特点，需要一个UsageEnvironmet&amp;amp;型的参数。
这些方法大多在live555sourcecontrol\groupsock\include\GroupsockHelper.hh中声明。
10)MAKE_SOCKADDR_IN构建sockaddr_in结构体宏 1 #ifdef HAVE_SOCKADDR_LEN 2 #define SET_SOCKADDR_SIN_LEN(var) var.sin_len = sizeof var 3 #else 4 #define SET_SOCKADDR_SIN_LEN(var) 5 #endif 6 7 //sockaddr_in var,使用adr和prt为其赋值(AF_INET) 8 #define MAKE_SOCKADDR_IN(var,adr,prt) /adr,prt must be in network order/
9 struct sockaddr_in var;
10 var.sin_family =AF_INET;
11 var.sin_addr.s_addr =(adr);
12 var.sin_port =(prt);</description>
    </item>
    
    <item>
      <title>SNMP简单网络管理协议(转载)</title>
      <link>http://sotex.github.io/post/2015-08-10-snmp%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Mon, 10 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-10-snmp%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE%E8%BD%AC%E8%BD%BD/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/10/4717911.html SNMP
SNMP 网络管理的历史 美国国防部设计了世界上头几个包交换网之一的ARPANET，在70年代，TCP/IP协议族正式被定为军方通信标准，随着此协议的广泛使用，网络管理成了一件大事。在80年代未和90年代初，网络迅速发展，许多子网数目的增多使监视网络活动成为一种必须。
在网络管理的初期，对网络的管理停留在使用ICMP和PING的基础上，但是随着网络内主机数据的不断增多，这种简单的工具已经不可能完成网络管理的工作了。
SNMP历史 随着网络数目与网络内主机数目的日益增多，单纯依靠一些网络专业进行网络管理已经不可能了，必须有一种通行的网络管理标准以及相应的管理工具使普通人也能够管理网络。第一个相关的协议是SGMP，它提供了一种直接监视网关的方法，也因此成了一种通用的网络管理工具。下来，有三种可供选择的管理工具：HEMS，SNMP和建立在TCP/IP基础上的CMIP（CMOT），因为需要使用ISO/OSI模型进行网络管理，SNMP首选CMOT作为管理工具。基本的SNMP已经被广泛使用了，所有的网络产品都提供对SNMP的支持，新开发的具有远程管理能力的SNMP是RMON，它使管理人员可以将整个子网进行管理，而不是对整个子网内的设备进行管理。
一些定义 SNMP，Simple Network Management Protocol：简单网络管理协议它是一个标准的用于管理IP网络上结点的协议。此协议包括了监视和控制变量集以及用于监视设备的两个数据格式：SMI和MIB。MIB，Management Information Base：管理信息库由网络管理协议访问的管理对象数据库，它包括SNMP可以通过网络设备的SNMP管理代理进行设置的变量。SMI，Structure of Management Information：管理信息结构用于定义通过网络管理协议可访问的对象的规则。SMI定义在MIB中使用的数据类型及网络资源在MIB中的名称或表示。ASN.1，Abstract Syntax Notation One：抽象语法定义用于定义语法的正式语言，在SNMP中它用于定义SNMP协议数据单元和对象的格式。PDU，Protocol Data Unit：协议数据单元在网络中传送的数据包。BER，basic encoding rules：基本编码规则由CCITT (X.209)和ISO (ISO 8825)指定的编码规则，它描述了如何将ASN.1类型表示为字符串。 SNMP介绍 使用SNMP进行网络管理需要下面几个重要部分：管理基站，管理代理，管理信息库和网络管理工具。管理基站通常是一个独立的设备，它用作网络管理者进行网络管理的用户接口。基站上必须装备有管理软件，管理员可以使用的用户接口和从MIB取得信息的数据库，同时为了进行网络管理它应该具备将管理命令发出基站的能力。
管理代理是一种网络设备，如主机，网桥，路由器和集线器等，这些设备都必须能够接收管理基站发来的信息，它们的状态也必须可以由管理基站监视。管理代理响应基站的请求进行相应的操作，也可以在没有请求的情况下向基站发送信息。
MIB是对象的集合，它代表网络中可以管理的资源和设备。每个对象基本上是一个数据变量，它代表被管理的对象的一方面的信息。
最后一个方面是管理协议，也就是SNMP，SNMP的基本功能是：取得，设置和接收代理发送的意外信息。取得指的是基站发送请求，代理根据这个请求回送相应的数据，设置是基站设置管理对象（也就是代理）的值，接收收代理发送的意外信息是指代理可以在基站未请求的状态下向基站报告发生的意外情况。
MIB和对象 MIB包括了对象列表，这些对象与指示对象类型的OBJECT IDENTIFIER相关。MIB的结构是树形结构，有两种方式可以访问MIB中对象的值，一种是快速访问，另一种慢速访问，快速访问时只用输入一些数据，慢速访问时要加上其它信息。
SNMP MIB是对象的定义是十分严格的，定义指定了对象的数据类型，允许的形式，取值范围和与其它MIB对象的关系。ASN.1定义方法用来定义每个对象，同时也定义整个MIB结构。
有两种不同对象数据结构：通用类型的专用类型，通用类型指的是整数，字符串，空值，对象标识，序列和序列号；专用类型是指网络地址，IP地址，记数器，标准等。
若要定义对象自身，必须使用ASN.1。下面是一个基本的定义结构：
 &amp;lt;模块名&amp;gt; DEFINITIONS ::= BEGIN EXPORTS IMPORTS AssignmentList End 软件 应用程序可以显示SNMP数据，NAS公司开发的应用程序HNMS就是这方面的一个比较好的工具。详细情况请参阅：http://www.nas.nasa.gov/Groups/LAN/Trouble/HNMS.html
如果不想花钱可以在下面一些地方取得免费的管理软件
 ftp://ftp.ida.liu.se/pub/isode-snmpV2/isode-8.tar.gz ftp://allspice.lcs.mit.edu/pub/snmp/ ftp://ftp.net.cmu.edu/pub/snmp-dist/cmu-snmp2.1.2.tar ftp://ftp.cs.utwente.nl:/pub/src/snmp ftp://ftp.ece.ucdavis.edu/pub/snmp/ucd-snmp.tar.gz http://www.cs.tu-bs.de/ibr/projects/nm/tkined/ http://www.cs.tu-bs.de/ibr/projects/nm/scotty/  体系结构  所有在应用层下的TCP/IP层都有它自己的SNMP结构 硬件制造商可以在它的产品中实现了相应的管理结构 从图上可以看到有许多MIB，但服务器只有一台  服务器处理过程  基站发送的请求仅有两种类型，取值和赋值 一个请求可以进行多个操作  ASN.</description>
    </item>
    
    <item>
      <title>net-snmp配置:snmp v3的安全配置</title>
      <link>http://sotex.github.io/post/2015-08-10-net-snmp%E9%85%8D%E7%BD%AE-snmp-v3%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-10-net-snmp%E9%85%8D%E7%BD%AE-snmp-v3%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/10/4718207.html net-snmp配置:snmp v3的安全配置  net-snmp配置:snmp v3的安全配置  增加snmp v3用户  增加 认证且加密只读账号(authPriv) 增加 认证且加密的读写账户 增加 认证但不加密只读账户(authNoPriv)  参数说明     重新启动snmpd 测试一下  测试认证且加密只读账户fx 测试认证且加密读写账户fxw 测试认证不加密只读账户fxa 注意事项  snmpwalk权限设置导致的超时 snmpset安全等级设置与认证和加密设置不对等时候的报错 snmpset使用noAuthNoPriv不认证不加密方式报错         可以参考这里：http://www.ttlsa.com/zabbix/snmp-v3-configuration/
增加snmp v3用户 增加 认证且加密只读账号(authPriv) o@o-pc:~$ sudo service snmpd stop #停止snmpd服务 o@o-pc:~$ sudo net-snmp-create-v3-user -ro -A auth123456 -X priv123456 -a MD5 -x DES fx #创建snmpv3用户
adding the following line to /var/net-snmp/snmpd.</description>
    </item>
    
    <item>
      <title>net-snmp子代理(SubAgent)编写详述</title>
      <link>http://sotex.github.io/post/2015-08-06-net-snmp%E5%AD%90%E4%BB%A3%E7%90%86subagent%E7%BC%96%E5%86%99%E8%AF%A6%E8%BF%B0/</link>
      <pubDate>Thu, 06 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-08-06-net-snmp%E5%AD%90%E4%BB%A3%E7%90%86subagent%E7%BC%96%E5%86%99%E8%AF%A6%E8%BF%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/08/06/4708581.html net-snmp子代理(SubAgent)编写  net-snmp子代理(SubAgent)编写  Netsnmp_Node_Handler MIB/OID定义 1、头文件test.h的编写 2、test.c的编写  init_test函数编写 handle_readObject函数实现(只读节点) handle_writeObject函数实现(读写节点)   3、main函数的编写  main.c完整代码   4、写一个简单的makefile     可以使用mib2c生成子代理的代码来编写子代理程序，但是这个方式并不利于我们来学习这个开发过程。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
Netsnmp_Node_Handler 先来看一个类型定义
在net-snmp源码目录include/net-snmp/agent/下的agent_handler.h文件中有如下定义：
1 typedef int (Netsnmp_Node_Handler) (netsnmp_mib_handler handler, 2 /* pointer to registration struct / 3 /* 指针，指向注册结构体 */ 4 netsnmp_handler_registration reginfo, 5 /* pointer to current transaction / 6 /* 指针，指向当前处理信息 */ 7 netsnmp_agent_request_info *reqinfo, 8 netsnmp_request_info requests);  这个类型就是一个函数指针，它是用来声明OID对应的handler函数的。</description>
    </item>
    
    <item>
      <title>PictureCutting图片批量裁切(裁剪)工具</title>
      <link>http://sotex.github.io/post/2015-07-31-picturecutting%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E8%A3%81%E5%88%87%E8%A3%81%E5%89%AA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-31-picturecutting%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E8%A3%81%E5%88%87%E8%A3%81%E5%89%AA%E5%B7%A5%E5%85%B7/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/31/4691745.html PictureCutting图片批量裁切(裁剪)工具 写这个工具的原因是因为在获取一个软件的皮肤包中的图片的时候需要进行批量的裁切工作，而有没有找到在linux下简单好用的工具，干脆就用QT写了一个。
项目地址 &amp;nbsp;https://git.oschina.net/oloroso/PictureCutting.git
批量裁切 批量裁切是这个软件的主要功能。单击按钮添加要进行处理的图片，然后在右侧选择裁切方式和设置裁切参数，左下角选择裁切输出参数和输出的目录和文件名选项，点击开始按钮即可。
按比例裁切 指的是按照上下左右裁去部分的方式。 例如原图是1200*900大小的，现在裁切比例设置为 上：10%、下：20%、左：20%、右：50%，那么将会裁切出原图中起点坐标为240,90高宽为360*630`大小的部分。&amp;nbsp;
横纵向均分裁切 这个就简单了，就是将图片按照等分的原则均分为多张图片。例如原图为1200*900现在横向分3份，纵向分3份，那就把原图分成了9张400*300大小的图片了。</description>
    </item>
    
    <item>
      <title>gcc编译时对&#39;xxxx&#39;未定义的引用问题</title>
      <link>http://sotex.github.io/post/2015-07-30-gcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%AF%B9xxxx%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-30-gcc%E7%BC%96%E8%AF%91%E6%97%B6%E5%AF%B9xxxx%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/30/4688426.html gcc编译时对&amp;rsquo;xxxx&amp;rsquo;未定义的引用问题  gcc编译时对&amp;rsquo;xxxx&amp;rsquo;未定义的引用问题  原因 解决办法  gcc 依赖顺序问题       在使用gcc编译的时候有时候会碰到这样的问题，编译为.o(obj) 文件没有问题，但是编译(这一步应该是链接)为可执行文件的时候会出现找不到&amp;rsquo;xxx&amp;rsquo;的定义的情况。
本文由乌合之众 lym瞎编，欢迎转载blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
例如：
g++ -o spider -rdynamic -lpthread -levent -lcrypt -ldl bloomfilter.o confparser.o crc32.o dso.o hashs.o md5.o qstring.o sha1.o socket.o spider.o threads.o url.o &amp;hellip;
dso.o：在函数&amp;lsquo;dso_load(char const, char const)&amp;rsquo;中： dso.cpp:(.text+0x3c)：对&amp;lsquo;dlopen&amp;rsquo;未定义的引用 dso.cpp:(.text+0x4c)：对&amp;lsquo;dlsym&amp;rsquo;未定义的引用 dso.cpp:(.text+0xb5)：对&amp;lsquo;dlerror&amp;rsquo;未定义的引用 dso.cpp:(.text+0x13e)：对&amp;lsquo;dlclose&amp;rsquo;未定义的引用  原因 出现这种情况的原因，主要是C/C++编译为obj文件的时候并不需要函数的具体实现，只要有函数的原型即可。但是在链接为可执行文件的时候就必须要具体的实现了。如果错误是未声明的引用，那就是找不到函数的原型，解决办法这里就不细致说了，通常是相关的头文件未包含。
解决办法 指定原因就好办了，既然知道是缺少了函数的具体实现，那么就给它这个函数的实现就好了。比如上面的例子，是因为缺失了dlopen、dlsym、dlerror、dlclose这些函数的实现，这几个函数是用于加载动态链接库的，编译的时候需要添加-ldl来使用dl库(这是静态库，在系统目录下/usr/lib/i386-linux-gnu/libdl.a、/usr/lib/x86_64-linux-gnu/libdl.a)。
但是看上面编译的时候是有添加-ldl选项的，那么为什么不行呢？
gcc 依赖顺序问题 这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。
在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。
例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。&amp;nbsp;gcc main.c -lpthread -o a.out&amp;nbsp;。</description>
    </item>
    
    <item>
      <title>linux下QtCreator无法输入中文的情况</title>
      <link>http://sotex.github.io/post/2015-07-30-linux%E4%B8%8Bqtcreator%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E6%83%85%E5%86%B5/</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-30-linux%E4%B8%8Bqtcreator%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E6%83%85%E5%86%B5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/30/4688244.html 解决linux下QtCreator无法输入中文的情况 本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
安装了QtCreator(Qt5.3.1自带版本)后无法输入中文，确切的说是无法打开输入法。以前使用iBus输入法的时候没有这个问题，现在使用sougou输入法才有的这个问题。
可以查看此文 http://www.cnblogs.com/oloroso/p/5114041.html
原因 有问题就得找原因，搜狗输入法是基于fcitx来做的，那么可能是缺少了相关的库支持。
解决办法 先安装fcitx-libs-qt和fcitx-libs-qt5这两个库。
sudo apt-get install fcitx-libs-qt fcitx-libs-qt5
安装后问题 安装了这两个库，发现也没有效果，还是无法输入中文。在网上找了一些解决办法，原因是在Qt5开发环境缺少fcix for Qt5动态库上面。
在QT安装目录下的/Tools/QtCreator/bin/plugins目录下的platforminputcontexts(平台输入上下文)目录下有相关的动态库来支持相关的输入法。
因为QT相关的程序没有使用系统的相关依赖库支持，所以出现这个问题。现在从系统依赖库目录把相关的动态库拷贝过来，就可以了。
拷贝动态库到QT安装目录 前面sudo apt-get install fcitx-libs-qt5将库文件libfcitxplatforminputcontextplugin.so安装在目录/usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/下，我们把它拷贝到QT安装目录下。
cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so ~/Qt5.4.1/Tools/QtCreator/bin/plugins/platforminputcontexts/
拷贝完成之后需要更改权限
chmod +x libfcitxplatforminputcontextplugin.so
编译的Qt开发程序无法输入中文解决 还是和上面一样的原因，也是缺少了libfcitxplatforminputcontextplugin.so这个动态库。将其拷贝到
~/Qt5.4.1&amp;frasl;5.4/gcc_64/plugins/platforminputcontexts/目录下，然后修改其权限即可了。
至此，QtCreator中输入中文的问题就解决了。</description>
    </item>
    
    <item>
      <title>SNMP报文抓取与分析(二)</title>
      <link>http://sotex.github.io/post/2015-07-28-snmp%E6%8A%A5%E6%96%87%E6%8A%93%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90%E4%BA%8C/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-28-snmp%E6%8A%A5%E6%96%87%E6%8A%93%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90%E4%BA%8C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/28/4682502.html SNMP报文抓取与分析(二)  SNMP报文抓取与分析(二) 1、SNMP报文表示简介  基本编码规则BER  标识域Tag表示 长度域length表示     2、SNMP报文详细分析(以一个get-response报文为例)  2.1、数据包分析结果(以get-response为例)  get-response报文示例分析(b.hex)   2.1、SNMP首部 2.3、SNMP版本表示 2.4、Community共同体表示   3、PUD表示  PDU类型表示 get/set的表示  请求标识符Request ID 错误状态error-state 错误索引error-index 变量绑定   trap(notification) 一些数据类型的编码表示  Integer整型编码表示 OID对象标识符编码表示 sequence组合类型       在上一篇文章(SNMP报文抓取与分析(一))中已经介绍了怎么使用netcat来抓取数据包了。也给出了对数据包分析的结果。本篇文章将介绍具体的分析过程。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
1、SNMP报文表示简介 SNMP(简单网络管理协议)是目前在计算机网络中用得最广泛的网络管理协议,它使用ASN.1(Abstract Syntax Notation One抽象语法表示法.1)来定义SNMP报文格式和MIB(Management Information Base管理信息库)变量的名称。
ASN.1是一种描述数据和数据特征的正式语言,它和数据的存储及编码无关。
根据ASN.1标准定义,数据类型分为:
简单数据类型: boolean布尔值、null空、integer整型、real实数、octerstring八进制字符串、object identifier对象标识、ipaddressIP地址、time ticks时刻值等。</description>
    </item>
    
    <item>
      <title>SNMP报文抓取与分析(一)</title>
      <link>http://sotex.github.io/post/2015-07-23-snmp%E6%8A%A5%E6%96%87%E6%8A%93%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90%E4%B8%80/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-23-snmp%E6%8A%A5%E6%96%87%E6%8A%93%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90%E4%B8%80/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/23/4671184.html SNMP报文抓取与分析(一) 1、抓取SNMP报文 SNMP报文的形式大致如下图所示
我们这里使用netcat这个工具来抓取snmp的PDU（协议数据单元）。（因为我们并不需要前面的IP和UDP首部）
关于netcat的一些基本使用可以看这里http://www.cnblogs.com/oloroso/p/4610563.html
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
netcat获取snmp报文 1 先获取snmpwalk发出的(get-next-request) 我们使用nc来监听161端口，然后把输出重定向到文件a.hex。因为监听的是161端口，所以这里必须以root权限运行。
sudo nc -u -l 161 &amp;gt;a.hex  这样之后使用snmpwalk这个工具来向这个&amp;ldquo;受控端&amp;rdquo;发送命令。
snmpwalk -c public -v 2c localhost 1.3.6.1.4.201566.1.1  2 再获取代理程序发回的(get-response) 我们先要打开代理程序Agent，然后使用下面的命令将a.hex的内容发给代理程序，并将接收到的返回保存到b.hex
o@o-pc:~/snmpPUD$ nc -u 127.0.0.1 161 &amp;lt;a.hex &amp;gt;b.hex ^C o@o-pc:~/snmpPUD$  下图是针对SNMPv1版本的。目前比较通用的是SNMP v2c/v3版本，具有八种PDU类型。
分析获取到的报文 先使用hexdump来查看一下获取到的报文内容。（hexdump是一个很好用的十六进制分析工具）
o@o-pc:~/snmpPUD$ hexdump -C a.hex 00000000 30 2c 02 01 01 04 06 70 75 62 6c 69 63 a1 1f 02 |0,&amp;hellip;.</description>
    </item>
    
    <item>
      <title>我的Vim配置(自动补全/树形文件浏览)</title>
      <link>http://sotex.github.io/post/2015-07-23-%E6%88%91%E7%9A%84vim%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8.%E6%A0%91%E5%BD%A2%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-23-%E6%88%91%E7%9A%84vim%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8.%E6%A0%91%E5%BD%A2%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/23/4670165.html 配置文件的下载路径在这里 &amp;nbsp;http://files.cnblogs.com/files/oloroso/vim.configure.xz.gz&amp;nbsp; 这实际上是一个&amp;nbsp;xz 格式的文件，添加的&amp;nbsp;gz 文件后缀是因为博客园上传文件的限制
&amp;nbsp;
&amp;nbsp;
.vimrc文件的内容如下 &amp;ldquo;==========================================================================&amp;ldquo;======================= 基本显示设置 ==================================&amp;ldquo;==========================================================================
&amp;ldquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ldquo;行号与标尺 set ruler &amp;ldquo;右下角显示光标位置的状态行 set number &amp;ldquo;显示行号 set cursorline &amp;ldquo;突出显示当前行
&amp;ldquo;设置行号的颜色和背景(这在设置了colorscheme可能会无效) if has(&amp;ldquo;gui_running&amp;ldquo;) highlight LineNr guifg=red &amp;ldquo;gui模式下字体颜色设置 highlight LineNr guibg=white &amp;ldquo;gui模式下背景颜色设置 elsehighlight LineNr ctermfg=yellow &amp;ldquo;彩色终端下字体颜色设置 highlight LineNr ctermbg=blue &amp;ldquo;彩色终端下背景颜色设置 endif
&amp;ldquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ldquo;制表符(设置所有的tab和缩进为4个空格) set tabstop=4 &amp;ldquo;设置tab键的宽度 set shiftwidth=4 &amp;ldquo;换行时行间交错使用4个空格&amp;ldquo;set cindent shiftwidth=4 &amp;ldquo;自动缩进4空格 set softtabstop=4 &amp;ldquo;set expandtab &amp;ldquo;使用空格来替换tab set smarttab &amp;ldquo;开启新行时使用智能 tab 缩进
&amp;ldquo;set list &amp;ldquo;显示Tab符， &amp;ldquo;set listchars=tab:|\ , &amp;ldquo; 使用一高亮竖线代替 把符号显示为 | &amp;ldquo;set listchars=tab:&amp;gt;-,trail:-&amp;ldquo;set listchars=tab:|\ ,nbsp:%,trail:-</description>
    </item>
    
    <item>
      <title>U盘安装ubuntu server 14.04</title>
      <link>http://sotex.github.io/post/2015-07-21-u%E7%9B%98%E5%AE%89%E8%A3%85ubuntu-server-14.04/</link>
      <pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-21-u%E7%9B%98%E5%AE%89%E8%A3%85ubuntu-server-14.04/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/21/4665107.html U盘安装ubuntu server 14.04  U盘安装ubuntu server 14.04  1、制作启动u盘 2、开始安装  1 将u盘插入主机，重启后从u盘启动 2 选择语言(随便挑，随便选)，我选的是简体中文，回车 3选择安装ubuntu 服务器版，回车 4选择语言，一路回车继续 5遇到无法挂载安装光盘错误No CD-ROM drive was detected 6一路继续，后面的过程应该是畅通无阻了。       使用u盘安装系统是比较方便的，也很简单。现在网上有很多iso to usb disk的工具，我推荐使用LinuxLive USB Creator。
使用U盘安装ubuntu 桌面版通常不会有问题，但是安装服务器版的时候却容易出现检查不到光驱(No CD-ROM drive was detected)的问题。网上有一些说法是安装的时候添加启动参数install cdrom-detect/try-usb=true，但实际上这不适用于ubuntu server 14。
1、制作启动u盘 看下面这张图应该就可以了吧。
2、开始安装 1 将u盘插入主机，重启后从u盘启动 这一步就没有什么好说的了。  2 选择语言(随便挑，随便选)，我选的是简体中文，回车 3选择安装ubuntu 服务器版，回车 4选择语言，一路回车继续 &amp;nbsp;5遇到无法挂载安装光盘错误No CD-ROM drive was detected 选择否
选择继续
选择运行shell，进入ash
&amp;nbsp; &amp;nbsp;</description>
    </item>
    
    <item>
      <title>vim帮助手册汉化</title>
      <link>http://sotex.github.io/post/2015-07-21-vim%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C%E6%B1%89%E5%8C%96/</link>
      <pubDate>Tue, 21 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-21-vim%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C%E6%B1%89%E5%8C%96/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/21/4664858.html vim帮助手册汉化  vim帮助手册汉化  下载vimcdoc-1.9.0.tar.gz 安装vimcodc-1.9.0     vim命令模式下输入help可以查看vim的帮助手册。美中不足的是这个帮助手册是英文的，这让很多爱国者们犯难了。好在有热心人士将其翻译成了中文的，帮助到了很多人。
下载vimcdoc-1.9.0.tar.gz 这个文件的下载地址是http://jaist.dl.sourceforge.net/project/vimcdoc/vimcdoc/vimcdoc-1.9.0.tar.gz
wget http://jaist.dl.sourceforge.net/project/vimcdoc/vimcdoc/vimcdoc-1.9.0.tar.gz  安装vimcodc-1.9.0  1 首先解压压缩包
bash tar -xzvf vimcdoc-1.9.0.tar.gz 2 运行./vimcdoc.sh
./vimcodc.sh -i
这个脚本有三个互斥参数可以选择，分别是：
参数-i是安装 vimcdoc 并将设置 helplang(help语言)
参数-I是仅安装vimcdoc
参数-u是卸载 &amp;nbsp;
  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>QT 信号与槽connect</title>
      <link>http://sotex.github.io/post/2015-07-17-qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BDconnect/</link>
      <pubDate>Fri, 17 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-17-qt-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BDconnect/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/17/4653770.html QT 信号与槽connect  QT 信号与槽connect  connect函数调用几个限制 connect函数代码     QT中信号与槽的连接使用的connect函数是一个静态函数，在类QObject中定义。这里说的是QT5环境下。更详细的介绍可以看这里http://www.devbean.net/2012/12/how-qt-signals-and-slots-work-qt5/
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
connect函数调用几个限制   1. 信号的发送者必须是QObject的派生类对象。不然会出现error: invalid conversion from &amp;lsquo;XXX&amp;rsquo; to &amp;lsquo;const QObject&amp;rsquo; [-fpermissive]&amp;hellip;的错误。
  2. 回调槽函数的对象必须是QObject的派生类对象。不然会出现error: no matching function for call to &amp;lsquo;QObject::connect(XXX*,的错误。这里要注意一点，信号函数无论存在与否，都不会报错的。但是如果信号的发送者是NULL，那么会在运行的时候提示QObject::connect: Cannot connect (null)::信号函数() to 接收者::槽函数()的问题。
  对于1,2两点，在connect函数调用的时候强转类型也可以通过编译，但是运行的时候会提示No such slot QObject::的问题。
  3. 槽函数所在的类的定义中必须添加宏Q_OBJECT，不然会出现QObject::connect: No such slot &amp;hellip;的错误。
这里必须和第2点联系起来，如果添加了Q_OBJECT宏的类不是从QObject派生的，moc生成中间文件的时候会报错Error: Class contains Q_OBJECT macro but does not inherit from QObject。</description>
    </item>
    
    <item>
      <title>5-python学习——条件语句</title>
      <link>http://sotex.github.io/post/2015-07-15-5-python%E5%AD%A6%E4%B9%A0%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-15-5-python%E5%AD%A6%E4%B9%A0%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/15/4648619.html 5-python学习&amp;mdash;&amp;mdash;条件语句  5-python学习&amp;mdash;&amp;mdash;条件语句  条件语句if else形式 if else条件语句说明  测试一下       编程语言一般都由这么几个部分组成
 变量 条件分支语句 循环语句 函数  这里要说的就是条件分支语句。
python的条件语句和shell脚本的非常像，也就是if else if else这种形式，其中else if可以缩写为elif。
条件语句if else形式 if &amp;lt;条件判断1&amp;gt;: &amp;lt;执行1&amp;gt; elif &amp;lt;条件判断2&amp;gt;: &amp;lt;执行2&amp;gt; elif &amp;lt;条件判断3&amp;gt;: &amp;lt;执行3&amp;gt; else: &amp;lt;执行4&amp;gt;  if else条件语句说明 if后面跟的是判断条件，对于条件，可以进行类似于C语言中的隐式转换为true或false。非零数值、非空字符串、非空list等，判断为True，否则为False。
测试一下 #! /usr/bin/python3.4
if 100: print(&amp;ldquo;100 &amp;ndash;&amp;gt; true&amp;rdquo;)
true = &amp;ldquo;&amp;rdquo;
if true: print(&amp;ldquo;true&amp;rdquo;) else: print(&amp;ldquo;true在这里是一个空的值&amp;rdquo;) true = 100
if true: print(true)  o@o-pc:~$ python3 test.</description>
    </item>
    
    <item>
      <title>linux下一个有意思的问题(文件名以短划线或空格开头)</title>
      <link>http://sotex.github.io/post/2015-07-15-linux%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98%E6%96%87%E4%BB%B6%E5%90%8D%E4%BB%A5%E7%9F%AD%E5%88%92%E7%BA%BF%E6%88%96%E7%A9%BA%E6%A0%BC%E5%BC%80%E5%A4%B4/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-15-linux%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%97%AE%E9%A2%98%E6%96%87%E4%BB%B6%E5%90%8D%E4%BB%A5%E7%9F%AD%E5%88%92%E7%BA%BF%E6%88%96%E7%A9%BA%E6%A0%BC%E5%BC%80%E5%A4%B4/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/15/4648711.html linux下一个有意思的问题(文件名以短划线开头) 这本是无意中的一个发现。
在linux下，文件名中含有 - 是没有问题，但是如果文件名是以-作为第一个字符的，那么就比较麻烦了。
&amp;nbsp;
问题演示 看这里，以短划线开头的文件名似乎对mv cp&amp;nbsp; rm &amp;nbsp; 等操作免疫了。利用这个特性可以制造出一些比较麻烦的文件或者文件夹来。
o@o-pc:~$ ls -python.md o@o-pc:~$ mv -python.md 5-python.md mv：无效选项 &amp;ndash;p Try &amp;lsquo;mv &amp;ndash;help&amp;lsquo; for moreinformation. o@o-pc:~$ mv &amp;ldquo;-python.md&amp;ldquo; 5-python.md mv：无效选项 &amp;ndash;p Try &amp;lsquo;mv &amp;ndash;help&amp;lsquo; for more information.  &amp;nbsp;
解决办法 这个其实很好解决的嘛，问题的原因是因为其将&amp;nbsp;-当做了一个选项参数的标识，而导致找不到对应的文件。解决的办法就是想办法把这个-给隐藏起来咯。
o@o-pc:~$ mv ./-python.md 5-pythom.md  &amp;nbsp;
文件名以空格开头  这里不打算说太多，原理是一样的。如果文件名以空格开头，必须知道空格的数目。
将要操作的文件名以单引号&amp;nbsp; &amp;ldquo; 包裹起来
例如有一个文件名为&amp;nbsp;&amp;rdquo; A&amp;ldquo; 注意，该文件名为三个空格加一个字母A。如果对其重命名，使用以下命令
mv ` A&amp;lsquo;新文件名  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>一个简单的中英文翻译脚本</title>
      <link>http://sotex.github.io/post/2015-07-13-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-13-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/13/4642092.html 这个脚本是很久之前写的，主要就是方便使用。
把它保存为&amp;nbsp;fy.sh 然后丢到&amp;nbsp;/usr/bin 目录下。
示例 o@o-pc:~$ fy.shhello world hello 你好世界 o@o-pc:~$ fy.sh你好世界 Hello world  脚本代码如下 #! /bin/bash
#curl etoc.sinaapp.com/英文
url=&amp;ldquo;ctoe.sinaapp.com/&amp;ldquo;var=&amp;rdquo;&amp;rdquo;$1 echo $var|grep 1*$ if [ $? == 0] thenurl=&amp;ldquo;etoc.sinaapp.com/&amp;ldquo; fi#echo${url}
for var in$@ dourl=${url}&amp;ldquo;%20&amp;ldquo;${var} donecurl $url  &amp;nbsp;
 0-9A-Za-z [return]   </description>
    </item>
    
    <item>
      <title>linux下安装使用libuuid(uuid-generate)</title>
      <link>http://sotex.github.io/post/2015-07-09-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8libuuiduuid-generate/</link>
      <pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-09-linux%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8libuuiduuid-generate/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/09/4633744.html linux下安装使用libuuid(uuid-generate)  linux下安装使用libuuid(uuid-generate)  UUID简介 安装libuuid库 编写一个程序试一下  代码 编译运行       UUID简介 UUID含义是通用唯一识别码(Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。
UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字
UUID由以下几部分的组合：
 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。
 UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个x是0-9 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)
在linux下生成UUID可以使用libuuid的uuid-generate函数
安装libuuid库 libuuid是一个跨平台的开源的uuid操作库。一般的机器上默认是没有，先安装一下。
sudo apt-get install uuid-dev  也可以下载源码来安装，下载地址http://nchc.dl.sourceforge.net/project/libuuid/libuuid-1.0.3.tar.gz
安装之后可以使用man uuid_generate来查看一下使用方法
这里先说一下uuid_t这个类型。可以找到uuid.h这个头文件，里面有一行typedef unsigned char uuid_t[16];
#include &amp;lt;uuid.h&amp;gt; void uuid_generate(uuid_t out); void uuid_generate_random(uuid_t out); void uuid_generate_time(uuid_t out); int uuid_generate_time_safe(uuid_t out);  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>linux下编译安装boost库</title>
      <link>http://sotex.github.io/post/2015-07-09-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85boost%E5%BA%93/</link>
      <pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-09-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85boost%E5%BA%93/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/09/4632848.html linux下编译安装boost库  linux下编译安装boost库  1、下载并解压boost 1.58 源代码  下载 解压   2、运行bootstrap.sh 3、使用b2进行构建  构建成功的提示   4、安装boost库到指定目录 5、测试一下  代码 编译运行       先看一下系统环境
Linux o-pc 3.19.0-22-generic #22-Ubuntu SMP Tue Jun 16 17:15:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
 本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
1、下载并解压boost 1.58 源代码 可以去boost的官网下载，这里提供一个下载地址
下载 wget http://jaist.dl.sourceforge.net/project/boost/boost/1.58.0/boost_1_58_0.tar.bz2  解压 tar -xjf boost_1_58_0.tar.bz2  2、运行bootstrap.sh bootstrap.sh是用来检查安装环境的，如果报错了，看一下是缺少了什么，安装一下即可(g++)。</description>
    </item>
    
    <item>
      <title>30 GroupSock(Port)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-08-30-groupsockportlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-08-30-groupsockportlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/08/4629190.html 30 GroupSock(Port)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  30 GroupSock(Port)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 Port类的定义 Port的构造与全局的 &amp;lt;&amp;lt; 运算符重载     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 端口类是用于保存网络端口的，计算机网络端口一般有两种含义，分别是物理意义上的网络设备接口和逻辑意义上的端口。这里指的就是逻辑意义上的端口(特指TCP/IP协议中端口)，端口的范围是0到65535(u_int16_t的表示范围)。
Port类只有一个数据成员portNumBits fPortNum，用于保存端口值。保存的是以网络字节序表示的(网络字节序是大端序)。
字节序在这里稍微提一下。字节序分为大端序和小端序。拿这里来说，fPortNum是16bits的，其占了两个字节。假如它代表的内存区块是0x1000和0x1001这两个字节，其保存的内容是0x5678，那么是那个字节表示0x56那个字节是0x78呢？这就涉及到字节序的问题了。通常把低地址保存低位，高地址保存高位的叫做小端序。反之为大端序。
  内存地址小端序表示0x5678大端序表示 0x5678 
   0x1001 0x56 0x78
  0x1000 0x78 0x56


 Port类的定义 1 typedef u_int16_t portNumBits; 2 classPort { 3 public: 4 Port(portNumBits num /in host byte order /); 5 6 portNumBits num() const //in network byte order 7 { 8 returnfPortNum; 9 } 10 11 private: 12 portNumBits fPortNum; //stored in network byte order 13 #ifdef IRIX 14 portNumBits filler; //hack to overcome a bug in IRIX C++ compiler 15 #endif 16 };  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>31 GroupSock(AddressString)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-08-31-groupsockaddressstringlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-08-31-groupsockaddressstringlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/08/4629193.html 31 GroupSock(AddressString)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  31 GroupSock(AddressString)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 AddressString类定义 AddressString::init方法 AddressString构造与析构     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 AddressString类是用于以点分十进制的C风格字符串形式保存的IP地址，这是为了替换&amp;ldquo;inet_ntoa()&amp;rdquo;,因为它不是线程安全的。这里就不介绍什么是线程安全了，inet_ntoa内部存在静态变量，在不同的线程中调用可能会导致混乱。
AddressString类定义了一个数据成员fVal用于动态申请内存来保存数据，注意这个类目前只能用于IPv4的地址保存，对于IPv6还未做支持。
AddressString类定义 1 //A mechanism for displaying an IPv4 address in ASCII. This is intended to replace &amp;ldquo;inet_ntoa()&amp;ldquo;, which is not thread-safe. 2 //一种机制，用于ASCII码显示IPv4地址。这是为了替换&amp;rdquo;inet_ntoa()&amp;ldquo;,因为这是不是线程安全的。 3 classAddressString { 4 public: 5 AddressString(struct sockaddr_in const&amp;amp;addr); 6 AddressString(struct in_addr const&amp;amp;addr); 7 AddressString(netAddressBits addr); //&amp;ldquo;addr&amp;rdquo; is assumed to be in host byte order here 8 9 virtual ~AddressString(); 10 11 char const* val() const { returnfVal; } 12 13 private: 14 void init(netAddressBits addr); //used to implement each of the constructors 15 16 private: 17 char* fVal; //The result ASCII string: allocated by the constructor; deleted by the destructor 18 //其结果是ASCII码字符串：由构造函数分配;在析构函数中删除 19 };  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>32 GroupSock(AddressPortLookupTable)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-08-32-groupsockaddressportlookuptablelive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-08-32-groupsockaddressportlookuptablelive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/08/4629201.html 32 GroupSock(AddressPortLookupTable)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  32 GroupSock(AddressPortLookupTable)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 AddressPortLookupTable的定义 AddressPortLookupTable构造与析构 Add方法(添加表项) Remove方法(移除表项) Lookup方法(查找表项) AddressPortLookupTable迭代器方法     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 AddressPortLookupTable地址端口查找表类
AddressPortLookupTable类内部定义了一个HashTable* fTable用于保存哈希表的地址。在构造函数中动态创建了一个哈希表对象给它。AddressPortLookupTable使用了两个地址和一个端口号组合作为一个key，value是Add方法的时候确定的。
AddressPortLookupTable类只提供了增删查三种操作，没有提供修改表项的操作。
使用哈希表的优点在于可以快速的查找key对应的value。
AddressPortLookupTable的定义 1 //A generic table for looking up objects by (address1, address2, port) 2 //用于查找对象,通过一个通用表（地址1，地址2，端口） 3 classAddressPortLookupTable { 4 public: 5 //为内部哈希表fTable创建对象，哈希表的key是3个元素的unsigned int数组 6 AddressPortLookupTable(); 7 //释放内部哈希表fTable 8 virtual ~AddressPortLookupTable(); 9 10 //使用address1、address2、port组成key,value为值添加到哈希表 11 //如果对应key的条目已经存在，返回旧的value，否则返回NULL 12 voidAdd(netAddressBits address1, netAddressBits address2, 13 Port port, voidvalue); 14 //Returns the old value if different, otherwise 0 15 16 //从哈希表中移除key对应的条目，对应条目存在返回true 17 Boolean Remove(netAddressBits address1, netAddressBits address2, 18 Port port); 19 //从哈希表中查找key对应的value，没找到返回NULL 20 voidLookup(netAddressBits address1, netAddressBits address2, 21 Port port); 22 //Returns 0 if not found 23 24 //Used to iterate through the entries in the table 25 //用于遍历在表中的条目 26 classIterator { 27 public: 28 Iterator(AddressPortLookupTable&amp;amp;table); 29 virtual ~Iterator(); 30 31 void next(); //NULL iff none 32 33 private: 34 HashTable::Iterator* fIter; //哈希表迭代器 35 }; 36 37 private: 38 friend classIterator; 39 HashTable* fTable; //哈希表 40 };  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>INI文件的读取(C语言:GetPrivateProfileString/GetPrivateProfileInt)</title>
      <link>http://sotex.github.io/post/2015-07-08-ini%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96c%E8%AF%AD%E8%A8%80-getprivateprofilestring.getprivateprofileint/</link>
      <pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-08-ini%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96c%E8%AF%AD%E8%A8%80-getprivateprofilestring.getprivateprofileint/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/08/4630120.html INI文件格式说明 /********************************************* ini文件说明 ini文件是文本文件，由节点(Section)和键值对(key=value)组成 以&amp;rsquo;;&amp;lsquo;开头的行为注释 一般形式如下所示: +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; test.ini &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | [Section1] | | key1=value1 | | key2=value2 | | ;这是注释 | | [Section2] | | key3=value3 | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+ *******************************************/  更详细的介绍可见http://blog.chinaunix.net/uid-25885064-id-3327199.html
&amp;nbsp;
GetPrivateProfileString 从INI文件中读取String值 辅助函数&amp;nbsp;dupFile&amp;nbsp;
1 //读取文件内容，保存到在heap区上申请的内存中 2 //成功返回内存地址，失败返回NULL 3 //参数fsize用于传出文件的内存区域的大小 4 char* dupFile(const char* FileName,longfsize) 5 { 6 char buf =NULL; 7 long size = 0; 8 //读取文件，因为ini文件通常都很小，所以一次全部读取了 9 FILE* fp = fopen(FileName,&amp;ldquo;r&amp;ldquo;); 10 do{ 11 if(fp == NULL){ //打开文件失败 12 //puts(&amp;ldquo;打开文件失败&amp;rdquo;); 13 break; 14 } 15 //获取文件大小 16 if(fseek(fp,0,SEEK_END)){ 17 break; //fseek失败 18 } 19 size = ftell(fp); //获取当前偏移(文件长度) 20 if(size&amp;lt;0){break;} 21 22 //读取文件 23 fseek(fp,0,SEEK_SET); 24 buf = (char*)malloc(size+1); 25 if(buf == NULL){break;} 26 if(size == fread(buf,1,size,fp)){ //fread是阻塞模式，= 27 buf[size] = &amp;lsquo;\0&amp;lsquo;; 28 //文件已经读取完成了 29 }else{ //万一失败了呢？ 30 free(buf); 31 buf =NULL; 32 size = 0; 33 } 34 }while(0); 35 fclose(fp); //关闭文件 36 if(fsize !</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;相对论——C&#43;&#43;中为什么要使用异常?</title>
      <link>http://sotex.github.io/post/2015-07-02-c.c&#43;&#43;%E7%9B%B8%E5%AF%B9%E8%AE%BAc&#43;&#43;%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 02 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-02-c.c&#43;&#43;%E7%9B%B8%E5%AF%B9%E8%AE%BAc&#43;&#43;%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/02/4616502.html C++中为什么要使用异常? 很多人也许知道C++中的异常机制，很多人也许不知道。很多人知道C中常用的assert，也知道在编译时候指定NODEBUG来忽略它。
对于C语言，使用正常的if-else即是很好的选择，而在C++中，如果使用了面向对象的编程，最好还是使用Exception机制。这主要设计对象能否正确的析构的问题。
C中的出错跳转setjmp和longjmp C语言中常用的用于处理异常的方法。它不像abort或者assert或者exit那样直接退出，也不像goto语句仅仅局限在函数内部。
它是用于一种长跳转的方式。可以从一个函数跳到这个函数上层的调用函数中。
举个例子
 函数 A 中调用了setjmp设置了一个跳转位，然后函数A调用了函数B。 函数 B 中调用了longjmp，那么会使得程序条到 函数 A中调用setjmp的位置继续执行。
 这不是本文的重点。
使用setjmp和longjmp最大的缺点是可能会跳过某些对象的构造或者析构。
还有，在C中使用goto可以跳过某些变量的定义，但是这不会出什么问题。可以试试下面的代码。注意，是C语言，你要是用C++的编译器来编译，应该是会报错的。
1 #include &amp;lt;stdio.h&amp;gt; 2 3 int main(int argc,char*argv) 4 { 5 if(argc &amp;gt; 1){ 6 gotonodef; 7 } 8 int a = 102; 9 nodef: 10 printf(&amp;ldquo;a = %d\n&amp;ldquo;,a); 11 return 0; 12 }  &amp;nbsp;
C++中使用setjmp和longjmp造成的不良后果 我们先看代码
无法正常析构对象的代码 1 #include &amp;lt;iostream&amp;gt; 2 #include &amp;lt;csetjmp&amp;gt; 3 4 usingstd::cout; 5 usingstd::endl; 6 7 classTest{ 8 public: 9 Test(){ cout&amp;lt;&amp;lt;&amp;ldquo;Test 构造&amp;ldquo;&amp;lt;&amp;lt;endl;} 10 ~Test(){cout&amp;lt;&amp;lt;&amp;ldquo;Test 析构&amp;ldquo;&amp;lt;&amp;lt;endl;} 11 }; 12 13 jmp_buf jbuf; //用于setjmp保存当前相关信息 14 15 voidcalljmp() 16 { 17 Test t; //测试能够正确调用析构 18 cout&amp;lt;&amp;lt;&amp;ldquo;call longjmp(jbuf,3721)&amp;ldquo;&amp;lt;&amp;lt;endl; 19 longjmp(jbuf,3721); 20 } 21 22 intmain() 23 { 24 int ret=0; 25 if( 0 == (ret=setjmp(jbuf))){ 26 cout&amp;lt;&amp;lt;&amp;ldquo;call setjmp(jbuf) resuces&amp;ldquo;&amp;lt;&amp;lt;endl; 27 calljmp(); 28 } 29 else{ 30 cout&amp;lt;&amp;lt;&amp;ldquo;call setjmp(jbuf) failed ret = &amp;ldquo;&amp;lt;&amp;lt; ret &amp;lt;&amp;lt;endl; 31 } 32 }  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>getopt函数的使用——分析命令行参数</title>
      <link>http://sotex.github.io/post/2015-07-02-getopt%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 02 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-02-getopt%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/02/4616282.html getopt（分析命令行参数）  getopt（分析命令行参数）  短参数的定义 返回值 范例 getopt_long      相关函数表头文件
#include&amp;lt;unistd.h&amp;gt; 函数声明
int getopt(int argc,char * const argv[ ],const char * optstring); 全局变量
 extern char *optarg;
extern int optind, opterr, optopt;&amp;nbsp; //索引/错误输出标志/最后一个未知选项
 函数说明
getopt()用来分析命令行参数。参数argc和argv是由main()传递的参数个数和内容。参数optstring 则代表欲处理的选项字符串。此函数会返回在argv中下一个的选项字母，此字母会对应参数optstring 中的字母。如果选项字符串里的字母后接着冒号&amp;ldquo;:&amp;rdquo;，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果getopt()找不到符合的参数，则会打印出错信息，并将全域变量optarg设为&amp;ldquo;?&amp;rdquo;字符，如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。
 getopt() 所设置的全局变量包括：
char *optarg&amp;mdash;&amp;mdash;当前选项参数字串（如果有）。 
int optind&amp;mdash;&amp;mdash;argv的当前索引值。当getopt()在while循环中使用时，循环结束后，剩下的字串视为操作数，在argv[optind]至argv[argc-1]中可以找到。 
int opterr&amp;mdash;&amp;mdash;这个变量非零时，getopt()函数为&amp;ldquo;无效选项&amp;rdquo;和&amp;ldquo;缺少参数选项，并输出其错误信息。

int optopt&amp;mdash;&amp;mdash;当发现无效选项字符之时，getopt()函数或返回&amp;rsquo;?&amp;lsquo;字符，或返回&amp;rsquo;:&amp;lsquo;字符，并且optopt包含了所发现的无效选项字符。
短参数的定义 getopt()使用optstring所指的字串作为短参数列表，象&amp;ldquo;1ac:d::&amp;rdquo;就是一个短参数列表。短参数的定义是一个-后面跟一个字母或数字，象-a,-b就是一个短参数。每个数字或字母定义一个参数。 其中短参数在getopt定义里分为三种：
1、不带值的参数，它的定义即是参数本身。
2、必须带值的参数，它的定义是在参数本身后面再加一个冒号。
3、可选值的参数，它的定义是在参数本身后面加两个冒号 。
&amp;nbsp;
在这里拿上面的&amp;ldquo;1ac:d::&amp;rdquo;作为样例进行说明，其中的1,a就是不带值的参数，c是必须带值的参数，d是可选值的参数。
在实际调用中，-1 -a -c cvalue -d, -1 -a -c cvalue -ddvalue,-1a -ddvalue -c cvalue都是合法的。这里需要注意三点：</description>
    </item>
    
    <item>
      <title>linux/windows下启用和停止VMware后台服务的脚本</title>
      <link>http://sotex.github.io/post/2015-07-02-linux.windows%E4%B8%8B%E5%90%AF%E7%94%A8%E5%92%8C%E5%81%9C%E6%AD%A2vmware%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Thu, 02 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-02-linux.windows%E4%B8%8B%E5%90%AF%E7%94%A8%E5%92%8C%E5%81%9C%E6%AD%A2vmware%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%84%9A%E6%9C%AC/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/02/4615798.html linux/windows下启用和停止VMware后台服务的脚本  linux/windows下启用和停止VMware后台服务的脚本  linux平台 windows平台     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
linux平台 将以下代码保存为脚本。（适用于debian系）
1 #! /bin/bash 2 #停止vmware 3 sudoservice vmware stop 4 #停止vmware-USBArbitrator 5 sudo service vmware-USBArbitrator stop 6 #停止vmware-workstation-server 7 sudo service vmware-workstation-server stop 8 #关闭相关进程 9 sudo killall vmware*  &amp;nbsp;
windows平台 将下面的代码保存为xxx.bat。注意使用的时候要使用管理员权限运行。
1 @echo off 2 for /f &amp;ldquo;skip=3 tokens=4&amp;rdquo; %%i in (&amp;lsquo;sc query &amp;ldquo;VMAuthdService&amp;rdquo;&amp;rsquo;) do set &amp;ldquo;zt=%%i&amp;rdquo; &amp;amp;goto :next 3 :next 4 if /i &amp;ldquo;%zt%&amp;rdquo;==&amp;ldquo;RUNNING&amp;rdquo; ( 5 echo服务VMware Authorization Service正在运行 6 ) else ( 7 echo服务VMware Authorization Service已停止 8 ) 9 for /f &amp;ldquo;skip=3 tokens=4&amp;rdquo; %%i in (&amp;lsquo;sc query &amp;ldquo;VMnetDHCP&amp;rdquo;&amp;rsquo;) do set &amp;ldquo;zt=%%i&amp;rdquo; &amp;amp;goto :next 10 :next 11 if /i &amp;ldquo;%zt%&amp;rdquo;==&amp;ldquo;RUNNING&amp;rdquo; ( 12 echo服务VMware DHCP Service正在运行 13 ) else ( 14 echo服务VMware DHCP Service已停止 15 ) 16 for /f &amp;ldquo;skip=3 tokens=4&amp;rdquo; %%i in (&amp;lsquo;sc query &amp;ldquo;VMware NAT Service&amp;rdquo;&amp;rsquo;) do set &amp;ldquo;zt=%%i&amp;rdquo; &amp;amp;goto :next 17 :next 18 if /i &amp;ldquo;%zt%&amp;rdquo;==&amp;ldquo;RUNNING&amp;rdquo; ( 19 echo服务VMware NAT Service正在运行 20 ) else ( 21 echo服务VMware NAT Service已停止 22 ) 23 for /f &amp;ldquo;skip=3 tokens=4&amp;rdquo; %%i in (&amp;lsquo;sc query &amp;ldquo;VMUSBArbService&amp;rdquo;&amp;rsquo;) do set &amp;ldquo;zt=%%i&amp;rdquo; &amp;amp;goto :next 24 :next 25 if /i &amp;ldquo;%zt%&amp;rdquo;==&amp;ldquo;RUNNING&amp;rdquo; ( 26 echo服务VMware USB Arbitration Service正在运行 27 ) else ( 28 echo服务VMware USB Arbitration Service已停止 29 ) 30 for /f &amp;ldquo;skip=3 tokens=4&amp;rdquo; %%i in (&amp;lsquo;sc query &amp;ldquo;VMwareHostd&amp;rdquo;&amp;rsquo;) do set &amp;ldquo;zt=%%i&amp;rdquo; &amp;amp;goto :next 31 :next 32 if /i &amp;ldquo;%zt%&amp;rdquo;==&amp;ldquo;RUNNING&amp;rdquo; ( 33 echo服务VVMware Workstation Server正在运行 34 ) else ( 35 echo服务VMware Workstation Server已停止 36 ) 37 pause 38 echo 1：启用VM虚拟机服务（VMware Authorization Service、VMware DHCP Service、VMware NAT Service、VMware USB Arbitration Service、VMware Workstation Server）及网络连接（VMware Network 39 Adapter VMnet1、VMware Network Adapter VMnet8） 40 echo 2：禁用VM虚拟机服务（VMware Authorization Service、VMware DHCP Service、VMware NAT Service、VMware USB Arbitration Service、VMware Workstation Server）及网络连接（VMware Network 41 Adapter VMnet1、VMware Network Adapter VMnet8） 42 choice /c:12 /m &amp;ldquo;根据选项请选择&amp;hellip;&amp;rdquo; 43 if errorlevel 2 gototwo 44 if errorlevel 1 gotoone 45 :one 46 echo 正在启用服务&amp;hellip; 47 net start &amp;ldquo;VMAuthdService&amp;rdquo; 48 net start &amp;ldquo;VMnetDHCP&amp;rdquo; 49 net start &amp;ldquo;VMware NAT Service&amp;rdquo; 50 net start &amp;ldquo;VMUSBArbService&amp;rdquo; 51 net start &amp;ldquo;VMwareHostd&amp;rdquo; 52 echo 正在启用网络连接&amp;hellip; 53 netsh interface set interface &amp;ldquo;VMware Network Adapter VMnet1&amp;rdquo;enable 54 netsh interface set interface &amp;ldquo;VMware Network Adapter VMnet8&amp;rdquo;enable 55 echo网络连接VMware Network Adapter VMnet1、VMware Network Adapter VMnet8启动成功 56 echo 按任意键退出&amp;hellip; 57 pause&amp;gt;nul 58 C:\&amp;ldquo;Program Files (x86)&amp;rdquo;\VMware\&amp;ldquo;VMware Workstation&amp;rdquo;\vmware.</description>
    </item>
    
    <item>
      <title>27 GroupSock概述(一)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-01-27-groupsock%E6%A6%82%E8%BF%B0%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-01-27-groupsock%E6%A6%82%E8%BF%B0%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/01/4613329.html 27 GroupSock概述(一)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  27 GroupSock概述(一)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 1.网络通用数据类型定义 2.Tunnel隧道封装     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 group是组/群的意思，socket是网络接口的代名词了。这个部分很庞大，主要是与网络相关的。而live555的网络模块很多都涉及到组播的概念。
作为一个跨平台的流媒体服务库，live555对网络的封装很全面，值得一看。
1.网络通用数据类型定义 因为live555跨平台的特点，需要定义一些在数据类型来适应各个平台环境。
这写代码在live555sourcecontrol\groupsock\include\NetCommon.h文件中
#if defined(WIN32) || defined(_WIN32) || defined(_WIN32_WCE) /* Windows */ #if defined(WINNT) || defined(_WINNT) || defined(BORLANDC) || defined(MINGW32) || defined(_WIN32_WCE) #define MSWSOCK #include &amp;lt;winsock2.h&amp;gt; #include &amp;lt;ws2tcpip.h&amp;gt; #endif #include &amp;lt;windows.h&amp;gt; #include &amp;lt;string.h&amp;gt;
#define closeSocket closesocket //关闭socket函数 #define EWOULDBLOCK WSAEWOULDBLOCK //10035L 可能会被阻塞 #define EINPROGRESS WSAEWOULDBLOCK //10035L 操作正在进行 #define EAGAIN WSAEWOULDBLOCK //10035L 再试一次 #define EINTR WSAEINTR //10004L 中断</description>
    </item>
    
    <item>
      <title>28 GroupSock(NetAddress)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-01-28-groupsocknetaddresslive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-01-28-groupsocknetaddresslive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/01/4613341.html 28 GroupSock(NetAddress)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  28 GroupSock(NetAddress)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 1) NetAddress网络地址类简述 下面是其定义 assign方法(分配空间) NetAddress的构造 clean方法(清理)与析构 operate= 重载赋值操作     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 使用Socket进行的网络连接，网络地址一般由地址(IP)和端口(port)组成。
live555中定义了一些数据类型，表明了目前所支持的网络地址类型。
1 //Definition of a type representing a low-level network address. 2 //At present, this is 32-bits, for IPv4. Later, generalize it, 3 //to allow for IPv6. 4 //一种代表底层网络地址定义。目前，默认它32位，IPv4。将来，可扩展支持IPv6。 5 typedef u_int32_t netAddressBits; 6 typedef u_int16_t portNumBits;  定义在文件live555sourcecontrol\groupsock\include\NetAddress.hh
1) NetAddress网络地址类简述 NetAddress是一个用于保存网络地址的类，它不是对struct sockaddr的封装。其内部定义了两个数据成员，分别是用于保存地址数据的u_int8_t* fData和用于指示地址长度的unsigned fLength。</description>
    </item>
    
    <item>
      <title>29 GroupSock(NetAddressList)——live555源码阅读(四)网络</title>
      <link>http://sotex.github.io/post/2015-07-01-29-groupsocknetaddresslistlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-01-29-groupsocknetaddresslistlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9B%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/01/4613361.html 29 GroupSock(NetAddressList)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  29 GroupSock(NetAddressList)&amp;mdash;&amp;mdash;live555源码阅读(四)网络  简介 NetAddressList的定义 assign方法 NetAddressList的构造 clean方法与析构 拷贝构造与赋值运算符重载 NetAddressList::Iterator迭代器     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 网络地址列表是用于保存一系列网络地址的类。它与NetAddress无直接联系。
NetAddressList类内部定义了一个二级指针NetAddress** fAddressArray，在使用的时候给它动态申请一个元素个数为unsigned fNumAddresses的指针(NetAddress)数组。指针数组的每一个元素又指向一个动态申请的NetAddress对象。
NetAddressList的定义 1 classNetAddressList { 2 public: 3 //构造函数hostname可以是一个点分十进制的IP地址，也可以是主机域名 4 NetAddressList(char consthostname); 5 NetAddressList(NetAddressList const&amp;amp;orig); 6 NetAddressList&amp;amp; operator=(NetAddressList const&amp;amp;rightSide); 7 virtual ~NetAddressList(); 8 //获取地址表中元素个数 9 unsigned numAddresses() const { returnfNumAddresses; } 10 //获取地址表第一个地址的内存地址 11 NetAddress const* firstAddress() const; 12 13 //Used to iterate through the addresses in a list: 14 //用于遍历列表中的地址： 15 classIterator { 16 public: 17 Iterator(NetAddressList const&amp;amp;addressList); 18 NetAddress const* nextAddress(); //NULL iff none没有跟多地址了 19 private: 20 NetAddressList const&amp;amp; fAddressList; //必须绑定一个地址表 21 unsigned fNextIndex; //下一个地址的索引 22 }; 23 24 private: 25 //为地址表申请内存空间，并将表addressArray中的内容拷贝进去 26 void assign(netAddressBits numAddresses, NetAddressaddressArray); 27 //删除地址表和地址表中所有地址 28 voidclean(); 29 30 friend classIterator; 31 unsigned fNumAddresses; //地址个数 32 NetAddress fAddressArray; //地址表 33 };  NetAddressList 定义 assign方法 assign方法为地址表动态申请内存来保存地址元素。</description>
    </item>
    
    <item>
      <title>linux下VMware安装出现的问题解决</title>
      <link>http://sotex.github.io/post/2015-07-01-linux%E4%B8%8Bvmware%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-01-linux%E4%B8%8Bvmware%E5%AE%89%E8%A3%85%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/01/4612935.html linux下VMware安装出现的问题解决  linux下VMware安装出现的问题解决  报错信息 问题1liboverlay-scrollbar.so和libunity-gtk-module.so加载失败的问题。 问题2 Gtk-WARNING **: 无法在模块路径中找到主题引擎：&amp;ldquo;murrine&amp;rdquo; 问题3 无法加载libcanberra-gtk-module.so的问题     本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
系统环境 ubuntu-kylin 15.04
o@o-pc:~/software$ uname -a Linux o-pc 3.19.0-22-generic #22-Ubuntu SMP Tue Jun 16 17:15:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux  报错信息 Gtk-Message: Failed to load module &amp;ldquo;overlay-scrollbar&amp;rdquo;: liboverlay-scrollbar.so: 无法打开共享对象文件: 没有那个文件或目录 Gtk-Message: Failed to load module &amp;ldquo;unity-gtk-module&amp;rdquo;: libunity-gtk-module.so: 无法打开共享对象文件: 没有那个文件或目录
(vmware-installer.py:1593): Gtk-WARNING **: 无法在模块路径中找到主题引擎：&amp;ldquo;murrine&amp;rdquo;，</description>
    </item>
    
    <item>
      <title>windows下的socket网络编程</title>
      <link>http://sotex.github.io/post/2015-07-01-windows%E4%B8%8B%E7%9A%84socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-07-01-windows%E4%B8%8B%E7%9A%84socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/07/01/4613296.html windows下的socket网络编程  windows下的socket网络编程 clinet.c 客户端 server.c 服务器端 UDP通信的实现 代码如下   已经很久没有在windows下编程了，这次因为需要做一个跨平台的网络程序，就先写了个简单的winSocket网路通信的例子，以便以后用到的时候有个参考。
windows下使用winsock编程与linux/unix的区别在于windows下需要先有一个初始化的操作，结束的时候需要一个清理的操作。还有windows下编译的时候需要连接ws32_lib库。
大致过程如下
  1、初始化
/加载Winsock DLL/
WSADATA wsd;
if (WSAStartup(MAKEWORD(2 , 2) , &amp;amp;wsd) != 0) {
printf(&amp;ldquo;Winsock 初始化失败!\n&amp;rdquo;);
return 1;
}
  2、socket相关函数调用
socket(&amp;hellip;)
bind(&amp;hellip;)
listen(&amp;hellip;)
connect(&amp;hellip;)
accept(&amp;hellip;)
send/sendto
recv/recvfrom
  3、清理
WSACleanup();

 clinet.c 客户端 客户端的流程很简单。
 1、先是使用socket函数产生一个打开的socket文件描述符。 2、使用connect函数去连接服务端 3、使用read/recv等读文件函数从服务端接收数据，使用write/send等写文件的函数向服务端发送数据
 上面是典型的TCP编程流程，如果是UDP的话不需要connect去连接服务端直接使用sendto函数来发送数据，使用recvfrom接收来自服务器的数据
server.c 服务器端 服务器端的流程比客户端稍微复杂一点
 1、调用socket打开一个socket句柄 2、调用bind来绑定socket句柄到一个网口的某个端口 3、调用listen来设置(启用)监听 4、调用accept来等待客户端的连接</description>
    </item>
    
    <item>
      <title>23 使用环境 UsageEnvironment——Live555源码阅读</title>
      <link>http://sotex.github.io/post/2015-06-30-23-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83-usageenvironmentlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-23-%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83-usageenvironmentlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4609387.html 23 使用环境 UsageEnvironment&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment  23 使用环境 UsageEnvironment&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment   这是Live555源码阅读的第三部分，包括了UsageEnvironment相关的三个类。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
使用环境相关的类和任务调度的很类似，在UsageEnvironment类中有一个数据成员fScheduler，其是一个TaskScheduler的引用。
使用环境相关类也是由三个类组成，其关系如下
UsageEnvrionment &amp;rarr; 派生出 &amp;rarr;BasicUasgeEnvironment0 &amp;rarr; 派生出 &amp;rarr; BasicUasgeEnvironment
使用环境相关类的作用主要有三个方面，首先UsageEnvrionment包含了任务调度器，可以做任务调度相关操作；其次BasicUasgeEnvironment0 定义了一个buffer(fResultMsgBuffer)，与处理消息的结果相关；最后BasicUasgeEnvironment继承了前两者的功能并添加了向标准错误流输出数据的功能。</description>
    </item>
    
    <item>
      <title>24 UsageEnvironment使用环境抽象基类——Live555源码阅读(三)UsageEnvironment</title>
      <link>http://sotex.github.io/post/2015-06-30-24-usageenvironment%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-24-usageenvironment%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4609389.html 24 UsageEnvironment使用环境抽象基类&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment  24 UsageEnvironment使用环境抽象基类&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment  简介 下面是其定义 UsageEnvironment的构造与析构 reclaim方法(自我回收) internalError方法(内部错误)     这是Live555源码阅读的第三部分，包括了UsageEnvironment相关的三个类。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 UsageEnvironment是一个抽象基类，其定义在live555sourcecontrol\UsageEnvironment\include\UsageEnvironment.hh文件中。
UsageEnvironment定义了三个数据成员， void*类型的指针liveMediaPriv和groupsockPriv(要注意这两者是public权限的，在使用环境相关类中都没有对它们进行初始化以外的操作)，这两个在后面说Groupsock和LiveMedia模块的时候就比较清楚了。还有一个很重要的是一个引用fScheduler，它告诉了我们，每一个使用环境必须绑定一个任务调度器。
下面是其定义 // An abstract base class, subclassed for each use of the library // 一个抽象类，子类为每个使用库 class UsageEnvironment { public:
//reclaim vt.开拓，开垦; 感化; 取回; 沙化; n.改造，感化; 教化; 回收再利用; 收回，取回; //自我回收，如果liveMediaPriv或groupsockPriv这两个成员变量有一个为NULL，就delete this; void reclaim(); // task scheduler:任务调度 //直接返回对象内部的fScheduler成员 TaskScheduler&amp;amp;amp; taskScheduler() const { return fScheduler; } // result message handling: //消息处理结果，注意这里是一个类型定义 typedef char const* MsgString; //纯虚接口，看意思应该是获取消息处理结果 virtual MsgString getResultMsg() const = 0; virtual void setResultMsg(MsgString msg) = 0; virtual void setResultMsg(MsgString msg1, MsgString msg2) = 0; virtual void setResultMsg(MsgString msg1, MsgString msg2, MsgString msg3) = 0; virtual void setResultErrMsg(MsgString msg, int err = 0) = 0; // like setResultMsg(), except that an &#39;errno&#39; message is appended.</description>
    </item>
    
    <item>
      <title>25 BasicUsageEnvironment0基本使用环境基类——Live555源码阅读(三)UsageEnvironment</title>
      <link>http://sotex.github.io/post/2015-06-30-25-basicusageenvironment0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-25-basicusageenvironment0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4609400.html 25 BasicUsageEnvironment0基本使用环境基类&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment  25 BasicUsageEnvironment0基本使用环境基类&amp;mdash;&amp;mdash;Live555源码阅读(三)UsageEnvironment  简介 代码定义如下 BasicUsageEnvironment0构造析构与重置 ResultMsg系列方法 getResultMsg() const方法(获取buffer) appendToResultMsg方法(添加msg到buffer) setResultMsg方法(重置buffer内容为msg) setResultErrMsg方法(重置buffer内容为msg/err) reportBackgroundError方法(报告错误消息)     这是Live555源码阅读的第三部分，包括了UsageEnvironment相关的三个类。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
简介 BasicUsageEnvironment0实现了其基类UsageEnvironment的部分纯虚接口(只有部分，其还是一个抽象类)，并添加了三个数据成员。其定义在live555sourcecontrol\BasicUsageEnvironment\include\BasicUsageEnvironment0.hh文件中。
代码定义如下 // An abstract base class, useful for subclassing // (e.g., to redefine the implementation of &amp;ldquo;operator&amp;lt;&amp;lt;&amp;rdquo;) class BasicUsageEnvironment0 : public UsageEnvironment { public: // redefined virtual functions:重定义虚函数
//返回fResultMsgBuffer virtual MsgString getResultMsg() const; // 调用reset将消息结果buffer截空，再将msg(msg1-3)拷贝到buffer virtual void setResultMsg(MsgString msg); virtual void setResultMsg(MsgString msg1, MsgString msg2); virtual void setResultMsg(MsgString msg1, MsgString msg2, MsgString msg3); //将msg设置到fResultMsgBuffer，支持_WIN32_WCE的平台会将err代表的错误消息也加入 virtual void setResultErrMsg(MsgString msg, int err = 0); //将msg拷贝到fResultMsgBuffer可用部分，剩余空间不够时，只拷贝部分 virtual void appendToResultMsg(MsgString msg); ////将fResultMsgBuffer中的内容写入到标准错误 virtual void reportBackgroundError();  protected: BasicUsageEnvironment0(TaskScheduler&amp;amp; taskScheduler); virtual ~BasicUsageEnvironment0();</description>
    </item>
    
    <item>
      <title>26 BasicUsageEnvironment基本使用环境——Live555源码阅读(三)UsageEnvironment</title>
      <link>http://sotex.github.io/post/2015-06-30-26-basicusageenvironment%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-26-basicusageenvironment%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%89usageenvironment/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4609394.html 26 BasicUsageEnvironment基本使用环境——Live555源码阅读(三)UsageEnvironment26 BasicUsageEnvironment基本使用环境——Live555源码阅读(三)UsageEnvironment简介以下是其定义BasicUsageEnvironment的构造与析构createNew方法(创建对象)getErrno方法operator&amp;lt;&amp;lt;方法(输出到strerr)这是Live555源码阅读的第三部分，包括了UsageEnvironment相关的三个类。
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso简介这个类很简单，它不想basicTaskScheduler那么复杂。没有增加任何成员，仅是实现了基类的几个纯虚方法。
以下是其定义class BasicUsageEnvironment : public BasicUsageEnvironment0 { public: static BasicUsageEnvironment* createNew(TaskScheduler&amp;amp; taskScheduler);
// redefined virtual functions: virtual int getErrno() const; // 向 stderr 输出内容。stderr是不带缓冲的 virtual UsageEnvironment&amp;amp;amp; operator&amp;amp;lt;&amp;amp;lt;(char const* str); virtual UsageEnvironment&amp;amp;amp; operator&amp;amp;lt;&amp;amp;lt;(int i); virtual UsageEnvironment&amp;amp;amp; operator&amp;amp;lt;&amp;amp;lt;(unsigned u); virtual UsageEnvironment&amp;amp;amp; operator&amp;amp;lt;&amp;amp;lt;(double d); virtual UsageEnvironment&amp;amp;amp; operator&amp;amp;lt;&amp;amp;lt;(void* p);  protected: // 避免直接构造对象，只能通过createNew来创建 BasicUsageEnvironment(TaskScheduler&amp;amp; taskScheduler); // called only by &amp;ldquo;createNew()&amp;rdquo; (or subclass constructors) virtual ~BasicUsageEnvironment(); }; BasicUsageEnvironment的构造与析构注意构造和析构是protected权限的。在创建对象的时候只能使用createNew方法。</description>
    </item>
    
    <item>
      <title>nc 局域网聊天&#43;文件传输(netcat)</title>
      <link>http://sotex.github.io/post/2015-06-30-nc-%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9&#43;%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93netcat/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-nc-%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9&#43;%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93netcat/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4610563.html nc 局域网聊天+文件传输 nc的全程是netcat，这个工具非常好用。
有时候我们需要在局域网内传送一些文本消息或者文件的时候，通常的做法是安装一些局域网通讯软件，然后来做。其实不必要这样，使用nc这个小工具就很好了。
nc的一些参数 具体的参数，可以通过nc -help来获取。（注意此处只有一个-）
下面表格中的内容是用google翻译后修改来的，不是很好看，请原谅。
最常用的几个参数就是-l,-u,-p这几个参数。
  参数说明 
   -4 使用IPv4
  -6 使用IPv6
  -b 允许广播
  -C 发送CRLF作为行结束
  -D 启用套接字调试选项
  -d 从标准输入分离
  -h 查看帮助信息
  -I length TCP接收缓冲区长度
  -i secs 发送间隔/端口扫描的延时
  -j 使用巨型帧
  -k 保持套接字打开多个连接
  -l 监听模式,绑定端口,等待连接
  -n 禁止名称/端口的解析</description>
    </item>
    
    <item>
      <title>一个按比特位拷贝数据的函数copybits</title>
      <link>http://sotex.github.io/post/2015-06-30-%E4%B8%80%E4%B8%AA%E6%8C%89%E6%AF%94%E7%89%B9%E4%BD%8D%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%BD%E6%95%B0copybits/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-%E4%B8%80%E4%B8%AA%E6%8C%89%E6%AF%94%E7%89%B9%E4%BD%8D%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%BD%E6%95%B0copybits/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4610120.html 一个按比特位拷贝数据的函数 没有进行特别的优化。其实还可以在拷贝源开始位置和目标开始位置是2的整数倍位置的时候进行优化。
说明 这个函数用于从src数组首地址跳过sbb个字节，又跳过ssb个比特位，拷贝nbits个比特位的数据到dest数组首地址跳过dbb个字节，又跳过dsb个比特位位置。
代码如下 1 include &amp;lt;stdio.h&amp;gt; 2 #include &amp;lt;stdlib.h&amp;gt; 3 #include &amp;lt;string.h&amp;gt; 4 #include &amp;lt;assert.h&amp;gt; 5 6 //二进制打印输出 7 void Bp(unsigned charn)
8 {
9 inti; 10 for (i=7;i&amp;gt;=0;i&amp;ndash;)
11 {
12 printf(&amp;ldquo;%u&amp;ldquo;,(n&amp;gt;&amp;gt;i)&amp;amp;1);
13 } 14 } 15 16 //按比特位拷贝 17 //从src数组首地址跳过sbb个字节，又跳过ssb个比特位，拷贝nbits个比特位的数据到 18 //dest数组首地址跳过dbb个字节，又跳过dsb个比特位位置 19 int copybits(const unsigned char* src,int sbb/source begin byte/,int ssb/source skip bit/, 20 unsigned char* dest,int dbb/dest begin byte/,int dsb/dest skip bit/,intnbits) 21 { 22 //assert(src &amp;amp;&amp;amp; dest &amp;amp;&amp;amp; sbb&amp;gt;=0 &amp;amp;&amp;amp; ssb&amp;gt;=0 &amp;amp;&amp;amp; dbb&amp;gt;=0 &amp;amp;&amp;amp; dsb&amp;gt;=0 &amp;amp;&amp;amp; nbits&amp;gt;=0); 23 if(src ==NULL || dest == NULL)return -1; 24 if(sbb &amp;lt; 0 || ssb &amp;lt; 0 || dbb &amp;lt; 0 || dsb &amp;lt;0)return -2; 25 if(nbits==0)return 0; 26 27 if(ssb ==dsb){ 28 //边界对其情况 29 //1拷贝对齐部分 30 int copybyte=(nbits -(8-ssb))/8; 31 memmove(dest+dbb+1,src+sbb+1,copybyte); 32 //2拷贝前端不完整字节 33 if(ssb !</description>
    </item>
    
    <item>
      <title>简单的哈希表实现 C语言</title>
      <link>http://sotex.github.io/post/2015-06-30-%E7%AE%80%E5%8D%95%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0-c%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-30-%E7%AE%80%E5%8D%95%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0-c%E8%AF%AD%E8%A8%80/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/30/4610109.html 简单的哈希表实现  简单的哈希表实现  原理 哈希表和节点数据结构的定义 初始化和释放哈希表 哈希散列算法 辅助函数strDup 哈希表的插入和修改 哈希表中查找 哈希表元素的移除 哈希表打印 测试一下     这是一个简单的哈希表的实现，用c语言做的。
原理 先说一下原理。
先是有一个bucket数组，也就是所谓的桶。
哈希表的特点就是数据与其在表中的位置存在相关性，也就是有关系的，通过数据应该可以计算出其位置。
这个哈希表是用于存储一些键值对(key &amp;ndash; value)关系的数据，其key也就是其在表中的索引，value是附带的数据。
通过散列算法，将字符串的key映射到某个桶中，这个算法是确定的，也就是说一个key必然对应一个bucket。
然后是碰撞问题，也就是说多个key对应一个索引值。举个例子：有三个key:key1,key3,key5通过散列算法keyToIndex得到的索引值都为2，也就是这三个key产生了碰撞，对于碰撞的处理，采取的是用链表连接起来，而没有进行再散列。
&amp;nbsp;这是包含的头文件
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt;
#define BUCKETCOUNT 16   &amp;nbsp;
哈希表和节点数据结构的定义 1 structhashEntry 2 { 3 const charkey; 4 charvalue; 5 struct hashEntrynext; 6 }; 7 8 typedef structhashEntry entry; 9 10 structhashTable 11 { 12 entry bucket[BUCKETCOUNT]; //先默认定义16个桶 13 }; 14 15 typedef struct hashTable table;  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>关于linux中文乱码的问题。</title>
      <link>http://sotex.github.io/post/2015-06-26-%E5%85%B3%E4%BA%8Elinux%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-26-%E5%85%B3%E4%BA%8Elinux%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/26/4602697.html 公司让人在一台装有ubuntu14.04的机器上安装net-snmp，可是这台机器的设置很让人不喜。没关系，一个个解决它。
 不能连接外网，得弄一个代理。
这个好说，在可以上外网的本机上安装squid工具来做代理即可。 locale看看，这个设置得改啊。
 fx@fx:~$ locale LANG=zh_CN.UTF-8 LANGUAGE=zh_CN:zh LC_CTYPE=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_NUMERIC=zh_CN LC_TIME=zh_CN LC_COLLATE=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_MONETARY=zh_CN LC_MESSAGES=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_PAPER=zh_CN LC_NAME=zh_CN LC_ADDRESS=zh_CN LC_TELEPHONE=zh_CN LC_MEASUREMENT=zh_CN LC_IDENTIFICATION=zh_CN LC_ALL=   没有安装中文语言包，先安装一个。  sudo apt-get install language-pack-zh-hans-base language-pack-zh-hans   再改改环境变量。通常我都是改.bashrc而不是改/etc/profile  fx@fx:~$ date 2014�� 08�� 22�� ������ 07:08:51 CST fx@fx:~$ cat &amp;gt;&amp;gt;.bashrc
LANG=zh_CN.UTF-8 LANGUAGE=zh_CN:en_US:en LC_CTYPE=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_NUMERIC=zh_CN.UTF-8 LC_TIME=zh_CN.UTF-8 LC_COLLATE=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_MONETARY=zh_CN.UTF-8 LC_MESSAGES=&amp;ldquo;zh_CN.UTF-8&amp;rdquo; LC_PAPER=zh_CN.UTF-8 LC_NAME=zh_CN.UTF-8 LC_ADDRESS=zh_CN.UTF-8 LC_TELEPHONE=zh_CN.UTF-8 LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=zh_CN.UTF-8
fx@fx:~$ source .bashrc fx@fx:~$ date 2014年 08月 22日 星期五 07:09:51 CST</description>
    </item>
    
    <item>
      <title>关于ubuntukylin安装后界面中英文混杂的问题</title>
      <link>http://sotex.github.io/post/2015-06-26-%E5%85%B3%E4%BA%8Eubuntukylin%E5%AE%89%E8%A3%85%E5%90%8E%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E6%9D%82%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-26-%E5%85%B3%E4%BA%8Eubuntukylin%E5%AE%89%E8%A3%85%E5%90%8E%E7%95%8C%E9%9D%A2%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E6%9D%82%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/26/4602642.html 起因 一直使用的是ubuntu原版的系统，ubuntukylin出来后也没用使用过。一次去其论坛逛了一圈之后决定使用一下。 安装后的截面和ubuntu原版的差不多，还是挺漂亮的。 但是有一个问题是，安装之后系统很多位置还是英文的。
解决 起初以为是中文包不全的问题，于是更新了一下，结果没有用。 后来自习观察了一下，发现其他的都是中文界面，唯有系统设置等一些位置是英文的。想了想，如果是gnome桌面环境的话，应该安装gnome的中文语言包就是了。但是这个是unity桌面环境啊。再仔细观察一下，发现确实是gnome相关的软件是英文的，那么应该是缺少了gnome的中文语言包，于是安装了。
&amp;nbsp;
 o@o-pc:~$ sudo apt-get install language-pack-gnome-zh-hans language-pack-gnome-zh-hans-base  &amp;nbsp;
安装完成后，重启gnome-session就可以了。
 o@o-pc:~$ sudo killall gnome-session   &amp;nbsp;</description>
    </item>
    
    <item>
      <title>网络数据包发送工具PacketSender中文源码</title>
      <link>http://sotex.github.io/post/2015-06-26-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%B7%A5%E5%85%B7packetsender%E4%B8%AD%E6%96%87%E6%BA%90%E7%A0%81/</link>
      <pubDate>Fri, 26 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-26-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%B7%A5%E5%85%B7packetsender%E4%B8%AD%E6%96%87%E6%BA%90%E7%A0%81/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/26/4602018.html 在网上发现了一个好用的工具PacketSender，数据包发送器。对于写网络程序来说，有很大的便利性。虽然在linux下，netcat工具也很好用，但是这个也不错。
原本是英文的，给翻译了一下。这是基于QT开发的。有一些翻译不对的地方，还请指正。
&amp;nbsp;本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
下面是翻译后的源码包，下载地址
实际上是一个bzip包，因为博客园不支持bz2文件后缀。
http://files.cnblogs.com/files/oloroso/packetSender.tar.gz&amp;nbsp;
&amp;nbsp;
使用netcat监听9000端口测试一下。
&amp;nbsp;
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>12 哈希表相关类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-25-12-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-12-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599519.html #12 哈希表相关类——Live555源码阅读(一)基本组件类
这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
 本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso  哈希表相关类综述 哈希表相关类一个有两个，HashTable和BasicHashTable。HashTable是BasicHashTable的派生类。其定义在\live555sourcecontrol\UsageEnvironment\include\HashTable.hh和BasicHashTable.hh文件中。
HashTable是一个抽象类，其没有定义数据成员，仅仅作为`接口类存在。
###其结构关系如图 </description>
    </item>
    
    <item>
      <title>13 HashTable抽象哈希表类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-25-13-hashtable%E6%8A%BD%E8%B1%A1%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-13-hashtable%E6%8A%BD%E8%B1%A1%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599526.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
HashTable抽象哈希表类 HashTable类内部嵌套定义了一个迭代器类Iterator，这个迭代器类用于循环访问表的成员。这也是一个抽象类，但是其有一个静态的方法static Iterator* create(HashTable&amp;amp; hashTable);这个方法用于创建一个BasicHashTable::Iterator对象，并返回其地址。
###HashTable的定义
class HashTable { public: virtual ~HashTable(); // The following must be implemented by a particular // implementation (subclass): static HashTable* create(int keyType); virtual void* Add(char const* key, void* value) = 0; // Returns the old value if different, otherwise 0 virtual Boolean Remove(char const* key) = 0; virtual void* Lookup(char const* key) const = 0; // Returns 0 if not found virtual unsigned numEntries() const = 0; Boolean IsEmpty() const { return numEntries() == 0; } // Used to iterate through the members of the table: class Iterator { public: // The following must be implemented by a particular // implementation (subclass): static Iterator* create(HashTable&amp;amp; hashTable); virtual ~Iterator(); virtual void* next(char const*&amp;amp; key) = 0; // returns 0 if none protected: Iterator(); // abstract base class }; // A shortcut that can be used to successively remove each of // the entries in the table (e.</description>
    </item>
    
    <item>
      <title>14 BasicHashTable基本哈希表类(一)——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-25-14-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-14-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599536.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##BasicHashTable基本哈希表类
这个类搞的很复杂，实质上没什么东西，就是很难看。
###先画一个简图
###先说说这个BasicHashTable的设计吧。
这个表的内部嵌套定义了一个TableEntry(表条目)的类，这个类有一个键key，一个值value，以及指向同一个索引下一个条目的指针(此处很有用，为什么要这么设置，后面会说到的)。这里的key是char const*类型，但其并不一定是如此，可以是unsigned类型等，这里只是一个代表。
  BasicHashTable的内部定义了一个TableEntry*类型的数组fStaticBuckets，是用来保存表条目的，默认是4个元素。还有一个指向这个数组的指针fBuckets，为什么还要这个数组呢？因为可能哈希表要扩展，4个元素不够用。所以又定义了一个成员fNumBuckets来标识桶(Buckets)的数量，一个桶就是一个数组元素空间。除此之外还需要知道以及保存了多少个条目，于是又有了成员fNumEntries。还有一个就是条目的键的类型，这个在创建哈希表的时候就要确定，所以又增加了成员fKeyType。
  还有一个成员fRebuildSize，这个成员是用来确定什么时候该重建的。每次在Add方法调用的时候就会判断当前已有条目数是否达到了fRebuildSize，如果达到了就该重建了。它的值是现有桶数的3倍。前面说了，一个桶可以保存一个TableEntry*类型的变量，也就是一个条目的地址，而每一个TableEntry对象中，又含有一个fNext变量，指向下一个条目。因为hash是散列算法，那么不同的key可能会散列到同一个index，如何解决这种碰撞问题呢？很好办，用链表。即把同一个散列到index的条目，用链表串联起来。
另外两个成员fDownShift, fMask是用于产生索引index用的。
##下面是类BasicHashTable的定义
#define SMALL_HASH_TABLE_SIZE 4 class BasicHashTable : public HashTable { private: class TableEntry; // forward public: /** *	1、将fBuckets指向fStaticBuckets,初始化其他几个数据成员 *	2、将FStaticBuckets数值清零(全置为NULL) */ BasicHashTable(int keyType); virtual ~BasicHashTable(); //======== class iteratr ===================================== // Used to iterate through the members of the table: class Iterator; friend class Iterator; // to make Sun&#39;s C++ compiler happy class Iterator : public HashTable::Iterator { public: //绑定到table Iterator(BasicHashTable&amp;amp; table); private: // implementation of inherited pure virtual functions //设置key为下一个节点的key,返回下一个节点的value。如果下一个不存在，返回NULL void* next(char const*&amp;amp; key); // returns 0 if none private: BasicHashTable&amp;amp; fTable;	//绑定一个哈希表 unsigned fNextIndex; // index of next bucket to be enumerated after this TableEntry* fNextEntry; // next entry in the current bucket }; //=========================================================== private: // implementation of inherited pure virtual functions //继承的纯虚函数的实现 virtual void* Add(char const* key, void* value); // Returns the old value if different, otherwise 0 // 如果不同的话返回旧值，否则为0 virtual Boolean Remove(char const* key); virtual void* Lookup(char const* key) const; // Returns 0 if not found //获取当前条目数 virtual unsigned numEntries() const; private: //======== class TableEntry ================================= class TableEntry { public: TableEntry* fNext;	//下一个指针 char const* key;	//键 void* value;	//值 }; //=========================================================== //使用key来确定index和要查找的条目 TableEntry* lookupKey(char const* key, unsigned&amp;amp; index) const; // returns entry matching &amp;quot;key&amp;quot;, or NULL if none //返回“key”匹配的条目，如果没有找到返回null //比较两个key是否一样 Boolean keyMatches(char const* key1, char const* key2) const; // used to implement &amp;quot;lookupKey()&amp;quot; // 用于实现 &amp;quot;lookupKey()&amp;quot; //创建一个条目，将其放入到桶数组的index位置 TableEntry* insertNewEntry(unsigned index, char const* key); // creates a new entry, and inserts it in the table // 创建一个新条目，并插入到这个哈希表 //给一个条目entry的key成员赋值(绑定一个key) void assignKey(TableEntry* entry, char const* key); // used to implement &amp;quot;insertNewEntry()&amp;quot; // 用于实现“insertNewEntry” //从哈希表中找到entry，移除后销毁 void deleteEntry(unsigned index, TableEntry* entry); //将条目entry的key删除 void deleteKey(TableEntry* entry); // used to implement &amp;quot;deleteEntry()&amp;quot; // 用于实现 &amp;quot;deleteEntry()&amp;quot; //重建哈希表，重建的尺寸是以前的四倍 void rebuild(); // rebuilds the table as its size increases //重建表作为它的尺寸的增加而增加 //从key散列索引,通过key来获取一个索引值 unsigned hashIndexFromKey(char const* key) const; // used to implement many of the routines above // 用于实现许多以上的程序 //随机索引，其实并非随机。产生一个与i有关的随机值，这是单向不可逆的 unsigned randomIndex(uintptr_t i) const { //1103515245这个数很有意思，rand函数线性同余算法中用来溢出的 //这个函数的作用就是返回一个随机值，因为默认fMask(0x3)，也就是只保留两位 //为什么只要保留2位，也就是0 1 2 3 这四种结果咯，因为桶默认只有四个 return (unsigned)(((i * 1103515245) &amp;gt;&amp;gt; fDownShift) &amp;amp; fMask); } private: TableEntry** fBuckets; // pointer to bucket array 指向 桶数组，桶中保存TableEntry对象地址 TableEntry* fStaticBuckets[SMALL_HASH_TABLE_SIZE];// used for small tables 用于小表 unsigned fNumBuckets/*桶数*/, fNumEntries/*节点数*/, fRebuildSize/*重建尺寸大小*/, fDownShift/*降档变速*/, fMask/*掩码*/; int fKeyType; };  ##迭代器BasicHashTable::Iterator</description>
    </item>
    
    <item>
      <title>15 BasicHashTable基本哈希表类(二)——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-25-15-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-15-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599556.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##BasicHashTable的辅助方法
这里介绍的是一些用来对哈希表进行一些基本的哈希操作的函数。
##randomIndex(uintptr_t i) const方法
randomIndex(uintptr_t i) const方法是这个BasicHashTable的散列算法。它将各个TableEntry对象的key散列到不同的桶中去，就是获取key对应桶的索引。
下面代码中的注释已经比较清楚了，稍微再解释一下。 &amp;gt; 我们之前已经说过了，一个桶可能会有多个条目相关联。哈希表的特点就是要快速查找，那么一个key对应到一个桶，然后从桶中查找条目就加快了速度。这个i * 1103515245就是一个用来产生伪随机数的操作。这个函数在key类型不为字符串的时候会使用到。因为是伪随机数，所以只要i不变，结果就不变。在使用的时候会使用key来替代i。所以只要key相同，会散列到同一个桶中。
fDownShift是用来降档移位的。如果 i=123,那么i * 1103515245的结果是 135732375135 转为二进制就是
1001 1010 0100 0111 1010 1110 0101 1111	这里只看32位，溢出的部分不要了，然后将其左移 fDownShift =28 位 0000 0000 0000 0000 0000 0000 0000 1001	这也一来就只剩下了最后四位有效了，其余的都被清零了。然后&amp;amp;fMask=0x3 0000 0000 0000 0000 0000 0000 0000 0001	因为0x3的二进制形式为 0011（前面28位皆为0），所以相当于就是清零了 前面的30位，只留下最低两位。之前说过默认的桶数是4个，而两个二进制位 能表示的是 0、1、2、3四种可能，刚刚好。  如果重建桶，那么fDownShift和fMask的值必须有相应的改变。这个在后面会介绍。这里补充一下，上面所做的二进制表示都是在小端序的情况下的。
//随机化索引，其实并非随机。产生一个与i有关的随机值，这是单向不可逆的 unsigned randomIndex(uintptr_t i) const { //1103515245这个数很有意思，rand函数线性同余算法中用来溢出的 //这个函数的作用就是返回一个随机值，因为默认fMask(0x3)，也就是只保留两位 //为什么只要保留2位，也就是0 1 2 3 这四种结果咯，因为桶默认只有四个 // fDownShift用来移位，其默认是28，每次调整哈希表大小的时候会减2 return (unsigned)(((i * 1103515245) &amp;gt;&amp;gt; fDownShift) &amp;amp; fMask); }  ##hashIndexFromKey(char const* key) const方法 hashIndexFromKey方法将一个key值散列得到一个index索引值。</description>
    </item>
    
    <item>
      <title>16 BasicHashTable基本哈希表类(三)——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-25-16-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%B8%89live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-16-basichashtable%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E8%A1%A8%E7%B1%BB%E4%B8%89live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599643.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##哈希表的增删查改
这是BasicHashTable基本哈希表类源码分析的最后一个部分，即哈希表的基本操作方法。这里时间没有直接给出修改条目的方法，因为它包含在了add方法中。
##Add方法(增加条目)
Add方法先从哈希表中查找参数key对应的条目是否存在，存在的话替换value,不存在就创建一个条目，并加入哈希表。如果加入后哈希表的条目过多了，就重建哈希表。其返回值为原来key对应条目的value，如果不存在，返回NULL。
void* BasicHashTable::Add(char const* key, void* value) { void* oldValue; unsigned index; TableEntry* entry = lookupKey(key, index); if (entry != NULL) { // There&#39;s already an item with this key oldValue = entry-&amp;gt;value; } else { // There&#39;s no existing entry; create a new one: entry = insertNewEntry(index, key); oldValue = NULL; } entry-&amp;gt;value = value; // If the table has become too large, rebuild it with more buckets: // 如果该表已经变得太大，重建更多的桶给它： if (fNumEntries &amp;gt;= fRebuildSize) rebuild(); return oldValue; }  ##Remove方法(删除条目)</description>
    </item>
    
    <item>
      <title>17 任务调度相关类综述——Live555源码阅读(一)任务调度相关类</title>
      <link>http://sotex.github.io/post/2015-06-25-17-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%BC%E8%BF%B0live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-17-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%BC%E8%BF%B0live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599872.html 这是Live555源码阅读的第二部分，包括了任务调度相关的三个类。任务调度是Live555源码中很重要的部分。
 本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
 任务调度是Live555源码中很重要的部分。前面介绍的基本组件类在这里都用到了。 任务调度部分有三个类，其有继承关系。 抽象基类TaskScheduler 派生出 BasicTaskScheduler0，BasicTaskScheduler0 再派生出BasicTaskScheduler。
##TaskScheduler主要是一些接口的定义。
BasicTaskScheduler0主要实现了触发事件的管理。触发事件其主要有三个要素，分别是触发调用函数，数据参数，和等待触发掩码。其中触发调用函数地址保存在函数指针数组中(触发函数类型是：void TaskFunc(void* clientData))，数据参数保存在数据参数指针数组里(void*),等待触发掩码是用于控制其在doEventLoop调用的SingleStep中是否被触发的标识。 &amp;gt;
BasicTaskScheduler是任务调度器的最终成果。它包含了上述两者，并加入了延时队列DelayQueue和处理程序链表HandlerSet成员。在SingleStep中使用了select 非阻塞I/O模型来进行处理fHandlerSet链表中的处理程序对象。fHandlerSet中的链表节点成员是HandlerDescriptor对象类型，其有四个重要的成员(socketNum/conditionSet/handlerProc/clientData)，在前面介绍过，这里再提一下。socketNum用来标识节点，在这里应当会赋予一个网络socket套接口给它；handlerProc是调用的函数的地址，其类型是TaskScheduler::BackgroundHandlerProc*，而BackgroundHandlerProc的类型是void BackgroundHandlerProc(void* clientData, int mask)，所以其是一个类成员函数指针类型 。clientData和conditionSet都是其参数，其中conditionSet是用于socketNum的读、写、异常操作的的掩码。</description>
    </item>
    
    <item>
      <title>18 TaskScheduler任务调度器抽象基类——Live555源码阅读(一)任务调度相关类</title>
      <link>http://sotex.github.io/post/2015-06-25-18-taskscheduler%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-18-taskscheduler%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599955.html 这是Live555源码阅读的第二部分，包括了任务调度相关的三个类。任务调度是Live555源码中很重要的部分。
 本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
 ##TaskScheduler任务调度器抽象基类
TaskScheduler是一个抽象基类，其定义在live555sourcecontrol\UsageEnvironment\include\UsageEnvironment.hh文件中。 TaskScheduler声明了很多纯虚接口，其实现一般在class BasicTaskScheduler0中。这里简要介绍一下。 TaskScheduler的默认构造函数是protected权限的，也就是只能被其内部的或派生类的方法调用。 这里先列出三个类型定义，这个在后面就不介绍了。在前面AlarmHandler中提过。
typedef void TaskFunc(void* clientData); typedef void* TaskToken;	//token 标志 typedef u_int32_t EventTriggerId;	//Trigger 触发  ##TaskScheduler的定义如下
//任务调度器 class TaskScheduler { public: virtual ~TaskScheduler(); /* 这是一个纯虚接口，在BasicTaskScheduler0中有一个实现*/ virtual TaskToken scheduleDelayedTask(int64_t microseconds, TaskFunc* proc, void* clientData) = 0; /* 这是一个纯虚接口，在BasicTaskScheduler0中有一个实现*/ virtual void unscheduleDelayedTask(TaskToken&amp;amp; prevTask) = 0; // 没有影响，如果 prevTask == NULL // 完成之后将设置 prevTask 为NULL // 虚接口，重新调度延时任务 // 先调用unscheduleDelayedTask(task); // 在调用task = scheduleDelayedTask(microseconds, proc, clientData); virtual void rescheduleDelayedTask(TaskToken&amp;amp; task, int64_t microseconds, TaskFunc* proc, void* clientData); // For handling socket operations in the background (from the event loop): // 后台处理套接字操作类型（从事件循环）：注意，这是一个类型定义 typedef void BackgroundHandlerProc(void* clientData, int mask); // 设置掩码位为mask,这是特意这样定义的，为了符合Tcl接口的一致性 // Tcl 是“工具控制语言（Tool Control Language）”的缩写。Tk 是 Tcl“图形工具箱”的扩展 // 它提供各种标准的 GUI 接口项，以利于迅速进行高级应用程序开发 #define SOCKET_READABLE (1&amp;lt;&amp;lt;1)	//readable adj.</description>
    </item>
    
    <item>
      <title>19 BasicTaskScheduler0 基本任务调度类基类（一）——Live555源码阅读(一)任务调度相关类</title>
      <link>http://sotex.github.io/post/2015-06-25-19-basictaskscheduler0-%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-19-basictaskscheduler0-%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599968.html 这是Live555源码阅读的第二部分，包括了任务调度相关的三个类。任务调度是Live555源码中很重要的部分。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##BasicTaskScheduler0 基本任务调度类基类
BasicTaskScheduler0是一个用作传递的类，它继承自TaskScheduler，又派生出BasicTaskScheduler。其定义在live555sourcecontrol\UsageEnvironment\include\BasicUsageEnvironment0.hh文件中。 这个类实现了TaskScheduler中的纯虚接口，并增加了一些数据成员。其中比较重要的两个是fDelayQueue(延时队列)和fHandlers(处理程序集合/链表)。
##下面是其定义代码，里面有一些是对注释的翻译。
class HandlerSet; // forward #define MAX_NUM_EVENT_TRIGGERS 32 // An abstract base class, useful for subclassing 抽象基类，用于子类化 // (e.g., to redefine the implementation of socket event handling) // 例如，重新定义socket事件处理的实现 class BasicTaskScheduler0 : public TaskScheduler { public: //析构的时候 delete fHandlers virtual ~BasicTaskScheduler0(); //设置select轮询的超时时间的最大值，如果maxDelatTime不大于0，那么就设置为一百万秒 virtual void SingleStep(unsigned maxDelayTime = 0) = 0; // &amp;quot;maxDelayTime&amp;quot; is in microseconds. It allows a subclass to impose a limit // maxDelayTime 单位是微秒，它允许一个子类施加限制 // on how long &amp;quot;select()&amp;quot; can delay, in case it wants to also do polling.</description>
    </item>
    
    <item>
      <title>20 BasicTaskScheduler0 基本任务调度类基类（二）——Live555源码阅读(一)任务调度相关类</title>
      <link>http://sotex.github.io/post/2015-06-25-20-basictaskscheduler0-%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-20-basictaskscheduler0-%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9F%BA%E7%B1%BB%E4%BA%8Clive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599973.html 这是Live555源码阅读的第二部分，包括了任务调度相关的三个类。任务调度是Live555源码中很重要的部分。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##scheduleDelayedTask方法(调度延时任务)
scheduleDelayedTask方法有三个参数，分别是时间microseconds，任务proc，数据clientData。 其使用这三个参数创建一个定时处理程序对象AlarmHandler(proc, clientData, timeToDelay)，并将这个对象添加到延时队列链表中管理起来。返回了一个这个对象的唯一标识token。
TaskToken BasicTaskScheduler0::scheduleDelayedTask(int64_t microseconds, TaskFunc* proc, void* clientData) { if (microseconds &amp;lt; 0) microseconds = 0; DelayInterval timeToDelay((long)(microseconds/1000000), (long)(microseconds%1000000)); AlarmHandler* alarmHandler = new AlarmHandler(proc, clientData, timeToDelay); fDelayQueue.addEntry(alarmHandler); return (void*)(alarmHandler-&amp;gt;token()); } unscheduleDelayedTask方法(取消调度延时任务) unscheduleDelayedTask方法将pervTask代表的节点从延时队列中移除，并销毁。参数类型TaskToKen实质是一个void*型。其应该传入的是一个AlarmHandler对象的token标识。 void BasicTaskScheduler0::unscheduleDelayedTask(TaskToken&amp;amp; prevTask) { DelayQueueEntry* alarmHandler = fDelayQueue.removeEntry((intptr_t)prevTask); prevTask = NULL; delete alarmHandler; }  ##doEventLoop方法(事件处理循环)
这是一个死循环，在符合条件的时候，会不断调用SingleStep。这个方法是做一次事件轮询处理。参数watchVariable是用来控制是否继续循环的，如果它指向的地址的内容不是’\0’，那么就会跳出死循环，不再继续。 SingleStep在派生类BasicTaskScheduler中实现。
void BasicTaskScheduler0::doEventLoop(char* watchVariable) { // Repeatedly loop, handling readble sockets and timed events: // 反复循环，可读取套接字和定时事件的处理： while (1) { if (watchVariable !</description>
    </item>
    
    <item>
      <title>21 BasicTaskScheduler基本任务调度器（一）——Live555源码阅读(一)任务调度相关类</title>
      <link>http://sotex.github.io/post/2015-06-25-21-basictaskscheduler%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-21-basictaskscheduler%E5%9F%BA%E6%9C%AC%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%80live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599996.html  21_BasicTaskScheduler基本任务调度器（一）&amp;mdash;&amp;mdash;Live555源码阅读(一)任务调度相关类  BasicTaskScheduler基本任务调度器  BasicTaskScheduler基本任务调度器的定义 BasicTaskScheduler的构造与析构  下面来介绍一下schedulerTickTask函数(调度滴答任务)       这是Live555源码阅读的第二部分，包括了任务调度相关的三个类。任务调度是Live555源码中很重要的部分。
 本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
 BasicTaskScheduler::BasicTaskScheduler() fMaxNumSockets(0) { FD_ZERO(&amp;amp;fReadSet); FD_ZERO(&amp;amp;fWriteSet); FD_ZERO(&amp;amp;fExceptionSet);
schedulerTickTask(this); //ensures that we handle events frequently }   &amp;nbsp;
&amp;nbsp; 下面来介绍一下schedulerTickTask函数(调度滴答任务) 这个函数的作用就是将其参数转为(BasicTaskScheduler)类型，然后调用scheduleDelayedTask来调度(创建)一个延时任务。有意思的是，这个延时任务程序就是这个函数自身，延时任务程序的参数也是其参数。延时时间是10毫秒。
这有点像是函数递归调用了。与之不同的是，如果不去调度任务，递归就是无效的。
#define MAX_SCHEDULER_GRANULARITY 10000 //10 microseconds: We will return to the event loop at least this often static void schedulerTickTask(voidclientData) { ((BasicTaskScheduler*)clientData)-&amp;gt;scheduleDelayedTask(MAX_SCHEDULER_GRANULARITY, schedulerTickTask, clientData); }  &amp;nbsp;</description>
    </item>
    
    <item>
      <title>net-snmp的MIBs扩展（linux下）</title>
      <link>http://sotex.github.io/post/2015-06-25-net-snmp%E7%9A%84mibs%E6%89%A9%E5%B1%95linux%E4%B8%8B/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-25-net-snmp%E7%9A%84mibs%E6%89%A9%E5%B1%95linux%E4%B8%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/25/4599501.html net-snmp的MIBs扩展  net-snmp的MIBs扩展   1 编译安装net-snmp  2 编写MIB文件   MIB文件描述  一个简单的示例    3 使自定义的MIB文件生效  4 实现agent代理程序   使用mib2c程序来生成.c和.h文件。  只读节点readObject.c和readObject.h的修改。   编译一下  运行测试一下    读写节点writeObject.c的修改   编译运行测试一下             MIB的相关概念 在SNMP网络管理中，管理信息库MIB（Management Information Base）是对于通过网络管理协议可以访问的信息。这些信息更具体的理解为网管中被管资源，而网络管理中的资源是以对象来表示，每一个对象表示被管资源某一方面的属性，这些对象的集合形成管理信息库。    先说一下系统环境 &amp;nbsp;&amp;nbsp;&amp;nbsp; 
  o@o-pc:~$ uname -a Linux o-pc 3.</description>
    </item>
    
    <item>
      <title>10 DelayQueue 延时队列类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-10-delayqueue-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-10-delayqueue-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596854.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##DelayQueue 延时队列类
这个类的设计不是很复杂，但是要清楚的知道其设计的思路。先给个图
10_DelayQueue.png 这个链表的设计和前面不一样。其内部只有一个EventTime fLastSyncTime最后同步时间的数据成员。并不包含一个链表的头结点。但是其本身是DelayQueueEntry的派生类，所以其本身就是一个链表头结点。
我们前面说了，DealyQueueEntry的构造函数是protected权限的，而DelayQueue是其友元。在后面说还会说到AlarmHandler类，这个类对象才是真正的链表节点（头结点除外）。
DelayQueue类的定义 ///// DelayQueue ///// // 延时队列(链表) class DelayQueue: public DelayQueueEntry { public: // 设置头结点的 延时剩余时间 为 永恒 // 设置最后同步时间为当前时间 DelayQueue(); virtual ~DelayQueue(); //添加记录(节点) void addEntry(DelayQueueEntry* newEntry); // returns a token for the entry void updateEntry(DelayQueueEntry* entry, DelayInterval newDelay); void updateEntry(intptr_t tokenToFind, DelayInterval newDelay); void removeEntry(DelayQueueEntry* entry); // but doesn&#39;t delete it DelayQueueEntry* removeEntry(intptr_t tokenToFind); // but doesn&#39;t delete it // 获取头结点的 延时剩余时间 DelayInterval const&amp;amp; timeToNextAlarm(); //判断头结点的 延时剩余时间 是否为 DELAY_ZERO 是的话从链表中移除 // 并由头结点调用handleTimeout方法(delete this) void handleAlarm(); private: DelayQueueEntry* head() { return fNext; } DelayQueueEntry* findEntryByToken(intptr_t token); //把“剩余时间”域更新。 // 设置最后同步时间为当前时间 // 从链表头节点开始，遍历，看节点的延时时间是否到了,到了的设置为 DELAY_ZERO //	从这里可以看出来，链表中节点保存的 延时剩余时间 是与前一个节点有关系的 //	当前节点 总的延时时间，应该是当前节点的 延时剩余时间 加上前一个节点的 总的延时时间 void synchronize(); // bring the &#39;time remaining&#39; fields up-to-date EventTime fLastSyncTime;	//最后同步时间 };  ##DelayQueue的构造与析构</description>
    </item>
    
    <item>
      <title>11 AlarmHandler定时处理类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-11-alarmhandler%E5%AE%9A%E6%97%B6%E5%A4%84%E7%90%86%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-11-alarmhandler%E5%AE%9A%E6%97%B6%E5%A4%84%E7%90%86%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596870.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/ 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##AlarmHandler定时处理类
这个类定义在live555sourcecontrol\BasicUsageEnvironment\BasicTaskScheduler0.cpp文件中。
AlarmHandler继承自DelayQueueEntry其是用来作为DelayQueued 的节点的。其和HanlerDescriptor有点像。其有在DelayQueueEntry的基础上又增加了两个数据成员，一个函数指针TaskFunc* fProc和一个数据地址void* fClientData（这个在使用的时候会是调用函数的对象。即函数指针是对象的成员函数地址，数据地址就是对象的地址）。回想一下DelayQueueEntry是链表的节点，有前驱和后继指针，延时剩余时间，token标识。
////////// A subclass of DelayQueueEntry, ////////// used to implement BasicTaskScheduler0::scheduleDelayedTask() class AlarmHandler: public DelayQueueEntry { public: AlarmHandler(TaskFunc* proc, void* clientData, DelayInterval timeToDelay) : DelayQueueEntry(timeToDelay), fProc(proc), fClientData(clientData) { } private: // redefined virtual functions virtual void handleTimeout() { (*fProc)(fClientData); DelayQueueEntry::handleTimeout(); } private: TaskFunc* fProc; void* fClientData; };  </description>
    </item>
    
    <item>
      <title>2 DelayInterval延时间隔类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-2-delayinterval%E5%BB%B6%E6%97%B6%E9%97%B4%E9%9A%94%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-2-delayinterval%E5%BB%B6%E6%97%B6%E9%97%B4%E9%9A%94%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596822.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。 这里是时间相关类的第二个部分。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
##DelayInterval延时间隔类 DelayInterval这个类只是为了在名字上方便使用。我们可以看上面的TimeVal类，其带参构造函数是protected权限的，这里的定义就是暴露了一个构造接口，方便使用。
class DelayInterval: public Timeval { public: DelayInterval(time_base_seconds seconds, time_base_seconds useconds) : Timeval(seconds, useconds) {} };  除此之外DelayInterval类还重载了全局的 “ * ”运算符。注意，这个不是在DelayInterval类内部重载的，这里的第一个参数是short类型。其使用的时候是类似于这样的 result = arg1 * arg2;其中result和arg2是DelayInterval对象。
DelayInterval operator*(short arg1, DelayInterval const&amp;amp; arg2);  其实现如下
DelayInterval operator*(short arg1, const DelayInterval&amp;amp; arg2) { time_base_seconds result_seconds = arg1*arg2.seconds(); time_base_seconds result_useconds = arg1*arg2.useconds(); time_base_seconds carry = result_useconds/MILLION; result_useconds -= carry*MILLION; result_seconds += carry; return DelayInterval(result_seconds, result_useconds); }  </description>
    </item>
    
    <item>
      <title>3 EventTime 事件时间类和TimeNow函数——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-3-eventtime-%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E7%B1%BB%E5%92%8Ctimenow%E5%87%BD%E6%95%B0live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-3-eventtime-%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E7%B1%BB%E5%92%8Ctimenow%E5%87%BD%E6%95%B0live555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596828.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。 这里是时间相关类的第三个部分，也是最后一个部分。
##EventTime 事件时间类 这个类和DelayInterval类的是类似的，就是其构造函数默认参数是0。
class EventTime: public Timeval { public: EventTime(unsigned secondsSinceEpoch = 0, unsigned usecondsSinceEpoch = 0) // We use the Unix standard epoch: January 1, 1970 : Timeval(secondsSinceEpoch, usecondsSinceEpoch) {} };  ##全局函数EventTime TimeNow(); 全局函数EventTime TimeNow()是用来获取当前时间的函数。其实现如下
EventTime TimeNow() { struct timeval tvNow; gettimeofday(&amp;amp;tvNow, NULL); return EventTime(tvNow.tv_sec, tvNow.tv_usec); }  最后来一张图片，看看这时间相关类的关系 </description>
    </item>
    
    <item>
      <title>4 Handler相关类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-4-handler%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-4-handler%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596829.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
##Handler相关类概述 处理程序相关类一共有三个，其没有派生继承关系，但是其有友元关系和使用关系。处理程序相关类主要是用于对相关的处理函数的指针和数据的包装，方便在DelayQueue相关类中的使用等。 先来总的说以下三个类的关系。 HandlerDescriptor是一个节点类，而HandlerSet是一个链表类，链表节点就是HandlerDescriptor对象。HandlerIterator是一个迭代器类，其绑定一个HandlerSet对象。 处理程序相关的三个类都定义在live555sourcecontrol\BasicUsageEnvironment\include\HandlerSet.hh文件中。</description>
    </item>
    
    <item>
      <title>5 HandlerIterator处理程序迭代器类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-5-handleriterator%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-5-handleriterator%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596833.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##HandlerIterator处理程序迭代器类 这里本应该先介绍HandlerDescriptor类的，因为这个类与它的关联比较大，就先介绍这个类。 HandlerIterator是一个迭代器类，其有两个数据成员，分别是HandlerSet类对象的引用fOurSet，以及一个HandlerDescriptor对象指针fNextPtr。并且HandlerIterator同时是节点和链表的友元类。 fOurSet是一个引用，就说明了HandlerIterator的初始化必须要绑定一个HandlerSet对象。而HandlerSet类的对象又是一个链表，其节点是HandlerDescriptor对象。迭代器对象仅在HandlerSet类中使用。 迭代器构造的时候，会将其fNextPtr指向链表的头节点的下一个。
###下面是HandlerIterator类定义
// 处理程序描述链表迭代器类 class HandlerIterator { public: // 必须绑定到一个处理程序描述链表对象，并调用reset()将fNextPtr赋值为handlerSet.fNextHandler HandlerIterator(HandlerSet&amp;amp; handlerSet); virtual ~HandlerIterator(); // 返回fNextPtr,并将fNextPtr指向下一个处理程序描述对象 HandlerDescriptor* next(); // returns NULL if none void reset();	//将 fNextPtr 指向链表的头结点的下一个 private: HandlerSet&amp;amp; fOurSet;	//指向绑定链表的引用 HandlerDescriptor* fNextPtr;	//处理程序描述对象指针 };  ###next方法(获取链表节点，迭代器后移) 这里返回的是当前迭代器指向的元素，但是迭代器会走向下一个。如果走到了末尾元素位置，迭代器将不会循环到第一个，而是停滞不前，并返回NULL。
HandlerDescriptor* HandlerIterator::next() { HandlerDescriptor* result = fNextPtr; //要注意的是，这里是走到了最后一个，因为这是循环链表 if (result == &amp;amp;fOurSet.fHandlers) { // no more result = NULL; } else { fNextPtr = fNextPtr-&amp;gt;fNextHandler; } return result; }  </description>
    </item>
    
    <item>
      <title>6 HandlerDescriptor 处理程序描述类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-6-handlerdescriptor-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-6-handlerdescriptor-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596836.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
##HandlerDescriptor 处理程序描述类
HandlerDescriptor类是一个很重要的类，其保存了处理程序的函数指针和相关的数据的地址。在构建处理任务的时候，会使用到这个类的对象，处理任务的时候也会用到。 HandlerDescriptor类同时将HandlerIterator类和HandlerSet类声明为友元类，方便了后面链表的操作。个人觉得这种封装方式不是特别好。只是个人看法而已。
这里的封装还有一个原因就是因为构造和析构都是private权限的，因为只能在其友元类HandlerSet中来调用，避免暴露接口。 这里要特别提一下数据成员socketNum和conditionSet。socketNum在链表中要来标识一个节点，那么这socketNum的值是如何赋值来的呢？这里先提一下，在使用到这个类对象的时候，会将一个socket套接口作为其值(windows下是SOCKET类型linux/unix下是文件描述符，其实质都是int类型)，它必然是唯一的。这个变量名取为socketNum就是因为后面它将用于网络。而conditionSet是条件集合的意思，用来标识对应socketNum代表的套接口可以采取那写操作(读/写/异常)。 还有注意的是handlerProc的类型是一个类成员函数指针，它应该指向一个TaskScheduler的函数成员地址。(《C++必知必会》一个指向成员的指针并不指向一个具体的内存地址，它指向的是一个类的特定成员，而不是指向一个特定对象里的特定成员。)
###下面是HandlerDesciptor类的定义
// 处理程序描述类(作为链表的节点) class HandlerDescriptor { //构造和析构都是private权限的，因为只能在其友元类HandlerSet中来调用 // 如果nextHandler为其自身，自身就是双向链表的头结点 // 否则将自身插入到nextHandler和nextHandler-&amp;gt;fPrevHandler之间 HandlerDescriptor(HandlerDescriptor* nextHandler); // 将自身从双向链表中移除。这个函数一般由delete操作来调用 virtual ~HandlerDescriptor(); public: int socketNum;	//socket在链表里面用来标识节点 int conditionSet;	//条件集合 //typedef void BackgroundHandlerProc(void* clientData, int mask); TaskScheduler::BackgroundHandlerProc* handlerProc;	//后台处理程序函数指针 void* clientData;	//客户端数据 private: // Descriptors are linked together in a doubly-linked list: friend class HandlerSet; friend class HandlerIterator; HandlerDescriptor* fNextHandler;	//下一个处理程序描述 HandlerDescriptor* fPrevHandler;	//上一个处理程序描述 };  ###HandlerDescriptor的构造函数 从其构造函数可以看出，其默认只被用于链表中作为节点存在。并且这个构造函数是private权限的，只有在本类或者友元类中可以使用其来构造对象。</description>
    </item>
    
    <item>
      <title>7 HandlerSet 处理程序链表类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-7-handlerset-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-7-handlerset-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596843.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
##HandlerSet 处理程序链表类 这里使用的Set这个单词，Set是集合的意思，这里实质上是一个双向循环链表。这个类比较重要，这里会详细的介绍。 HandlerSet类只有一个数据成员，就是HandlerDescriptor fHandlers;这是作为链表的头结点而存在的。  ###HandlerSet的定义，代码如下
class HandlerSet { public: //设置fHandlers的下一个和上一个指向fHandler自己 HandlerSet(); //逐个释放链表节点 virtual ~HandlerSet(); // 从链表中查找socketNum代表的HandlerDescriptor,如果没有找到就创建一个并加入到链表 void assignHandler(int socketNum, int conditionSet, TaskScheduler::BackgroundHandlerProc* handlerProc, void* clientData); //从链表中查找socketNum对应的HandlerDescriptor，找到了就delete void clearHandler(int socketNum); // 从链表中查找oldSocketNum代表的HandlerDescriptor,找到了就将其sockerNum成员替换为newSocketNum void moveHandler(int oldSocketNum, int newSocketNum); private: // 从链表中查找socketNum代表的HandlerDescriptor，没找到返回NULL HandlerDescriptor* lookupHandler(int socketNum); private: friend class HandlerIterator; HandlerDescriptor fHandlers;	//处理程序描述对象 链表头节点 };  ###HandlerSet的构造 在其构造函数中，默认对头结点HandlerDescriptor fHandlers进行了初始化操作。
HandlerSet::HandlerSet() : fHandlers(&amp;amp;fHandlers) { fHandlers.socketNum = -1; // shouldn&#39;t ever get looked at, but in case.</description>
    </item>
    
    <item>
      <title>8 延时队列相关类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-8-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-8-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596846.html
这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。 本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
##延时队列相关类
延时队列相关类一共有两个，DelayQueue(延时队列)和DelayQueueEntry(延时队列节点)。后面说到任务调度器(TaskScheduler)的时候会使用到。 DelayQueue是DelayQueueEntry的派生类，同时也是它的友元类。其定义在live555sourcecontrol\BasicUsageEnvironment\include\DelayQueue.hh文件中。
###结构关系如下图
8_delay.png </description>
    </item>
    
    <item>
      <title>9 DelayQueueEntry 延时队列节点类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-9-delayqueueentry-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-9-delayqueueentry-%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E8%8A%82%E7%82%B9%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596849.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。
本文由乌合之众 lym瞎编，欢迎转载 http://www.cnblogs.com/oloroso/
##DelayQueueEntry 延时队列节点类 entry的意思如下 &amp;gt; entry n.进入，入场; 入口处，门口; 登记，记录; 参加比赛的人;
为什么说是节点类呢？这个通过阅读代码就可以知道了。 DelayQueueEntry类含有四个数据成员，其中fNext和fPrev说明了其是一个链表的节点。fToken是节点的标识，DelayInterval fDeltaTimeRemaining成员是一个代表时间间隔的量，在后面任务调度器调度任务的时候会使用到。
9_DelayQueueEntry.png 还有一个静态的成员static intptr_t tokenCounter用来作为token标识的不重复的初始化;注意，静态成员不是对象的成员，而是类的成员。(所有的对象共享这一个) 这里可以看到，其构造函数是protected权限的，而析构函数是public权限的。且没有了别的构造相关方法，也就是说这个类对象只能由其派生类来创建，但是销毁是对外开放的。其派生类有两个AlarmHandler和DelayQueue。
///// DelayQueueEntry ///// // 延时队列记录(节点) entry n.进入，入场; 入口处，门口; 登记，记录; 参加比赛的人; class DelayQueueEntry { public: virtual ~DelayQueueEntry(); intptr_t token() { return fToken; } protected: // abstract base class DelayQueueEntry(DelayInterval delay); // delete this; virtual void handleTimeout(); private: friend class DelayQueue; DelayQueueEntry* fNext;	//下一个节点 DelayQueueEntry* fPrev;	//上一个节点 DelayInterval fDeltaTimeRemaining;	//延时剩余的时间 intptr_t fToken;	//标识，等指针宽度的int型 static intptr_t tokenCounter;	//标识计数(注意此处是static 变量) };  ##DelayQueueEntry的构造</description>
    </item>
    
    <item>
      <title>QT国际化 一 (lupdate/linguits/lrelease)</title>
      <link>http://sotex.github.io/post/2015-06-24-qt%E5%9B%BD%E9%99%85%E5%8C%96-%E4%B8%80-lupdate.linguits.lrelease/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-qt%E5%9B%BD%E9%99%85%E5%8C%96-%E4%B8%80-lupdate.linguits.lrelease/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596740.html #QT国际化(lupdate/linguits/lrelease)
本文由乌合之众瞎写http://www.cnblogs.com/oloroso/
qt国际化其实就是qt中显示文本语言的设置。
QT提供了QTextCodec类来进行文本字符集的转换操作。 本文的重点不在于此。深入学习可以看
 QTextCodec &amp;amp;&amp;amp; 字符编码  Qt 编码问题QTextCodec   本文的重点在于QT界面显示的中文化。
##1、控制需要翻译的文本
在编写QT程序的时候，对于要翻译的文本，应当使用tr()包含起来。 我们先来看看tr函数的原型，注意，这是一个静态函数。
QString QObject::tr(const char * sourceText, const char * disambiguation = 0, int n = -1)  因为Qt中的类都继承自QObject类，所以这里直接使用了tr，如果不是在继承自QT的类中使用，应该用Object::tr(...)来调用。
这还不是很准确，在宏定义Q_OBJECT展开后，会创建一个QMetaObject对象，即static const QMetaObject staticMetaObject;这个可以看看
#define Q_OBJECT \ public: \ Q_OBJECT_CHECK \ static const QMetaObject staticMetaObject;\ Q_OBJECT_GETSTATICMETAOBJECT \ virtual const QMetaObject *metaObject() const; \ virtual void *qt_metacast(const char *); \ QT_TR_FUNCTIONS \ virtual int qt_metacall(QMetaObject::Call,int, void **); \ private:  展开一个宏定义QT_TR_FUNCTIONS，而这里面定义了一个内联的tr函数。可以看出这里实际是使用了一个静态对象staticMetaObject的成员函数tr。</description>
    </item>
    
    <item>
      <title>TimeVal类——Live555源码阅读(一)基本组件类</title>
      <link>http://sotex.github.io/post/2015-06-24-timeval%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</link>
      <pubDate>Wed, 24 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-24-timeval%E7%B1%BBlive555%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E7%B1%BB/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/24/4596812.html 这是Live555源码阅读的第一部分，包括了时间类，延时队列类，处理程序描述类，哈希表类这四个大类。 这里是时间相关类的第一个部分。 ##TimeVal类 TimeVal类定义在live555sourcecontrol\BasicUsageEnvironment\include\DelayQueue.hh文件中。其实质上是对struct timeval的封装。 先来看看TimeVal类的组成。 其只有一个数据成员，就是一个timeval的结构体fTv。TimeVal类封装的所有方法都是对其的操作。 TimeVal类的uml图 ###struct timeval结构体 再来看看这个 struct timeval结构体的定义
struct timeval { long tv_sec; /* seconds 秒*/ long tv_usec; /* and microseconds 微秒*/ };  ###下面是TimeVal类的定义。 TimeVal类的定义很简单，就不详述了。TimeVal类还有两个派生类。在另外的文章中来说。
class Timeval { public: time_base_seconds seconds() const { return fTv.tv_sec; } time_base_seconds seconds() { return fTv.tv_sec; } time_base_seconds useconds() const { return fTv.tv_usec; } time_base_seconds useconds() { return fTv.tv_usec; } int operator&amp;gt;=(Timeval const&amp;amp; arg2) const; int operator&amp;lt;=(Timeval const&amp;amp; arg2) const { return arg2 &amp;gt;= *this; } int operator&amp;lt;(Timeval const&amp;amp; arg2) const { return !</description>
    </item>
    
    <item>
      <title>1 python学习——python环境配置</title>
      <link>http://sotex.github.io/post/2015-06-23-1-python%E5%AD%A6%E4%B9%A0python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-1-python%E5%AD%A6%E4%B9%A0python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description> [TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594761.html #1 python学习——python环境配置
要学习python语言，光看书看教程还是不好，得动手去写。当然，不管学习什么编程语言，最佳的方式还在于实践。
要实践，先得有一个Python解释器来解释执行我们写下的python代码。 因为python是一门开源的语言,python解释器很多。有CPython,PyPy,Ipython,Jython等。 最常用的还是CPython了。CPython是python官方版本的解释器，是用C语言开发的。我们从python官网下载安装python开发环境后，在命令行下运行python就是启动CPython解释器。
##下载python源码包
-
先声明一下，我是在ubuntu 15.04下操作的，对于windows等平台，这里不做说明。(windows下直接下载二进制包安装，一路下一步就好了。还可以勾选配置到系统环境变量，如果没记错的话) 关于是学习python2.7还是python3.x，这里不下定论。一句话，爱学哪个学那个。关于两者区别，可以看这里。我这里使用的是2.7.10版本。 python 2.7.10 release版下载
##编译python
下载完Python-2.7.10.tar.xz后进行解压
o@o-pc:~$ tar -xJvf Python-2.7.10.tar.xz  解压后进入Python-2.7.10目录，执行
o@o-pc:~/Python-2.7.10$ ./configure  如果你的gcc/g++都存在的话，通常能够正常配置成功，生成Makefile文件。如果有需要，你还可以指定相关的选项，例如安装目录等。可以通过./configure --help来查看有哪些选项。
这里没有做过多的设置，全部使用默认设置进行的配置。配置完成后，开始编译
o@o-pc:~/Python-2.7.10$ make  make的过程中可能会有一些警告warning，这个不用管它，只要不是error即可。
##安装python
编译完成后，就可以安装python了。使用下面的命令进行安装
o@o-pc:~/Python-2.7.10$sudo make install  因为之前配置的时候，没有指定安装目录，那么就会安装到默认目录/usr/local/lib/python2.7，所有需要root权限。
- 安装完成后可以测试一下(我这里执行python2.7是因为我机器上还装有其他版本的python)
o@o-pc:~$ python2.7 Python 2.7.10 (default, Jun 17 2015, 14:15:05) [GCC 4.9.2] on linux2 Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt;  </description>
    </item>
    
    <item>
      <title>2-python学习——hello world</title>
      <link>http://sotex.github.io/post/2015-06-23-2-python%E5%AD%A6%E4%B9%A0hello-world/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-2-python%E5%AD%A6%E4%B9%A0hello-world/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594840.html &amp;ldquo;hello world&amp;rdquo;是编程界一个经久不衰的例子，几乎所有语言的学习教程都把它当做第一个程序的范例。学习的过程就是再造轮子的过程，千万不要以为有人做过的，就不去学习了。
##hello world
我们先打开CPython解释器。
o@o-pc:~$ python2.7 Python 2.7.10 (default, Jun 17 2015, 14:15:05) [GCC 4.9.2] on linux2 Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt;  打开之后就可以在&amp;gt;&amp;gt;&amp;gt;的后面输入python语句了。 我们先试一下print这个命令，看是否成功输出&amp;rdquo;hello world&amp;rdquo;
&amp;gt;&amp;gt;&amp;gt; print &amp;quot;hello world&amp;quot; hello world  因为这是在python2.7环境下，如果切换到python3.x这就行不通了。不信请看
o@o-pc:~$ python3.4 Python 3.4.3 (default, Mar 26 2015, 22:03:40) [GCC 4.9.2] on linux Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt; print &amp;quot;hello world&amp;quot; File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1 print &amp;quot;hello world&amp;quot; ^ SyntaxError: Missing parentheses in call to &#39;print&#39;  在python3.</description>
    </item>
    
    <item>
      <title>3-python学习——变量</title>
      <link>http://sotex.github.io/post/2015-06-23-3-python%E5%AD%A6%E4%B9%A0%E5%8F%98%E9%87%8F/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-3-python%E5%AD%A6%E4%B9%A0%E5%8F%98%E9%87%8F/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594846.html 变量是我所接触过的编程语言中都具有的一个概念，只是这个概念有的强有的弱罢了。
##1、什么是python的变量
变量这个东西怎么解释呢？不怎么好说。 这么说吧，变量就相当于一个代名词，或者说是名字。 计算机处理的都是二进制的数据，而变量就代表了一些二进制数据。 例如变量a给它赋值为5，那么a就代表了一块内存区域，这块区域保存的数据是5。然后又让a=&amp;quot;nihao&amp;quot;，那么a就不在代表那块保存数据5的内存区域了，而改为代表保存了数据&amp;quot;nihao&amp;quot;的内存区域。
##2、变量声明与赋值
python变量与C/C++这些强类型编程语言不同，它是弱类型的，也就是变量的类型并不是从一而终的(一次确定，终身不变)。
- python的变量，与对应内存区域的关系是可变的。当重新给变量赋值的时候，如果新赋值的类型与当前保存数据的类型不同，将会重新分派内存区域。
- 我们并不需要显示的声明一个变量，实际上这也行不通。可以看下面
&amp;gt;&amp;gt;&amp;gt; x Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; NameError: name &#39;x&#39; is not defined &amp;gt;&amp;gt;&amp;gt; print(x) Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; NameError: name &#39;x&#39; is not defined  我们这里想声明一个变量，但是会报错，原因是它不知道这个x是什么。
###变量赋值
我们在声明变量的时候，必须给变量赋一个初始值。 等号(=)来赋值给变量。
赋值方式以 变量 = 值。等于号=的左边是变量，右侧的是在变量中存储的值。 举个例子 下面什么了三个变量，然后输出了一下。 再对x重新赋值为字符串&amp;quot;你好&amp;quot;，然后重新输出。 对于中文字符串，这里输出的是十六进制的结果。如果在python3.x下，是可以正常输出中文的。
&amp;gt;&amp;gt;&amp;gt; x=123 &amp;gt;&amp;gt;&amp;gt; y=345 &amp;gt;&amp;gt;&amp;gt; z=x*y &amp;gt;&amp;gt;&amp;gt; print(x,y,z) (123, 345, 42435) &amp;gt;&amp;gt;&amp;gt; x=&amp;quot;你好&amp;quot; &amp;gt;&amp;gt;&amp;gt; print(x,y,z) (&#39;\xe4\xbd\xa0\xe5\xa5\xbd&#39;, 345, 42435)  多重赋值：  Python允许同时指定一个值给几个变量。例如：</description>
    </item>
    
    <item>
      <title>4-python学习——数据操作</title>
      <link>http://sotex.github.io/post/2015-06-23-4-python%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-4-python%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594853.html #4-python学习——数据操作
参考python类型转换、数值操作(收藏)
Python基本运算符
##数据类型转换：
有时候，可能需要执行的内置类型之间的转换。类型之间的转换，只需使用类名作为函数。
有几个内置的功能，从一种数据类型进行转换为另一种。这些函数返回一个表示转换值的新对象。
   函数 描述     int(x [,base]) 将x转换为一个整数。基数指定为base，如果x是一个字符串。   long(x [,base] ) 将x转换为一个长整数。基数指定为base，如果x是一个字符串。   float(x) 将x转换到一个浮点数。   complex(real [,imag]) 创建一个复数。   str(x) 转换对象x为字符串表示形式。   repr(x) 对象x转换为一个表达式字符串。   eval(str) 计算一个字符串，并返回一个对象。   tuple(s) 把s转换为一个元组。   list(s) 把s转换为一个列表。   set(s) 把s转换为一个集合。   dict(d) 创建一个字典。 d必须的（键，值）元组序列。   frozenset(s) 把s转换为冻结集。   chr(x) 整数转换为一个字符。   unichr(x) 整数转换为一个Unicode字符。   ord(x) 转换单个字符为整数值。   hex(x) 将整数转换为十六进制字符串。   oct(x) 将整数转换为以八进制的字符串。    ##数值操作</description>
    </item>
    
    <item>
      <title>Linux下编译安装Apache Http Server</title>
      <link>http://sotex.github.io/post/2015-06-23-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85apache-http-server/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-linux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85apache-http-server/</guid>
      <description>#Linux下编译安装Apache Http Server [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595115.html
##1.下载httpd-2.4.12.tar.bz2 wget http://mirror.bit.edu.cn/apache/httpd/httpd-2.4.12.tar.bz2 ##2.解压下载的文件## tar -xjvf httpd-2.4.12.tar.bz2 ##3.configure配置编译安装条件 ./configure &amp;ndash;prefix=/usr/local/apache2 &amp;ndash;enable-so &amp;ndash;enable-rewrite
   配置 说明     &amp;ndash;prefix=/usr/local/apach2 设置编译安装到的系统目录   &amp;ndash;enable-s 使httpd服务能够动态加载模块功能   &amp;ndash;enable-rewrite 使httpd服务具有网页地址重写功能    ARP not found 错误 o@o-pc:~/work/Apache-httpd-2.4.12$ ./configure --prefix=/usr/local/apache2 --enable-so --enable-rewrite checking for chosen layout... Apache checking for working mkdir -p... yes checking for grep that handles long lines and -e... /bin/grep checking for egrep.</description>
    </item>
    
    <item>
      <title>String封装——读时共享，写时复制</title>
      <link>http://sotex.github.io/post/2015-06-23-string%E5%B0%81%E8%A3%85%E8%AF%BB%E6%97%B6%E5%85%B1%E4%BA%AB%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-string%E5%B0%81%E8%A3%85%E8%AF%BB%E6%97%B6%E5%85%B1%E4%BA%AB%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594868.html 碰到过一位一直怀疑C++标准库（STL）效率的人，他说STL效率太低，企业开发根本不会用。我是持反对意见的。 说这话的人，肯定没有做过大量的调查。没有调查就没有发言权。 STL的效率是不低的，足够满足现在的绝大部分需求了。特别是当前的操作系统和硬件都以页为内存的基本管理单位，并且32位的系统(嵌入式还挺多的，但是嵌入式对内存的需求很大的比较少吧)的已经不是很多了。内存碎片的问题也就并不明显了。
前面说的与这里要说的是无关的，这里指向说一说String封装中的读共享，写复制。
学习过linux/unix系统编程的人，应该对读共享，写复制这个概念有一个比较清晰的了解，这个可见APUE的进程相关的章节。
##实现原理
这个实现原理其实很简单，如果学习了shared_ptr智能指针，那应该是可以猜得到的。
其实关键的地方就是引用计数了。如果在string对象拷贝构造或者赋值(用已有对象)的时候，不进行拷贝，而只是进行引用计数的增加，数据采用共享方式。而在需要进行写操作的时候，才进行真正的拷贝操作。
##代码实现
这里只是一个简单的实现，来说明这个原理，并没有多少实用价值。并且没有做到多线程安全。现在一般的也不会采取这种做法，因为现在内存都比较富裕了，还要解决多线程安全问题。VC6还是采用的COW技术，现在编译器自带的STL基本都不在采用，而改用(忘记名字了，原理就是内部使用一个数组，只有创建的字符串长度超过这个数组的时候，才进行内存分配)。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; struct shared_ptr{ char*	data;	//数据 int	ref;	//引用计数 }; class String{ public: String(const char* str=NULL):iswrite(false) { p = new shared_ptr; if( str != NULL){ p-&amp;gt;data = new char[strlen(str)+1]; strcpy(p-&amp;gt;data,str); } else{ p-&amp;gt;data = new char[1]; p-&amp;gt;data[0]=&#39;\0&#39;; } p-&amp;gt;ref = 1; } String(const String&amp;amp; s):iswrite(false) { p = s.p; p-&amp;gt;ref += 1; } ~String() { if(p-&amp;gt;ref == 1){ delete p-&amp;gt;data; delete p; } else{ p-&amp;gt;ref -=1; } } String&amp;amp; erase(int first,int last) { if(first &amp;lt; 0 ||last &amp;gt; strlen(p-&amp;gt;data))return *this; if(!</description>
    </item>
    
    <item>
      <title>Ubuntu14.04安装intel集显驱动</title>
      <link>http://sotex.github.io/post/2015-06-23-ubuntu14.04%E5%AE%89%E8%A3%85intel%E9%9B%86%E6%98%BE%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-ubuntu14.04%E5%AE%89%E8%A3%85intel%E9%9B%86%E6%98%BE%E9%A9%B1%E5%8A%A8/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595134.html
Ubuntu14.04安装intel集显驱动 标签（空格分隔）： ubuntu linux 驱动安装
##1.查看本机显卡型号 使用lspci命令来获取PCI接口硬件信息
o@o-pc:~$ lspci | grep -i vga 00:02.0 VGA compatible controller: Intel Corporation 4th Gen Core Processor Integrated Graphics Controller (rev 06) 02:00.0 VGA compatible controller: NVIDIA Corporation GK208M [GeForce GT 730M] (rev a1)  我们可以看到本机的显卡有两个，一个是intel的第四代集显(其实是HD4600)，一个是英伟达的NVIDIA GT 730M。 ##2.去英特尔官网下载对应的驱动 英特尔官网有一个下载中心，里面选择或输入产品型号即可搜索。 我需要的驱动下载地址是 https://download.01.org/gfx/ubuntu/14.04/main/pool/main/i/intel-linux-graphics-installer/intel-linux-graphics-installer_1.0.7-0intel1_amd64.deb ##3.安装驱动 这里会碰到一个问题，它的依赖关系不满足，需要先安装ttf-ancient-fonts
o@o-pc:~$ sudo apt-get install ttf-ancient-fonts ... o@o-pc:~$ sudo dpkg -i intel-linux-graphics-installer_1.0.7-0intel1_amd64.deb (正在读取数据库 ... 系统当前共安装有 171559 个文件和目录。) 正准备解包 intel-linux-graphics-installer_1.</description>
    </item>
    
    <item>
      <title>linux回收站设计</title>
      <link>http://sotex.github.io/post/2015-06-23-linux%E5%9B%9E%E6%94%B6%E7%AB%99%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-linux%E5%9B%9E%E6%94%B6%E7%AB%99%E8%AE%BE%E8%AE%A1/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4594913.html #linux回收站设计
在windows下有一个很好的东西，那就是回收站，虽然有很多人批评它。linux不是没有回收站，很多桌面环境都可以看到是有回收站的。 这里是讨论如何设计一个回收站，而不是有没有的问题。最好的结果是将rm命令使用mv命令替代使用了。
##1、设计思路
因为在linux下rm命令执行成功就直接将文件删除了，而不是将其移入回收站了，也没用给一个用于确认的命令提示，所以rm的误操作是很危险的。而使用mv命令来提供一个后悔机制，就挺好了。 我们可以设计这么一种操作，将rm命令用mv命令来改写，将要删除的文件，移动到一个隐藏的目录中。windows上的回收站就是这么做的，这是通常的做法。但是这还有一些问题，如下几点
1.文件同名问题。在一个目录下，不允许出现同名文件或者文件夹的问题。 2.恢复删除文件问题。如果只是简单的将要删除的文件移动到隐藏目录，那么就丢失了它原本所处的位置(路径)信息，不利于恢复到原目录。 3.不同分区问题。linux不同于windows，linux的目录结构并不体现出磁盘分区，所以单纯的根据文件路径不能确定其所在的分区。而如果不针对每个分区分设回收站，那么效率是很低的，因为不同分区间的文件移动，是会有拷贝过程的，而不仅仅只是目录项的操作。
##2、设计思路问题分析
###1、文件同名问题
文件同名的问题可以采取给文件编号的方式来解决。可以按照删除的顺序，给文件名加上一个数字前缀，这个数字从0开始，一直向上增加，就不会出现重复问题。对于这个数字，可以采取非十进制的设计来使得文件名更短小。比如说采取64进制的方式，以[0-9A-Za-z-_]这64个可见的可用于作为文件名的字符来作为前缀的&amp;rdquo;字符集&amp;rdquo;，如果是64进制的话，那么需要的前缀长度可以选择固定长度，且不会很长。因为64=2^6，而2^32次方就已经大到42亿了，所以这里采用7或者8位就差不多足够了。对于整个文件夹删除的，仅仅对文件夹名加前缀就可以了。为了提高效率，还可以采取在前缀编号出现了空洞的时候(先删除了100个文件，又恢复了中间的20个，就出现了20个空洞的编号)，采取不填补的原则，直接往后递增。当编号递增到最大值的时候，可以采取类似于磁盘整理的方式来进行前缀整理。
这里举一个例子,假设这里采取7位固定前缀。
   删除的文件（夹）名 移动到回收站后的文件名     a.txt 0000000a.txt   b.jpg 0000001b.jpg   &amp;hellip;删除了多个文件后 &amp;hellip;   tree.c 000001btree.c   dir 0000001cdir    这样做后，恢复文件的时候，只要去掉其前缀就可以了。采用固定长度前缀是为了提高效率，这里有一个问题没有解决，就是文件名长度的问题。因为绝大多数的文件名长度都远远低于限制大小，所有这个问题影响不大。
###2、恢复删除文件问题
这个问题也很好解决，配合上一个问题的思路来做。因为前面说了给每一个删除的文件都加上了固定不重复的前缀，而文件名不可能为空，所以我们可以采取添加一个文件来纪录原文件所在路径的方式来解决这个问题。
举个栗子：有一个文件在目录/home/xxx/code/c/test/下，文件名是a.c。删除到回收站后，编号为000000km。那么这个文件删除到回收站后，将其文件名改为000000kma.c，那么再建立一个文件000000km这个文件的内容就是/home/xxx/code/c/test。这么做就保存了文件所在的原本路径，恢复的时候根据这个路径来恢复就是了。 ###3、不同分区问题
这个问题要解决也不难，就是针对各个分区设立回收站嘛。主要问题在于获取文件或者文件夹所在的分区。这个不难，可以通过df -h来获取各个分区的挂载点，然后对文件或目录的路径来比对得出其所在的分区即可。这里的一个问题是要不要为了提高效率而存储各个分区挂载路径的结果呢？我觉得是不需要的，使用df -h命令的成本并不高，而且不会涉及到分区卸载后再挂载到另外目录的情况。</description>
    </item>
    
    <item>
      <title>net-snmp-5.7.3配置编译安装</title>
      <link>http://sotex.github.io/post/2015-06-23-net-snmp-5.7.3%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-net-snmp-5.7.3%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</guid>
      <description>net-snmp-5.7.3配置编译安装 [TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595123.html
先看一下系统环境
o@o-pc:~/work/_snmp/net-snmp-5.7.3$ uname -a Linux o-pc 3.16.0-30-generic #40~14.04.1-Ubuntu SMP Thu Jan 15 17:43:14 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux  1.下载net-snmp-5.7.3源码包 net snmp的源码包可以到 net-snmp官网上去下载。也可以到sourcefroce上去下载。 net-snmp-5.4.4版下载
o@o-pc:~/work/_snmp$ wget http://downloads.sourceforge.net/project/net-snmp/net-snmp/5.4.4/net-snmp-5.4.4.tar.gz  net-snmp-5.7.3版下载
o@o-pc:~/work/_snmp$ wget http://downloads.sourceforge.net/project/net-snmp/net-snmp/5.7.3/net-snmp-5.7.3.tar.gz  2.解压net-snmp源码包 o@o-pc:~/work/_snmp$ tar -xzvf net-snmp-5.7.3.tar.gz  3.编译安装配置 进入解压的 net-snmp-5.7.3文件夹。可以看到configure文件，现在就使用这个文件来自动配置。 当然，自动配置也可以定制一些内容，比如安装路径等。
    ./configure参数 含义     &amp;ndash;prefix=/usr/local/net-snmp  net snmp的安装路径   &amp;ndash;enable-mfd-rewrites 允许新的mfd重写可用的mid模块   &amp;ndash;with-default-snmp-version=&amp;ldquo;3&amp;rdquo; 默认的snmp版本   &amp;ndash;with-sys-contact=&amp;ldquo;name,E_mail:maileaddress &amp;rdquo; 该设备的联系人   &amp;ndash;with-sys-location=&amp;ldquo;China&amp;rdquo; 该设备的位置   &amp;ndash;with-logfile=&amp;ldquo;/var/log/snmpd.</description>
    </item>
    
    <item>
      <title>net-snmp的dateandtime数据类型</title>
      <link>http://sotex.github.io/post/2015-06-23-net-snmp%E7%9A%84dateandtime%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-net-snmp%E7%9A%84dateandtime%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595127.html #net-snmp的dateandtime数据类型
2015/06/12 16:35:59 DateAndTime是Snmpv2中的一种数据类型，它主要提供了对日期时间的描述。 在开发一个snmp相关程序的时候，碰到了这个东西。 本文由乌合之众瞎写http://www.cnblogs.com/oloroso
#原由 在开发的时候，某个节点的值是DateAndTime类型的，因为是通过挂载脚本来获取的值，是一个字符串，形似 &amp;quot;2015-06-12 17:04:03&amp;quot; 这样的。现在要将这个值转换为net-snmp管理端可以获取的DateAndTime值。
关于这个结构的描述，在net-snmp源代码目录下的snmplib/snmp-tc.c文件中可以找到。 net-snmp中没有定义这个类型，而是当做一个unsigned char类型的数组，根据各个字段的宽度来操作。
##结构描述如下
   字段 字节数 内容 取值范围     1 1-2 year* 0..65536   2 3 month 1..12   3 4 day 1..31   4 5 hour 0..23   5 6 minutes 0..59   6 7 seconds 0..60     (use 60 for leap-second)    7 8 deci-seconds 0.</description>
    </item>
    
    <item>
      <title>qmake的使用</title>
      <link>http://sotex.github.io/post/2015-06-23-qmake%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-qmake%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595181.html
本文由乌合之众 lym瞎编，欢迎转载 blog.cnblogs.net/oloroso 本文由乌合之众 lym瞎编，欢迎转载 my.oschina.net/oloroso
还是先说一下当前的系统环境：Ubuntu 14.04 + Qt5.4 如果没有安装过QT，可以安装下面几个qt软件
sudo apt-get install qt5-default qt5-doc-html qt5-qmake qt5-doc qt5-image-formats-plugins  -
这只是对qmake使用的一个说明而已。如果一直使用Qt Create来构建工程，很容易让人以为Qt项目必须使用Qt Create来创建。其实我们可以像写普通的C++工程一样，不一定需要IDE，编辑器+编译器即可搞定了。 不过这个有一个缺点，就是如果在connect函数连接信号的槽的时候，即便是槽函数不存在，也能够通过编译。
##1. 先来写源代码 必须先写源代码，这个源代码很简单，就是创建一个Widget,然后widget上面有一个PushButton,点击之后弹出一个MessageBox来提示一个*&amp;ldquo;hello world&amp;rdquo;*。
###hello.h
#ifndef __HELLO_H_ #define __HELLO_H_ #include &amp;lt;QWidget&amp;gt; class hello:public QWidget{ Q_OBJECT public: explicit hello(QWidget *parent = 0); ~hello(); public slots: //槽函数，处理button单击 void btn_click(); private: }; #endif #endif  ###hello.cpp
#include &amp;quot;hello.h&amp;quot; #include &amp;lt;QPushButton&amp;gt; #include &amp;lt;QMessageBox&amp;gt; hello::hello(QWidget *parent) : QWidget(parent){ //创建一个PushButton QPushButton * btn = new QPushButton(&amp;quot;点击我^-^&amp;quot;,this); //连接信号和槽 connect(btn,SIGNAL(clicked()),this,SLOT(btn_click())); } void hello::btn_click() { QMessageBox::information(NULL, &amp;quot;单击了button&amp;quot;, &amp;quot;hello world&amp;quot;, QMessageBox::Yes); }  ###main.</description>
    </item>
    
    <item>
      <title>ubuntu下编译VLC</title>
      <link>http://sotex.github.io/post/2015-06-23-ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91vlc/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91vlc/</guid>
      <description>ubuntu下编译VLC 标签（空格分隔）： ubuntu vlc 视频 编译
[TOC] 博客园原文地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595136.html
##1.下载VLC源码包并解压 VLC的源码包在VLC的官网有，可以直接下载。也可以使用git来clone一个。 git的地址git clone git://git.videolan.org/vlc.git 源码包地址 http://get.videolan.org/vlc/2.2.0/vlc-2.2.0.tar.xz 下载和解压 xz压缩的档案包使用J参数来解压
wget http://get.videolan.org/vlc/2.2.0/vlc-2.2.0.tar.xz o@o-pc:~/work/vlc$ tar -xJvf vlc-2.2.0.tar.xz ... o@o-pc:~/work/vlc$ ls vlc-2.2.0 ABOUT-NLS autotools ChangeLog configure COPYING extras lib Makefile.am NEWS share THANKS aclocal.m4 bin compat configure.ac COPYING.LIB include m4 Makefile.in po src AUTHORS bootstrap config.h.in contrib doc INSTALL make-alias modules README test  ##2.配置编译环境 下面说的东西很多，嫌麻烦的可以先安装依赖包，能够少很多问题。
$ sudo apt-get build-dep vlc  ###2.1使用configure脚本来配置</description>
    </item>
    
    <item>
      <title>将Apache加入到linux系统service</title>
      <link>http://sotex.github.io/post/2015-06-23-%E5%B0%86apache%E5%8A%A0%E5%85%A5%E5%88%B0linux%E7%B3%BB%E7%BB%9Fservice/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://sotex.github.io/post/2015-06-23-%E5%B0%86apache%E5%8A%A0%E5%85%A5%E5%88%B0linux%E7%B3%BB%E7%BB%9Fservice/</guid>
      <description>[TOC] 博客园文章地址 http://www.cnblogs.com/oloroso/archive/2015/06/23/4595142.html #将Apache加入到linux系统service 将apache加入到linux系统服务，用service命令来控制apache的启动和停止。 本文由乌合之众瞎写http://www.cnblogs.com/oloroso ##1.生成Apache服务控制脚本 ###1.1提取/usr/local/apache2/bin/apachectl脚本有效内容 grep -v &amp;quot;#&amp;quot;表示提取不是以#开头的hang
o@o-pc:~/work$ grep -v &amp;quot;#&amp;quot; /usr/local/apache2/bin/apachectl &amp;gt;apache.txt  ###1.2在/etc/init.d目录下创建控制脚本
o@o-pc:~/work$ sudo cat apache.txt &amp;gt;/etc/init.d/apache bash: /etc/init.d/apache: 权限不够  提示权限不够，因为这个目录root账户也没有写权限。 这是我的系统的原因，别的系统不一定默认就是没有写权限的。
o@o-pc:~/work$ stat /etc/init.d/ 文件：&amp;quot;/etc/init.d/&amp;quot; 大小：4096 块：8 IO 块：4096 目录 设备：803h/2051d	Inode：2233490 硬链接：2 权限：(0755/drwxr-xr-x) Uid：( 0/ root) Gid：( 0/ root) 最近访问：2015-05-28 12:27:07.617607855 +0800 最近更改：2015-05-28 09:36:16.162085700 +0800 最近改动：2015-05-28 09:36:16.162085700 +0800 创建时间：-  chmod修改权限，然后写入
o@o-pc:~/work$ sudo chmod a+w /etc/init.d o@o-pc:~/work$ stat /etc/init.d/ 文件：&amp;quot;/etc/init.d/&amp;quot; 大小：4096 块：8 IO 块：4096 目录 设备：803h/2051d	Inode：2233490 硬链接：2 权限：(0777/drwxrwxrwx) Uid：( 0/ root) Gid：( 0/ root) 最近访问：2015-05-28 12:27:07.</description>
    </item>
    
  </channel>
</rss>