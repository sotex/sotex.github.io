---
layout:  post
title:  "使用Dlib来运行基于CNN的人脸检测"
date:  2017-04-13
categories:  其它
tags:  其它
comments: 1
---

[TOC]
[博客园文章地址 http://www.cnblogs.com/oloroso/archive/2017/04/13/6703711.html](http://www.cnblogs.com/oloroso/archive/2017/04/13/6703711.html)
检测结果如下
![](http://images2015.cnblogs.com/blog/693958/201704/693958-20170413141243298-393554728.png)

这个示例程序需要使用较大的内存，请保证内存足够。本程序运行速度比较慢，远不及OpenCV中的人脸检测。

注释中提到的几个文件下载地址如下
[http://dlib.net/face_detection_ex.cpp.html](http://dlib.net/face_detection_ex.cpp.html)
[http://dlib.net/dnn_introduction_ex.cpp.html](http://dlib.net/dnn_introduction_ex.cpp.html)
[http://dlib.net/dnn_introduction2_ex.cpp.html](http://dlib.net/dnn_introduction2_ex.cpp.html)
[http://dlib.net/dnn_mmod_ex.cpp.html](http://dlib.net/dnn_mmod_ex.cpp.html)

```cpp
/*
    这个示例程序展示如何使用Dlib来运行基于CNN的人脸检测。示例程序加载现有训练模型数据，并使用它在图像中查找人脸。CNN模型在运行时比基于HOG模型的检测要精确很多，然而，只有在GPU上执行才能达到较快的速度。例如，在NVIDIA Titan X GPU上，此程序与face_detection_ex.cpp处理图像的速度相同。
    另外，刚刚学习dlib深度学习API的用户应该阅读dnn_introduction_ex.cpp和dnn_introduction2_ex.cpp示例，来了解API的工作原理。有关对象检测方法的介绍，您应该阅读dnn_mmod_ex.cpp



    训练模型 TRAINING THE MODEL
        最后，有兴趣对面部检测器进行训练的用户，可以阅读dnn_mmod_ex.cpp示例程序。
        应该注意的是，本示例程序中使用的面部检测器比dnn_mmod_ex.cpp中展示的具有更
        大的训练数据集和更大的CNN架构，但是其他训练条件是相同的。如果和dnn_mmod_ex.cpp
        代码中的net_type比较，可以看到它们非常相似，只是增加了参数的数量。

        另外，训练中以下训练参数有所不同：
        dnn_mmod_ex.cpp中有以下更改
            mmod_options options(face_boxes_train,40*40)
            trainer.set_iterations_without_progress_threshold(300);
        在以下示例中使用训练数据中使用参数为:
            mmod_options options(face_boxes_train, 80*80);
            trainer.set_iterations_without_progress_threshold(8000);

        此外，random_cropper保持默认设置，所以我们没有调用以下函数:
            cropper.set_chip_dims(200, 200);
            cropper.set_min_object_height(0.2);

        用于训练的数据也可在下面地址中找到
        http://dlib.net/files/data/dlib_face_detection_dataset-2016-09-30.tar.gz
*/


#include <iostream>
#include <dlib/dnn.h>
#include <dlib/data_io.h>
#include <dlib/image_processing.h>
#include <dlib/gui_widgets.h>


using namespace std;
using namespace dlib;

// ----------------------------------------------------------------------------------------

template <long num_filters, typename SUBNET> using con5d = con<num_filters,5,5,2,2,SUBNET>;
template <long num_filters, typename SUBNET> using con5  = con<num_filters,5,5,1,1,SUBNET>;

template <typename SUBNET> using downsampler  = relu<affine<con5d<32, relu<affine<con5d<32, relu<affine<con5d<16,SUBNET>>>>>>>>>;
template <typename SUBNET> using rcon5  = relu<affine<con5<45,SUBNET>>>;

using net_type = loss_mmod<con<1,9,9,1,1,rcon5<rcon5<rcon5<downsampler<input_rgb_image_pyramid<pyramid_down<6>>>>>>>>;

// ----------------------------------------------------------------------------------------


int main(int argc, char** argv) try
{
    argc = 3;
    char* v[] = {
        "test",
        "D:\\Picture\\mmod_human_face_detector.dat", /*这是下载的训练数据*/
        "D:\\Picture\\222209_MIoI_1428332.jpg" /*用于检测的文件*/
    };
    argv = v;

    if (argc == 1)
    {
        cout << "程序的使用，通过类似如下命令:" << endl;
        cout << "./dnn_mmod_face_detection_ex mmod_human_face_detector.dat faces/*.jpg" << endl;
        cout << "\n你可以从下面的地址获取 mmod_human_face_detector.dat 文件:\n";
        cout << "http://dlib.net/files/mmod_human_face_detector.dat.bz2" << endl;
        return 0;
    }


    net_type net;
    deserialize(argv[1]) >> net; // 将训练数据传递给检测器

    image_window win;
    for (int i = 2; i < argc; ++i)
    {
        matrix<rgb_pixel> img;
        load_image(img, argv[i]); // 加载图像

        // 向上采样图像将使得我们能够检测较小的面孔，但会导致程序使用更多的内存，并运行时间更长。
        while(img.size() < 512*512)
            pyramid_up(img);

        // 注意，您可以一次处理std::vector中的一堆图像，并且这样运行速度更快，
        // 因为这将形成小批量的图像，从而利用GPU硬件，获得更好的并行性。
        //但是，所有图像的大小必须相同。为了避免相同尺寸的这一要求，我们在这个例子中单独处理每一张图像。

        auto dets = net(img); // 获取检测结果
        win.clear_overlay();  // 清除已经绘制的
        win.set_image(img);   // 绘制图像
        // 将检测结果绘制在窗口上
        for (auto&& d : dets){
            win.add_overlay(d);
        }

        // 按下enter键去处理下一个图像
        cout << "Hit enter to process the next image." << endl;
        cin.get();
    }
    return 0;
}
catch(std::exception& e)
{
    cout << e.what() << endl;
}
```