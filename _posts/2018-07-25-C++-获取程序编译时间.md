---
layout:  post
title:  "C++ 获取程序编译时间"
date:  2018-07-25
categories:  编程
tags:  编程
comments: 1
---

[TOC]
[博客园文章地址 http://www.cnblogs.com/oloroso/archive/2018/07/25/9365749.html](http://www.cnblogs.com/oloroso/archive/2018/07/25/9365749.html)
一个简单的需求，就是需要程序判断当前系统的时间是不是在程序编译之后的，如果系统当前时间在编译之前，那说明这台机器的时间是不正确的，需要终止程序运行。
因为要在程序编译时候获取时间，如果每次编译前手动修改的话，稍微显得麻烦了一点。

## Windows下VS2015
VC中可以使用[Visual c + + 编译器预定义的宏](https://msdn.microsoft.com/zh-cn/library/b0084kay(v=vs.140).aspx)来获取编译时间，有`__DATE__` `__TIME__`(这两个是ISO C99 和 ISO C + + 14 标准预定义的宏)`__TIMESTAMP__`(这个是VS预定义的)三个宏可以获取，但是获取到的是字符串形式的时间，所以不太利于进行比较。
这里写一个函数，用来获取编译时候的时间。
```C++
// 获取编译时间
VOID GetCompileTime(LPSYSTEMTIME lpCompileTime)
{
	char Mmm[4] = "Jan";
	sscanf_s(__DATE__, "%3s %hu %hu", Mmm,sizeof(Mmm),
		&lpCompileTime->wDay, &lpCompileTime->wYear);
	Mmm[3] = Mmm[2]; Mmm[2] = Mmm[0]; Mmm[0] = Mmm[3]; Mmm[3] = 0;

	switch (*(DWORD*)Mmm) {
		case (DWORD)('Jan'): lpCompileTime->wMonth = 1; break;
		case (DWORD)('Feb'): lpCompileTime->wMonth = 2; break;
		case (DWORD)('Mar'): lpCompileTime->wMonth = 3; break;
		case (DWORD)('Apr'): lpCompileTime->wMonth = 4; break;
		case (DWORD)('May'): lpCompileTime->wMonth = 5; break;
		case (DWORD)('Jun'): lpCompileTime->wMonth = 6; break;
		case (DWORD)('Jul'): lpCompileTime->wMonth = 7; break;
		case (DWORD)('Aug'): lpCompileTime->wMonth = 8; break;
		case (DWORD)('Sep'): lpCompileTime->wMonth = 9; break;
		case (DWORD)('Oct'): lpCompileTime->wMonth = 10; break;
		case (DWORD)('Nov'): lpCompileTime->wMonth = 11; break;
		case (DWORD)('Dec'): lpCompileTime->wMonth = 12; break;
		default:lpCompileTime->wMonth = 0;
	}
	sscanf_s(__TIME__, "%hu:%hu:%hu", &lpCompileTime->wHour,
		&lpCompileTime->wMinute, &lpCompileTime->wSecond);
	lpCompileTime->wDayOfWeek = lpCompileTime->wMilliseconds = 0;
}
```
因为编译器给出的时间实际上是本地时间，所以这里如果进行判断的话，可以与`GetLocalTime`的结果进行比较。
```C++
	SYSTEMTIME lt, ct;
	GetLocalTime(&lt);
	GetCompileTime(&ct);

	FILETIME flt, fct;
	SystemTimeToFileTime(&lt, &flt);
	SystemTimeToFileTime(&ct, &fct);
	
	if (flt.dwHighDateTime < fct.dwHighDateTime || 
		(flt.dwHighDateTime == fct.dwHighDateTime && flt.dwLowDateTime < fct.dwLowDateTime)) {
		// Todo
	}
```
**这里没有考虑不同时区的问题。**

## Clang或GCC
Clang和GCC下可以使用`__DATE__`和`__TIME__`宏来获取编译时间，这两个在多字节字符常量上与VS的处理有些不同。不多说，直接放代码。
```C++
void GetCompileTime(struct tm* lpCompileTime)
{
	char Mmm[4] = "Jan";
	sscanf(__DATE__, "%3s %d %d", Mmm,
				&lpCompileTime->tm_mday, &lpCompileTime->tm_year);
	lpCompileTime->tm_year -= 1900;

	switch (*(uint32_t*)Mmm) {
		case (uint32_t)('Jan'): lpCompileTime->tm_mon = 1; break;
		case (uint32_t)('Feb'): lpCompileTime->tm_mon = 2; break;
		case (uint32_t)('Mar'): lpCompileTime->tm_mon = 3; break;
		case (uint32_t)('Apr'): lpCompileTime->tm_mon = 4; break;
		case (uint32_t)('May'): lpCompileTime->tm_mon = 5; break;
		case (uint32_t)('Jun'): lpCompileTime->tm_mon = 6; break;
		case (uint32_t)('Jul'): lpCompileTime->tm_mon = 7; break;
		case (uint32_t)('Aug'): lpCompileTime->tm_mon = 8; break;
		case (uint32_t)('Sep'): lpCompileTime->tm_mon = 9; break;
		case (uint32_t)('Oct'): lpCompileTime->tm_mon = 10; break;
		case (uint32_t)('Nov'): lpCompileTime->tm_mon = 11; break;
		case (uint32_t)('Dec'): lpCompileTime->tm_mon = 12; break;
		default:lpCompileTime->tm_mon = 0;
	}
	sscanf(__TIME__, "%d:%d:%d", &lpCompileTime->tm_hour,
				&lpCompileTime->tm_min, &lpCompileTime->tm_sec);
	lpCompileTime->tm_isdst = lpCompileTime->tm_wday = lpCompileTime->tm_yday = 0;
}
```